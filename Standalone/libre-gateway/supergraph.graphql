schema
  @core(feature: "https://specs.apollo.dev/core/v0.1"),
  @core(feature: "https://specs.apollo.dev/join/v0.1")
{
  query: Query
  mutation: Mutation
}

directive @core(feature: String!) repeatable on SCHEMA

directive @join__field(graph: join__Graph, requires: join__FieldSet, provides: join__FieldSet) on FIELD_DEFINITION

directive @join__type(graph: join__Graph!, key: join__FieldSet) repeatable on OBJECT | INTERFACE

directive @join__owner(graph: join__Graph!) on OBJECT | INTERFACE

directive @join__graph(name: String!, url: String!) on ENUM_VALUE

directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

enum AccessLevel {
  MODERATOR
  OWNER
  VIEWER
}

type AccessRight {
  forRole(filter: RoleFilter): Role
  id: ID!
  isActive: Boolean
  name: AccessRights
}

type AccessRightAggregateResult {
  count: Int
}

input AccessRightFilter {
  and: [AccessRightFilter]
  has: [AccessRightHasFilter]
  id: [ID!]
  name: AccessRights_hash
  not: AccessRightFilter
  or: [AccessRightFilter]
}

enum AccessRightHasFilter {
  forRole
  isActive
  name
}

input AccessRightPatch {
  forRole: RoleRef
  isActive: Boolean
  name: AccessRights
}

input AccessRightRef {
  forRole: RoleRef
  id: ID
  isActive: Boolean
  name: AccessRights
}

enum AccessRights {
  addACL
  addAccessRight
  addAddress
  addBillOfMaterial
  addBox
  addCarrier
  addEquipment
  addEquipmentClass
  addEquipmentNameAlias
  addEquipmentPropertyOverride
  addEquipmentReasonOverride
  addEquipmentSpecification
  addEventDefinition
  addEventLog
  addForm
  addGeneralLedgerAccount
  addInventoryHandlingPolicy
  addInventoryHandlingRule
  addJobOrder
  addJobResponse
  addMaterialAlternate
  addMaterialClass
  addMaterialDefinition
  addMaterialEquipment
  addMaterialEventRuleset
  addMaterialLot
  addMaterialSpecification
  addMaterialStateModel
  addMaterialStateTransition
  addMaterialStatus
  addMaterialSubLot
  addMaterialUnit
  addMenu
  addOperationsDefinition
  addOperationsRequest
  addOperationsSegment
  addOrder
  addOrderLine
  addOrderStartRuleset
  addPartner
  addPayloadFieldDefinition
  addPerson
  addPersonnelClass
  addPersonnelSpecification
  addProperty
  addPropertyNameAlias
  addPropertyValueAlias
  addQuantityLog
  addReason
  addReasonCategory
  addRequestState
  addRole
  addSegmentDependency
  addSegmentInvoiceSetting
  addShipment
  addShipmentItem
  addStateEventRuleset
  addTestResult
  addTestSpecification
  addTransitionEventRuleset
  addUnitOfMeasure
  addUnitOfMeasureConversion
  addUser
  addUserRole
  addWorkCalendar
  addWorkCalendarDefinitionEntry
  addWorkCalendarEntry
  addWorkflowConnection
  addWorkflowConnectionType
  addWorkflowInstance
  addWorkflowNode
  addWorkflowNodeEvent
  addWorkflowNodeInstance
  addWorkflowNodeType
  addWorkflowProperty
  addWorkflowPropertyInstance
  addWorkflowPropertyValue
  addWorkflowSpecification
  aggregateACL
  aggregateAccessRight
  aggregateAddress
  aggregateBillOfMaterial
  aggregateBox
  aggregateCarrier
  aggregateEquipment
  aggregateEquipmentClass
  aggregateEquipmentNameAlias
  aggregateEquipmentPropertyOverride
  aggregateEquipmentReasonOverride
  aggregateEquipmentSpecification
  aggregateEventDefinition
  aggregateEventLog
  aggregateForm
  aggregateGeneralLedgerAccount
  aggregateInventoryHandlingPolicy
  aggregateInventoryHandlingRule
  aggregateJobOrder
  aggregateJobResponse
  aggregateMaterialAlternate
  aggregateMaterialClass
  aggregateMaterialDefinition
  aggregateMaterialEquipment
  aggregateMaterialEventRuleset
  aggregateMaterialLot
  aggregateMaterialSpecification
  aggregateMaterialStateModel
  aggregateMaterialStateTransition
  aggregateMaterialStatus
  aggregateMaterialSubLot
  aggregateMaterialUnit
  aggregateMenu
  aggregateOperationsDefinition
  aggregateOperationsRequest
  aggregateOperationsSegment
  aggregateOrder
  aggregateOrderLine
  aggregateOrderStartRuleset
  aggregatePartner
  aggregatePayloadFieldDefinition
  aggregatePerson
  aggregatePersonnelClass
  aggregatePersonnelSpecification
  aggregateProperty
  aggregatePropertyNameAlias
  aggregatePropertyValueAlias
  aggregateQuantityLog
  aggregateReason
  aggregateReasonCategory
  aggregateRequestState
  aggregateRole
  aggregateSegmentDependency
  aggregateSegmentInvoiceSetting
  aggregateShipment
  aggregateShipmentItem
  aggregateStateEventRuleset
  aggregateTestResult
  aggregateTestSpecification
  aggregateTransitionEventRuleset
  aggregateUnitOfMeasure
  aggregateUnitOfMeasureConversion
  aggregateUser
  aggregateUserRole
  aggregateWorkCalendar
  aggregateWorkCalendarDefinitionEntry
  aggregateWorkCalendarEntry
  aggregateWorkflowConnection
  aggregateWorkflowConnectionType
  aggregateWorkflowInstance
  aggregateWorkflowNode
  aggregateWorkflowNodeEvent
  aggregateWorkflowNodeInstance
  aggregateWorkflowNodeType
  aggregateWorkflowProperty
  aggregateWorkflowPropertyInstance
  aggregateWorkflowPropertyValue
  aggregateWorkflowSpecification
  deleteACL
  deleteAccessRight
  deleteAddress
  deleteBillOfMaterial
  deleteBox
  deleteCarrier
  deleteEquipment
  deleteEquipmentClass
  deleteEquipmentNameAlias
  deleteEquipmentPropertyOverride
  deleteEquipmentReasonOverride
  deleteEquipmentSpecification
  deleteEventDefinition
  deleteEventLog
  deleteForm
  deleteGeneralLedgerAccount
  deleteInventoryHandlingPolicy
  deleteInventoryHandlingRule
  deleteJobOrder
  deleteJobResponse
  deleteMaterialAlternate
  deleteMaterialClass
  deleteMaterialDefinition
  deleteMaterialEquipment
  deleteMaterialEventRuleset
  deleteMaterialLot
  deleteMaterialSpecification
  deleteMaterialStateModel
  deleteMaterialStateTransition
  deleteMaterialStatus
  deleteMaterialSubLot
  deleteMaterialUnit
  deleteMenu
  deleteOperationsDefinition
  deleteOperationsRequest
  deleteOperationsSegment
  deleteOrder
  deleteOrderLine
  deleteOrderStartRuleset
  deletePartner
  deletePayloadFieldDefinition
  deletePerson
  deletePersonnelClass
  deletePersonnelSpecification
  deleteProperty
  deletePropertyNameAlias
  deletePropertyValueAlias
  deleteQuantityLog
  deleteReason
  deleteReasonCategory
  deleteRequestState
  deleteRole
  deleteSegmentDependency
  deleteSegmentInvoiceSetting
  deleteShipment
  deleteShipmentItem
  deleteStateEventRuleset
  deleteTestResult
  deleteTestSpecification
  deleteTransitionEventRuleset
  deleteUnitOfMeasure
  deleteUnitOfMeasureConversion
  deleteUser
  deleteUserRole
  deleteWorkCalendar
  deleteWorkCalendarDefinitionEntry
  deleteWorkCalendarEntry
  deleteWorkflowConnection
  deleteWorkflowConnectionType
  deleteWorkflowInstance
  deleteWorkflowNode
  deleteWorkflowNodeEvent
  deleteWorkflowNodeInstance
  deleteWorkflowNodeType
  deleteWorkflowProperty
  deleteWorkflowPropertyInstance
  deleteWorkflowPropertyValue
  deleteWorkflowSpecification
  getACL
  getAccessRight
  getAddress
  getBillOfMaterial
  getBox
  getCarrier
  getEquipment
  getEquipmentClass
  getEquipmentNameAlias
  getEquipmentPropertyOverride
  getEquipmentReasonOverride
  getEquipmentSpecification
  getEventDefinition
  getEventLog
  getForm
  getGeneralLedgerAccount
  getInventoryHandlingPolicy
  getInventoryHandlingRule
  getJobOrder
  getJobResponse
  getMaterialAlternate
  getMaterialClass
  getMaterialDefinition
  getMaterialEquipment
  getMaterialEventRuleset
  getMaterialLot
  getMaterialSpecification
  getMaterialStateModel
  getMaterialStateTransition
  getMaterialStatus
  getMaterialSubLot
  getMaterialUnit
  getMenu
  getOperationsDefinition
  getOperationsRequest
  getOperationsSegment
  getOrder
  getOrderLine
  getOrderStartRuleset
  getPartner
  getPayloadFieldDefinition
  getPerson
  getPersonnelClass
  getPersonnelSpecification
  getProperty
  getPropertyNameAlias
  getPropertyValueAlias
  getQuantityLog
  getReason
  getReasonCategory
  getRequestState
  getRole
  getSegmentDependency
  getSegmentInvoiceSetting
  getShipment
  getShipmentItem
  getStateEventRuleset
  getTestResult
  getTestSpecification
  getTransitionEventRuleset
  getUnitOfMeasure
  getUnitOfMeasureConversion
  getUser
  getUserRole
  getWorkCalendar
  getWorkCalendarDefinitionEntry
  getWorkCalendarEntry
  getWorkflowConnection
  getWorkflowConnectionType
  getWorkflowInstance
  getWorkflowNode
  getWorkflowNodeEvent
  getWorkflowNodeInstance
  getWorkflowNodeType
  getWorkflowProperty
  getWorkflowPropertyInstance
  getWorkflowPropertyValue
  getWorkflowSpecification
  isAdmin
  queryACL
  queryAccessRight
  queryAddress
  queryBillOfMaterial
  queryBox
  queryCarrier
  queryEquipment
  queryEquipmentClass
  queryEquipmentNameAlias
  queryEquipmentPropertyOverride
  queryEquipmentReasonOverride
  queryEquipmentSpecification
  queryEventDefinition
  queryEventLog
  queryForm
  queryGeneralLedgerAccount
  queryInventoryHandlingPolicy
  queryInventoryHandlingRule
  queryJobOrder
  queryJobResponse
  queryMaterialAlternate
  queryMaterialClass
  queryMaterialDefinition
  queryMaterialEquipment
  queryMaterialEventRuleset
  queryMaterialLot
  queryMaterialSpecification
  queryMaterialStateModel
  queryMaterialStateTransition
  queryMaterialStatus
  queryMaterialSubLot
  queryMaterialUnit
  queryMenu
  queryOperationsDefinition
  queryOperationsRequest
  queryOperationsSegment
  queryOrder
  queryOrderLine
  queryOrderStartRuleset
  queryPartner
  queryPayloadFieldDefinition
  queryPerson
  queryPersonnelClass
  queryPersonnelSpecification
  queryProperty
  queryPropertyNameAlias
  queryPropertyValueAlias
  queryQuantityLog
  queryReason
  queryReasonCategory
  queryRequestState
  queryRole
  querySegmentDependency
  querySegmentInvoiceSetting
  queryShipment
  queryShipmentItem
  queryStateEventRuleset
  queryTestResult
  queryTestSpecification
  queryTransitionEventRuleset
  queryUnitOfMeasure
  queryUnitOfMeasureConversion
  queryUser
  queryUserRole
  queryWorkCalendar
  queryWorkCalendarDefinitionEntry
  queryWorkCalendarEntry
  queryWorkflowConnection
  queryWorkflowConnectionType
  queryWorkflowInstance
  queryWorkflowNode
  queryWorkflowNodeEvent
  queryWorkflowNodeInstance
  queryWorkflowNodeType
  queryWorkflowProperty
  queryWorkflowPropertyInstance
  queryWorkflowPropertyValue
  queryWorkflowSpecification
  updateACL
  updateAccessRight
  updateAddress
  updateBillOfMaterial
  updateBox
  updateCarrier
  updateEquipment
  updateEquipmentClass
  updateEquipmentNameAlias
  updateEquipmentPropertyOverride
  updateEquipmentReasonOverride
  updateEquipmentSpecification
  updateEventDefinition
  updateEventLog
  updateForm
  updateGeneralLedgerAccount
  updateInventoryHandlingPolicy
  updateInventoryHandlingRule
  updateJobOrder
  updateJobResponse
  updateMaterialAlternate
  updateMaterialClass
  updateMaterialDefinition
  updateMaterialEquipment
  updateMaterialEventRuleset
  updateMaterialLot
  updateMaterialSpecification
  updateMaterialStateModel
  updateMaterialStateTransition
  updateMaterialStatus
  updateMaterialSubLot
  updateMaterialUnit
  updateMenu
  updateOperationsDefinition
  updateOperationsRequest
  updateOperationsSegment
  updateOrder
  updateOrderLine
  updateOrderStartRuleset
  updatePartner
  updatePayloadFieldDefinition
  updatePerson
  updatePersonnelClass
  updatePersonnelSpecification
  updateProperty
  updatePropertyNameAlias
  updatePropertyValueAlias
  updateQuantityLog
  updateReason
  updateReasonCategory
  updateRequestState
  updateRole
  updateSegmentDependency
  updateSegmentInvoiceSetting
  updateShipment
  updateShipmentItem
  updateStateEventRuleset
  updateTestResult
  updateTestSpecification
  updateTransitionEventRuleset
  updateUnitOfMeasure
  updateUnitOfMeasureConversion
  updateUser
  updateUserRole
  updateWorkCalendar
  updateWorkCalendarDefinitionEntry
  updateWorkCalendarEntry
  updateWorkflowConnection
  updateWorkflowConnectionType
  updateWorkflowInstance
  updateWorkflowNode
  updateWorkflowNodeEvent
  updateWorkflowNodeInstance
  updateWorkflowNodeType
  updateWorkflowProperty
  updateWorkflowPropertyInstance
  updateWorkflowPropertyValue
  updateWorkflowSpecification
}

input AccessRights_hash {
  eq: AccessRights
  in: [AccessRights]
}

type ACL {
  grants(filter: RoleFilter): Role
  id: ID!
  isActive: Boolean
  level: AccessLevel
}

type ACLAggregateResult {
  count: Int
}

input ACLFilter {
  and: [ACLFilter]
  has: [ACLHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ACLFilter
  or: [ACLFilter]
}

enum ACLHasFilter {
  grants
  isActive
  level
}

input ACLPatch {
  grants: RoleRef
  isActive: Boolean
  level: AccessLevel
}

input ACLRef {
  grants: RoleRef
  id: ID
  isActive: Boolean
  level: AccessLevel
}

input AddAccessRightInput {
  forRole: RoleRef
  isActive: Boolean
  name: AccessRights
}

type AddAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  numUids: Int
}

input AddACLInput {
  grants: RoleRef
  isActive: Boolean
  level: AccessLevel
}

type AddACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  numUids: Int
}

input AddAddressInput {
  city: String
  countryCode: String
  isActive: Boolean
  name: String
  number: String
  postCode: String
  state: String
  street1: String
  street2: String
}

type AddAddressPayload {
  address(filter: AddressFilter, first: Int, offset: Int, order: AddressOrder): [Address]
  numUids: Int
}

input AddBillOfMaterialInput {
  description: String
  isActive: Boolean
  materialSpecifications: [MaterialSpecificationRef]
  name: String!
  operationsDefinition: OperationsDefinitionRef
  version: String!
}

type AddBillOfMaterialPayload {
  billOfMaterial(filter: BillOfMaterialFilter, first: Int, offset: Int, order: BillOfMaterialOrder): [BillOfMaterial]
  numUids: Int
}

input AddBoxInput {
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

type AddBoxPayload {
  box(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box]
  numUids: Int
}

input AddCarrierInput {
  barcodeImage: String
  code: String!
  isActive: Boolean
  owner: PartnerRef
  status: MaterialStatusRef!
  storageLocation: EquipmentRef!
}

type AddCarrierPayload {
  carrier(filter: CarrierFilter, first: Int, offset: Int, order: CarrierOrder): [Carrier]
  numUids: Int
}

input AddDashboardConfigInput {
  isActive: Boolean
  name: String!
  panels: [DashboardPanelConfigRef]
}

type AddDashboardConfigPayload {
  dashboardConfig(filter: DashboardConfigFilter, first: Int, offset: Int, order: DashboardConfigOrder): [DashboardConfig]
  numUids: Int
}

input AddDashboardPanelConfigInput {
  dashboard: DashboardConfigRef
  h: Int
  properties: [DashboardWidgetConfigPropertyRef]
  w: Int
  widgetName: String
  x: Int
  y: Int
}

type AddDashboardPanelConfigPayload {
  dashboardPanelConfig(filter: DashboardPanelConfigFilter, first: Int, offset: Int, order: DashboardPanelConfigOrder): [DashboardPanelConfig]
  numUids: Int
}

input AddDashboardWidgetConfigPropertyInput {
  key: String!
  panel: DashboardPanelConfigRef
  value: String!
}

type AddDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(filter: DashboardWidgetConfigPropertyFilter, first: Int, offset: Int, order: DashboardWidgetConfigPropertyOrder): [DashboardWidgetConfigProperty]
  numUids: Int
}

input AddDeliveryInput {
  dateTime: DateTime!
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  shipments: [ShipmentRef]
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

type AddDeliveryPayload {
  delivery(filter: DeliveryFilter, first: Int, offset: Int, order: DeliveryOrder): [Delivery]
  numUids: Int
}

input AddEquipmentActualInput {
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef!
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddEquipmentActualPayload {
  equipmentActual(filter: EquipmentActualFilter, first: Int, offset: Int, order: EquipmentActualOrder): [EquipmentActual]
  numUids: Int
}

input AddEquipmentClassInput {
  addressTemplate: String
  children: [EquipmentClassRef]
  dashboardConfig: DashboardConfigRef
  description: String
  displayName: String
  equipmentLevel: EquipmentElementLevel
  equipmentSpecifications: [EquipmentSpecificationRef]
  equipments: [EquipmentRef]
  eventDefinitions: [EventDefinitionRef]
  image: String
  isActive: Boolean
  label: String
  name: String!
  parent: EquipmentClassRef
  properties: [PropertyRef]
  reasons: [ReasonRef]
}

type AddEquipmentClassPayload {
  equipmentClass(filter: EquipmentClassFilter, first: Int, offset: Int, order: EquipmentClassOrder): [EquipmentClass]
  numUids: Int
}

input AddEquipmentInput {
  addressTemplate: String
  allowAdhocWorklog: Boolean
  carriers: [CarrierRef]
  children: [EquipmentRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  description: String
  displayName: String
  equipmentActual: [EquipmentActualRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  erpAssetID: String
  events: [EventLogRef]
  inflows: [EquipmentRelationRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  jobResponses: [JobResponseRef]
  label: String
  materialSubLots: [MaterialSubLotRef]
  mpmAutoIdentMatchSource: String
  mpmEnableAutoIdentMatching: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableJobInterlock: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableORCRevokePermissive: Boolean
  mpmEnableORCWarning: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableSetupStartDetection: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmPermissiveOutputName: String
  name: String!
  ocsChosenStopTime: DateTime
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  operationsRequests: [OperationsRequestRef]
  orders: [OrderRef]
  outflows: [EquipmentRelationRef]
  parent: EquipmentRef
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  quantities: [QuantityLogRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  reasons: [ReasonRef]
  shipmentItems: [ShipmentItemRef]
  shipments: [ShipmentRef]
  stagedOrders: [OrderRef]
  timeZoneName: String
  userRoles: [UserRoleRef]
  workCalendar: WorkCalendarRef
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
}

input AddEquipmentNameAliasInput {
  alias: String!
  equipment: EquipmentRef!
  system: String!
}

type AddEquipmentNameAliasPayload {
  equipmentNameAlias(filter: EquipmentNameAliasFilter, first: Int, offset: Int, order: EquipmentNameAliasOrder): [EquipmentNameAlias]
  numUids: Int
}

type AddEquipmentPayload {
  equipment(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment]
  numUids: Int
}

input AddEquipmentPropertyOverrideInput {
  address: String
  equipment: EquipmentRef!
  expression: String
  ignore: Boolean
  isActive: Boolean
  property: PropertyRef!
  storeHistory: Boolean
  value: String
}

type AddEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(filter: EquipmentPropertyOverrideFilter, first: Int, offset: Int, order: EquipmentPropertyOverrideOrder): [EquipmentPropertyOverride]
  numUids: Int
}

input AddEquipmentReasonOverrideInput {
  equipment: EquipmentRef
  ignore: Boolean
  isActive: Boolean
  reason: ReasonRef
  standardValue: Float
}

type AddEquipmentReasonOverridePayload {
  equipmentReasonOverride(filter: EquipmentReasonOverrideFilter, first: Int, offset: Int, order: EquipmentReasonOverrideOrder): [EquipmentReasonOverride]
  numUids: Int
}

input AddEquipmentRelationInput {
  code: String
  from: EquipmentRef!
  isActive: Boolean
  to: EquipmentRef
  type: EquipmentRelationshipType!
}

type AddEquipmentRelationPayload {
  equipmentRelation(filter: EquipmentRelationFilter, first: Int, offset: Int, order: EquipmentRelationOrder): [EquipmentRelation]
  numUids: Int
}

input AddEquipmentSpecificationInput {
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddEquipmentSpecificationPayload {
  equipmentSpecification(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification]
  numUids: Int
}

input AddEventDefinitionInput {
  delayOption: Boolean
  delayTime: Int
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  materialEventRuleset: MaterialEventRulesetRef
  messageClass: MessageClass!
  name: String!
  orderStartRuleset: OrderStartRulesetRef
  payloadFields: [PayloadFieldDefinitionRef]
  payloadProperties: [PropertyRef]
  stateEventRuleset: StateEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  triggerExpression: String!
  triggerProperties: [PropertyRef]
}

type AddEventDefinitionPayload {
  eventDefinition(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition]
  numUids: Int
}

input AddEventLogInput {
  comments: String
  duration: Float
  endDateTime: DateTime
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef!
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  startDateTime: DateTime
}

type AddEventLogPayload {
  eventLog(filter: EventLogFilter, first: Int, offset: Int, order: EventLogOrder): [EventLog]
  numUids: Int
}

input AddFormInput {
  isActive: Boolean
  jsonSchema: String
  name: String!
  uiSchema: String
  workflowNodes: [WorkflowNodeRef]
}

type AddFormPayload {
  form(filter: FormFilter, first: Int, offset: Int, order: FormOrder): [Form]
  numUids: Int
}

input AddGeneralLedgerAccountInput {
  code: String!
  name: String
  type: String
}

type AddGeneralLedgerAccountPayload {
  generalLedgerAccount(filter: GeneralLedgerAccountFilter, first: Int, offset: Int, order: GeneralLedgerAccountOrder): [GeneralLedgerAccount]
  numUids: Int
}

input AddInterfaceMessageLogInput {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  level: String
  message: String
  payload: String
  status: String
}

type AddInterfaceMessageLogPayload {
  interfaceMessageLog(filter: InterfaceMessageLogFilter, first: Int, offset: Int, order: InterfaceMessageLogOrder): [InterfaceMessageLog]
  numUids: Int
}

input AddInventoryActualInput {
  carrier: ExtCarrierRef
  isActive: Boolean
  jobResponse: ExtJobResponseRef!
  materialDefinition: ExtMaterialDefinitionRef
  materialLot: ExtMaterialLotRef
  materialStatus: ExtMaterialStatusRef
  materialSubLot: ExtMaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: ExtUnitOfMeasureRef
}

type AddInventoryActualPayload {
  carrier: Carrier
  isActive: Boolean
  jobResponse: JobResponse!
  materialDefinition: MaterialDefinition
  materialLot: MaterialLot
  materialStatus: MaterialStatus
  materialSubLot: MaterialSubLot
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasure
}

input AddInventoryHandlingPolicyInput {
  isActive: Boolean
  materialClass: [MaterialClassRef]
  name: String!
  rules: [InventoryHandlingRuleRef]
  trackByCarrier: Boolean
  trackBySerialNumber: Boolean
  verifySerialNumberOnPacking: Boolean
  verifySerialNumberOnReceipt: Boolean
}

type AddInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter, first: Int, offset: Int, order: InventoryHandlingPolicyOrder): [InventoryHandlingPolicy]
  numUids: Int
}

input AddInventoryHandlingRuleInput {
  customer: PartnerRef!
  inventoryHandlingPolicy: InventoryHandlingPolicyRef!
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  stateModel: MaterialStateModelRef!
  stockType: StockType!
  warehouse: [EquipmentRef!]!
}

type AddInventoryHandlingRulePayload {
  inventoryHandlingRule(filter: InventoryHandlingRuleFilter, first: Int, offset: Int): [InventoryHandlingRule]
  numUids: Int
}

input AddInventoryHoldingPolicyInput {
  inventoryHandlingRule: InventoryHandlingRuleRef!
  inventoryMax: Int
  inventoryMin: Int
  isActive: Boolean
  material: MaterialDefinitionRef!
  materialStatus: MaterialStatusRef!
}

type AddInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter, first: Int, offset: Int, order: InventoryHoldingPolicyOrder): [InventoryHoldingPolicy]
  numUids: Int
}

input AddInventoryTransactionInput {
  """
  optional - the location and status information of where the material is being moved from
  """
  from: AddInventoryTransactionLocationInput

  """optional - a job response assoicated with the transaction"""
  jobResponse: ExtJobResponseRef

  """
  mandatory - the material definition of the transaction - ONLY ACCEPTS CODE AS AN INPUT
  """
  material: ExtMaterialDefinitionRef!

  """
  optional - the material sublot of the transaction - ONLY ACCEPTS CODE AS AN INPUT
  """
  materialSubLot: ExtMaterialSubLotRef

  """mandatory - the material use of the transaction"""
  materialUse: MaterialUse!

  """mandatory - stores the owner of the material"""
  owner: ExtPartnerRef!

  """mandatory - the quantity of material in the transaction"""
  quantity: Float!

  """
  mandatory - the location and status information of where the material is being moved to
  """
  to: AddInventoryTransactionLocationInput!

  """mandatory - stores the id of the user performing the transaction"""
  user: ExtUserRef
}

input AddInventoryTransactionLocationInput {
  carrier: ExtCarrierRef
  shipment: ExtShipmentRef
  shipmentItem: ExtShipmentItemRef
  status: ExtMaterialStatusRef
  storageLocation: ExtEquipmentRef
}

input AddJobOrderDependencyInput {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: JobOrderRef!
  isActive: Boolean
  segmentDependency: SegmentDependencyRef
  to: JobOrderRef!
}

type AddJobOrderDependencyPayload {
  jobOrderDependency(filter: JobOrderDependencyFilter, first: Int, offset: Int, order: JobOrderDependencyOrder): [JobOrderDependency]
  numUids: Int
}

input AddJobOrderDispatchStateModelInput {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus!
}

type AddJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(filter: JobOrderDispatchStateModelFilter, first: Int, offset: Int): [JobOrderDispatchStateModel]
  numUids: Int
}

input AddJobOrderInput {
  children: [JobOrderRef]
  createdDateTime: DateTime
  description: String
  dispatchStatus: DispatchStatus
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipment: EquipmentRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  hierarchyScope: String
  inflows: [JobOrderDependencyRef]
  isActive: Boolean
  jobOrderNotes: [JobOrderNoteRef]
  jobResponses: [JobResponseRef]
  materialSpecifications: [MaterialSpecificationRef]
  name: String!
  next: [JobOrderRef]
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  outflows: [JobOrderDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: JobOrderRef
  personnelSpecifications: [PersonnelSpecificationRef]
  previous: [JobOrderRef]
  priority: Int
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  scheduledDuration: Float
  scheduledEndDateTime: DateTime
  scheduledStartDateTime: DateTime
  version: String
  workDefinitionType: String
  workType: WorkType
}

input AddJobOrderNoteInput {
  comment: String
  createdBy: UserRef
  createdDateTime: DateTime
  editedDateTime: DateTime
  isActive: Boolean
  jobOrder: JobOrderRef
  modifiedBy: UserRef
}

type AddJobOrderNotePayload {
  jobOrderNote(filter: JobOrderNoteFilter, first: Int, offset: Int, order: JobOrderNoteOrder): [JobOrderNote]
  numUids: Int
}

type AddJobOrderPayload {
  jobOrder(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder]
  numUids: Int
}

input AddJobResponseInput {
  actualDuration: Float
  createdDateTime: DateTime
  endDateTime: DateTime
  equipment: EquipmentRef
  equipmentActual: [EquipmentActualRef]
  events: [EventLogRef]
  isActive: Boolean
  jobOrder: JobOrderRef
  materialActual: [MaterialActualRef]
  modifiedDateTime: DateTime
  operator: UserRef
  personnelActual: [PersonnelActualRef]
  productionDate: String
  properties: [PropertyRef]
  quantities: [QuantityLogRef]
  startDateTime: DateTime
}

type AddJobResponsePayload {
  jobResponse(filter: JobResponseFilter, first: Int, offset: Int, order: JobResponseOrder): [JobResponse]
  numUids: Int
}

input AddLibreServiceInput {
  heartbeat: DateTime
  name: String!
}

type AddLibreServicePayload {
  libreService(filter: LibreServiceFilter, first: Int, offset: Int, order: LibreServiceOrder): [LibreService]
  numUids: Int
}

input AddMaterialActualInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddMaterialActualPayload {
  materialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual]
  numUids: Int
}

input AddMaterialAlternateInput {
  alternateMaterial: MaterialDefinitionRef!
  effectiveDateTime: DateTime!
  isActive: Boolean
  material: MaterialDefinitionRef!
  priorityOrder: Int!
}

type AddMaterialAlternatePayload {
  materialAlternate(filter: MaterialAlternateFilter, first: Int, offset: Int, order: MaterialAlternateOrder): [MaterialAlternate]
  numUids: Int
}

input AddMaterialClassInput {
  children: [MaterialClassRef]
  code: String!
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  isActive: Boolean
  parent: MaterialClassRef
  properties: [PropertyRef]
  scheduleSortOrder: Int
}

type AddMaterialClassPayload {
  materialClass(filter: MaterialClassFilter, first: Int, offset: Int, order: MaterialClassOrder): [MaterialClass]
  numUids: Int
}

input AddMaterialDefinitionInput {
  OrderLines: [OrderLineRef]
  alternates: [MaterialAlternateRef]
  baseUnitOfMeasure: UnitOfMeasureRef!
  code: String!
  customerMaterialCode: String
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  lots: [MaterialLotRef]
  materialActual: [MaterialActualRef]
  materialClass: MaterialClassRef
  name: String
  operationsDefinitions: [OperationsDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
  properties: [PropertyRef]
  scheduleSortOrder: Int
  serialMask: String
  shipmentItems: [ShipmentItemRef]
  sublots: [MaterialSubLotRef]
  supplier: String
  transferrableMaterials: [MaterialDefinitionRef]
  units: [MaterialUnitRef]
  uomConversions: [UnitOfMeasureConversionRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  workSpecifications: [MaterialSpecificationRef]
}

type AddMaterialDefinitionPayload {
  materialDefinition(filter: MaterialDefinitionFilter, first: Int, offset: Int, order: MaterialDefinitionOrder): [MaterialDefinition]
  numUids: Int
}

input AddMaterialEventRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segment: OperationsSegmentRef
  targetMaterial: String!
  targetMaterialOp: String!
  triggerWhen: [RulesetTriggerOption]
}

type AddMaterialEventRulesetPayload {
  materialEventRuleset(filter: MaterialEventRulesetFilter, first: Int, offset: Int, order: MaterialEventRulesetOrder): [MaterialEventRuleset]
  numUids: Int
}

input AddMaterialLotInput {
  childSubLot: [MaterialSubLotRef]
  code: String!
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef!
  materialActual: [MaterialActualRef]
  properties: [PropertyRef]
  quantity: String
  unitOfMeasure: UnitOfMeasureRef
}

type AddMaterialLotPayload {
  materialLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot]
  numUids: Int
}

input AddMaterialSpecificationInput {
  allowedStates: [MaterialStatusRef]
  backFlushFromLocation: EquipmentRef
  billOfMaterial: BillOfMaterialRef
  description: String
  isActive: Boolean
  isBackFlushed: Boolean
  isTracked: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  materialUse: MaterialUse!
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddMaterialSpecificationPayload {
  materialSpecification(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification]
  numUids: Int
}

input AddMaterialStateModelInput {
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  name: String!
  states: [MaterialStateTransitionRef!]!
}

type AddMaterialStateModelPayload {
  materialStateModel(filter: MaterialStateModelFilter, first: Int, offset: Int, order: MaterialStateModelOrder): [MaterialStateModel]
  numUids: Int
}

input AddMaterialStateTransitionInput {
  canPack: Boolean
  canReceive: Boolean
  isPlanned: Boolean
  status: MaterialStatusRef!
  to: [MaterialStatusRef]
}

type AddMaterialStateTransitionPayload {
  materialStateTransition(filter: MaterialStateTransitionFilter, first: Int, offset: Int): [MaterialStateTransition]
  numUids: Int
}

input AddMaterialStatusInput {
  code: String!
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
}

type AddMaterialStatusPayload {
  materialStatus(filter: MaterialStatusFilter, first: Int, offset: Int, order: MaterialStatusOrder): [MaterialStatus]
  numUids: Int
}

input AddMaterialSubLotInput {
  childSubLot: MaterialSubLotRef
  code: String!
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef!
  materialActual: [MaterialActualRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  properties: [PropertyRef]
  quantity: String
  status: MaterialStatusRef!
  storageLocation: EquipmentRef
  unitOfMeasure: UnitOfMeasureRef
}

type AddMaterialSubLotPayload {
  materialSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot]
  numUids: Int
}

input AddMaterialUnitInput {
  isActive: Boolean
  material: MaterialDefinitionRef!
  properties: [PropertyRef]
  serialNumber: String!
}

type AddMaterialUnitPayload {
  materialUnit(filter: MaterialUnitFilter, first: Int, offset: Int, order: MaterialUnitOrder): [MaterialUnit]
  numUids: Int
}

input AddMenuInput {
  access: [RoleRef!]!
  children: [MenuRef!]
  icon: String
  isPage: Boolean!
  isSection: Boolean!
  label: String!
  menuPage: String
  orderNumber: Int
  parent: MenuRef
}

type AddMenuPayload {
  menu(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu]
  numUids: Int
}

input AddOperationsDefinitionInput {
  billOfMaterial: BillOfMaterialRef
  description: String
  hierarchyScope: String
  isActive: Boolean
  material: MaterialDefinitionRef
  name: String!
  operationsType: WorkType!
  segments: [OperationsSegmentRef]
  version: String
}

type AddOperationsDefinitionPayload {
  numUids: Int
  operationsDefinition(filter: OperationsDefinitionFilter, first: Int, offset: Int, order: OperationsDefinitionOrder): [OperationsDefinition]
}

input AddOperationsRequestInput {
  code: String!
  equipment: EquipmentRef
  isActive: Boolean
  jobOrders: [JobOrderRef]
  operationsDefinition: OperationsDefinitionRef!
  operationsType: WorkType!
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  priority: String
  properties: [PropertyRef]
  quantity: Float!
  quantityUoM: UnitOfMeasureRef!
  requestState: RequestStateRef!
}

type AddOperationsRequestPayload {
  numUids: Int
  operationsRequest(filter: OperationsRequestFilter, first: Int, offset: Int, order: OperationsRequestOrder): [OperationsRequest]
}

input AddOperationsSegmentInput {
  children: [OperationsSegmentRef]
  costAmountDirectLabourRate: Float
  costAmountFixedOverhead: Float
  costAmountVariableOverhead: Float
  costDriverFixedOverhead: CostDriver
  description: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  glAccountDirectLabour: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountWIP: String
  glAccountWIPInvoice: String
  hierarchyScope: String
  inflows: [SegmentDependencyRef]
  invoiceSettings: [SegmentInvoiceSettingRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  materialEventRuleset: MaterialEventRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  mpmAutoIdentMatchCode: PropertyRef
  mpmChangeoverFamily: String
  mpmEnableAutoIdent: Boolean
  mpmEnableSmartChangeover: Boolean
  mpmIdealChangeoverTime: Float
  mpmIdealSetupTime: Float
  mpmPlanRate: Float
  mpmThresholdMicrostopDuration: Float
  mpmThresholdRunDuration: Float
  mpmThresholdRunRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdSlowRate: Float
  name: String!
  operationsDefinition: OperationsDefinitionRef
  orderStartRuleset: OrderStartRulesetRef
  outflows: [SegmentDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: OperationsSegmentRef
  personnelSpecifications: [PersonnelSpecificationRef]
  positionX: Int
  positionY: Int
  stateEventRuleset: StateEventRulesetRef
  type: SegmentType
  uiComponent: String
  version: String
  workDefinitionType: String
  workType: WorkType
}

type AddOperationsSegmentPayload {
  numUids: Int
  operationsSegment(filter: OperationsSegmentFilter, first: Int, offset: Int, order: OperationsSegmentOrder): [OperationsSegment]
}

input AddOrderInput {
  createdDateTime: DateTime
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  isActive: Boolean
  lines: [OrderLineRef]
  notes: String
  orderType: OrderType!
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  shipments: [ShipmentRef]
  site: EquipmentRef
  status: OrderStatus!
  warehouse: EquipmentRef
}

input AddOrderLineInput {
  defectiveSerialNumbers: String
  isActive: Boolean
  isReturn: Boolean
  material: MaterialDefinitionRef!
  order: OrderRef
  orderLineNumber: Int!
  quantity: Int!
  workflowInstance: WorkflowInstanceRef
}

type AddOrderLinePayload {
  numUids: Int
  orderLine(filter: OrderLineFilter, first: Int, offset: Int, order: OrderLineOrder): [OrderLine]
}

type AddOrderPayload {
  numUids: Int
  order(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order]
}

input AddOrderStartRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segment: OperationsSegmentRef
}

type AddOrderStartRulesetPayload {
  numUids: Int
  orderStartRuleset(filter: OrderStartRulesetFilter, first: Int, offset: Int, order: OrderStartRulesetOrder): [OrderStartRuleset]
}

input AddParameterSpecificationInput {
  isActive: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  operationsSegment: OperationsSegmentRef
  property: PropertyRef!
  valueDefault: String
  valueLowerControlLimit: Float
  valueLowerSpecLimit: Float
  valueSetPoint: String
  valueUpperControlLimit: Float
  valueUpperSpecLimit: Float
}

type AddParameterSpecificationPayload {
  numUids: Int
  parameterSpecification(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification]
}

input AddPartnerInput {
  billingAddress: AddressRef
  carriers: [CarrierRef]
  companyCode: String!
  contactEmail: String
  contactName: String
  contactPhone: String
  fromOrders: [OrderRef]
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: String
  registrationNumber: String
  shippingAccounts: [ShippingAccountRef]
  shippingAddress: AddressRef
  toOrders: [OrderRef]
  vatNumber: String
}

type AddPartnerPayload {
  numUids: Int
  partner(filter: PartnerFilter, first: Int, offset: Int, order: PartnerOrder): [Partner]
}

input AddPayloadFieldDefinitionInput {
  expression: String!
  fieldType: PayloadFieldType
  isActive: Boolean
  name: String!
}

type AddPayloadFieldDefinitionPayload {
  numUids: Int
  payloadFieldDefinition(filter: PayloadFieldDefinitionFilter, first: Int, offset: Int, order: PayloadFieldDefinitionOrder): [PayloadFieldDefinition]
}

input AddPersonInput {
  description: String
  isActive: Boolean
  memberOf: [PersonnelClassRef]
  name: String!
  personnelActual: [PersonnelActualRef]
  properties: [PropertyRef]
}

input AddPersonnelActualInput {
  isActive: Boolean
  jobResponse: JobResponseRef!
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type AddPersonnelActualPayload {
  numUids: Int
  personnelActual(filter: PersonnelActualFilter, first: Int, offset: Int, order: PersonnelActualOrder): [PersonnelActual]
}

input AddPersonnelClassInput {
  description: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  name: String!
  persons: [PersonRef]
  properties: [PropertyRef]
}

type AddPersonnelClassPayload {
  numUids: Int
  personnelClass(filter: PersonnelClassFilter, first: Int, offset: Int, order: PersonnelClassOrder): [PersonnelClass]
}

input AddPersonnelSpecificationInput {
  description: String
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

type AddPersonnelSpecificationPayload {
  numUids: Int
  personnelSpecification(filter: PersonnelSpecificationFilter, first: Int, offset: Int, order: PersonnelSpecificationOrder): [PersonnelSpecification]
}

type AddPersonPayload {
  numUids: Int
  person(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person]
}

input AddPropertyInput {
  address: String
  dataType: DataType
  definedBy: PropertyRef
  description: String!
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  eventPayloads: [EventDefinitionRef]
  eventTriggers: [EventDefinitionRef]
  expression: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  jobOrder: JobOrderRef
  jobResponse: JobResponseRef
  materialClass: MaterialClassRef
  name: String!
  operationsRequest: OperationsRequestRef
  parameterSpecifications: [ParameterSpecificationRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  storeHistory: Boolean
  type: PropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input AddPropertyNameAliasInput {
  alias: String!
  equipment: EquipmentRef!
  property: PropertyRef!
  system: String!
}

type AddPropertyNameAliasPayload {
  numUids: Int
  propertyNameAlias(filter: PropertyNameAliasFilter, first: Int, offset: Int, order: PropertyNameAliasOrder): [PropertyNameAlias]
}

type AddPropertyPayload {
  numUids: Int
  property(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property]
}

input AddPropertyValueAliasInput {
  alias: String!
  property: PropertyRef!
  system: String!
  value: String!
}

type AddPropertyValueAliasPayload {
  numUids: Int
  propertyValueAlias(filter: PropertyValueAliasFilter, first: Int, offset: Int, order: PropertyValueAliasOrder): [PropertyValueAlias]
}

input AddQuantityLogInput {
  comments: String
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef!
  quantity: Float!
  reasonCode: String
  reasonText: String
  timestamp: DateTime
  type: MaterialUse!
}

type AddQuantityLogPayload {
  numUids: Int
  quantityLog(filter: QuantityLogFilter, first: Int, offset: Int, order: QuantityLogOrder): [QuantityLog]
}

input AddReasonCategoryInput {
  code: String!
  isActive: Boolean
  reason: [ReasonRef]
  timeCategory: TimeCategory!
}

type AddReasonCategoryPayload {
  numUids: Int
  reasonCategory(filter: ReasonCategoryFilter, first: Int, offset: Int, order: ReasonCategoryOrder): [ReasonCategory]
}

input AddReasonInput {
  category: ReasonCategoryRef
  children: [ReasonRef]
  class: ReasonClass!
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
  erpCode: String!
  isActive: Boolean
  label: String!
  parent: ReasonRef
  standardValue: Float
  text: String!
  valueUoM: UnitOfMeasureRef
}

type AddReasonPayload {
  numUids: Int
  reason(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason]
}

input AddRequestStateInput {
  description: String
  isActive: Boolean
  name: String!
}

type AddRequestStatePayload {
  numUids: Int
  requestState(filter: RequestStateFilter, first: Int, offset: Int, order: RequestStateOrder): [RequestState]
}

type Address
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  city: String @join__field(graph: SCHEMA)
  countryCode: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  name: String @join__field(graph: SCHEMA)
  number: String @join__field(graph: SCHEMA)
  postCode: String @join__field(graph: SCHEMA)
  state: String @join__field(graph: SCHEMA)
  street1: String @join__field(graph: SCHEMA)
  street2: String @join__field(graph: SCHEMA)
}

type AddressAggregateResult {
  cityMax: String
  cityMin: String
  count: Int
  countryCodeMax: String
  countryCodeMin: String
  nameMax: String
  nameMin: String
  numberMax: String
  numberMin: String
  postCodeMax: String
  postCodeMin: String
  stateMax: String
  stateMin: String
  street1Max: String
  street1Min: String
  street2Max: String
  street2Min: String
}

input AddressFilter {
  and: [AddressFilter]
  has: [AddressHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: AddressFilter
  or: [AddressFilter]
}

enum AddressHasFilter {
  city
  countryCode
  isActive
  name
  number
  postCode
  state
  street1
  street2
}

input AddressOrder {
  asc: AddressOrderable
  desc: AddressOrderable
  then: AddressOrder
}

enum AddressOrderable {
  city
  countryCode
  name
  number
  postCode
  state
  street1
  street2
}

input AddressPatch {
  city: String
  countryCode: String
  isActive: Boolean
  name: String
  number: String
  postCode: String
  state: String
  street1: String
  street2: String
}

input AddressRef {
  city: String
  countryCode: String
  id: ID
  isActive: Boolean
  name: String
  number: String
  postCode: String
  state: String
  street1: String
  street2: String
}

input AddRoleInput {
  hasGrantedRights: [AccessRightRef]
  hasMembers: [UserRoleRef]
  isActive: Boolean
  name: String!
  workflowNodes: [WorkflowNodeRef]
}

type AddRolePayload {
  numUids: Int
  role(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role]
}

input AddSegmentDependencyInput {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: OperationsSegmentRef!
  isActive: Boolean
  jobOrderDependencies: [JobOrderDependencyRef]
  to: OperationsSegmentRef!
  transitionEventRuleset: TransitionEventRulesetRef
}

type AddSegmentDependencyPayload {
  numUids: Int
  segmentDependency(filter: SegmentDependencyFilter, first: Int, offset: Int, order: SegmentDependencyOrder): [SegmentDependency]
}

input AddSegmentInvoiceSettingInput {
  costPerHour: Float
  costPerUnit: Float
  partner: PartnerRef
}

type AddSegmentInvoiceSettingPayload {
  numUids: Int
  segmentInvoiceSetting(filter: SegmentInvoiceSettingFilter, first: Int, offset: Int, order: SegmentInvoiceSettingOrder): [SegmentInvoiceSetting]
}

input AddShipmentInput {
  consignmentNumber: String
  customerReference: String
  dateTimeCreatedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeReceivedUTC: DateTime
  delivered: DeliveryRef
  emailTrackingEnabled: Boolean
  from: AddressRef
  isActive: Boolean
  items: [ShipmentItemRef]
  order: OrderRef!
  properties: [PropertyRef]
  reference: String
  status: ShipmentStatus
  to: AddressRef
  transportCompany: TransportCompany
  transportCompanyProductCode: String
  transportCompanyShipmentId: String
  type: ShipmentType!
  warehouse: EquipmentRef!
}

input AddShipmentItemInput {
  bin: EquipmentRef
  box: BoxRef
  isActive: Boolean
  isParcel: Boolean
  material: MaterialDefinitionRef
  plannedQuantity: Int
  shipment: ShipmentRef
  status: ShipmentItemStatus!
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  transportCompanyItemId: String
  transportCompanyItemReference: String
  weightKg: Float
}

type AddShipmentItemPayload {
  numUids: Int
  shipmentItem(filter: ShipmentItemFilter, first: Int, offset: Int, order: ShipmentItemOrder): [ShipmentItem]
}

type AddShipmentPayload {
  numUids: Int
  shipment(filter: ShipmentFilter, first: Int, offset: Int, order: ShipmentOrder): [Shipment]
}

input AddShippingAccountInput {
  accountNumber: String
  isActive: Boolean
  partner: PartnerRef
  secret: String
  transportCompany: TransportCompany
  username: String
  warehouse: EquipmentRef
}

type AddShippingAccountPayload {
  numUids: Int
  shippingAccount(filter: ShippingAccountFilter, first: Int, offset: Int, order: ShippingAccountOrder): [ShippingAccount]
}

input AddStateEventRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segment: OperationsSegmentRef
  targetState: String!
  triggerWhen: [RulesetTriggerOption]
}

type AddStateEventRulesetPayload {
  numUids: Int
  stateEventRuleset(filter: StateEventRulesetFilter, first: Int, offset: Int, order: StateEventRulesetOrder): [StateEventRuleset]
}

input AddTestResultInput {
  description: String
  isActive: Boolean
  result: String
  testDateTime: DateTime
  uom: UnitOfMeasureRef
}

type AddTestResultPayload {
  numUids: Int
  testResult(filter: TestResultFilter, first: Int, offset: Int, order: TestResultOrder): [TestResult]
}

input AddTestSpecificationInput {
  description: String
  isActive: Boolean
  version: String
}

type AddTestSpecificationPayload {
  numUids: Int
  testSpecification(filter: TestSpecificationFilter, first: Int, offset: Int, order: TestSpecificationOrder): [TestSpecification]
}

input AddTransitionEventRulesetInput {
  eventDefs: [EventDefinitionRef]
  name: String!
  segmentDependency: SegmentDependencyRef
}

type AddTransitionEventRulesetPayload {
  numUids: Int
  transitionEventRuleset(filter: TransitionEventRulesetFilter, first: Int, offset: Int, order: TransitionEventRulesetOrder): [TransitionEventRuleset]
}

input AddUnitOfMeasureConversionInput {
  denominator: Float!
  fromUoM: UnitOfMeasureRef!
  isActive: Boolean
  material: MaterialDefinitionRef!
  numerator: Float!
  toUoM: UnitOfMeasureRef!
}

type AddUnitOfMeasureConversionPayload {
  numUids: Int
  unitOfMeasureConversion(filter: UnitOfMeasureConversionFilter, first: Int, offset: Int, order: UnitOfMeasureConversionOrder): [UnitOfMeasureConversion]
}

input AddUnitOfMeasureInput {
  code: String!
  dataType: DataType
  isActive: Boolean
}

type AddUnitOfMeasurePayload {
  numUids: Int
  unitOfMeasure(filter: UnitOfMeasureFilter, first: Int, offset: Int, order: UnitOfMeasureOrder): [UnitOfMeasure]
}

input AddUserInput {
  hasRole: [UserRoleRef]
  isActive: Boolean
  isType: UserType!
  name: String
  tasks: [WorkflowNodeInstanceRef]
  username: String!
}

type AddUserPayload {
  numUids: Int
  user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

input AddUserRoleInput {
  isActive: Boolean
  responsibilities: [EquipmentRef]!
  role: RoleRef!
  user: UserRef!
}

type AddUserRolePayload {
  numUids: Int
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
}

input AddWorkCalendarDefinitionEntryInput {
  byHour: [Int]
  byMinute: [Int]
  byMonth: [Int]
  byMonthDay: [Int]
  bySecond: [Int]
  bySetPos: [Int]
  byWeekDay: [Weekday]
  byWeekNo: [Int]
  byYearDay: [Int]
  calendarEntries: [WorkCalendarEntryRef]
  count: Int
  description: String
  duration: String
  endDateTime: DateTime
  entryType: WorkCalendarEntryType!
  freq: Frequency!
  hierarchyScope: EquipmentRef
  interval: Int
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime!
  wkst: Weekday
  workCalendar: WorkCalendarRef
}

type AddWorkCalendarDefinitionEntryPayload {
  numUids: Int
  workCalendarDefinitionEntry(filter: WorkCalendarDefinitionEntryFilter, first: Int, offset: Int, order: WorkCalendarDefinitionEntryOrder): [WorkCalendarDefinitionEntry]
}

input AddWorkCalendarEntryInput {
  definition: WorkCalendarDefinitionEntryRef
  description: String
  entryType: WorkCalendarEntryType!
  finishDateTime: DateTime!
  hierarchyScope: EquipmentRef
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime!
  workCalendar: WorkCalendarRef
}

type AddWorkCalendarEntryPayload {
  numUids: Int
  workCalendarEntry(filter: WorkCalendarEntryFilter, first: Int, offset: Int, order: WorkCalendarEntryOrder): [WorkCalendarEntry]
}

input AddWorkCalendarInput {
  definition: [WorkCalendarDefinitionEntryRef]
  description: String
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
  isActive: Boolean
  name: String!
}

type AddWorkCalendarPayload {
  numUids: Int
  workCalendar(filter: WorkCalendarFilter, first: Int, offset: Int, order: WorkCalendarOrder): [WorkCalendar]
}

input AddWorkflowConnectionInput {
  access: [ACLRef]
  condition: String
  connectionType: WorkflowConnectionTypeRef!
  createdBy: UserRef
  createdDateTime: DateTime
  from: WorkflowNodeRef!
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  properties: [WorkflowPropertyRef]
  to: WorkflowNodeRef!
  workflowSpecification: WorkflowSpecificationRef!
}

type AddWorkflowConnectionPayload {
  numUids: Int
  workflowConnection(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection]
}

input AddWorkflowConnectionTypeInput {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  properties: [WorkflowPropertyRef]
}

type AddWorkflowConnectionTypePayload {
  numUids: Int
  workflowConnectionType(filter: WorkflowConnectionTypeFilter, first: Int, offset: Int, order: WorkflowConnectionTypeOrder): [WorkflowConnectionType]
}

input AddWorkflowInstanceInput {
  children: [WorkflowInstanceRef]
  createdBy: UserRef
  createdDateTime: DateTime
  equipment: EquipmentRef
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  nodeInstances: [WorkflowNodeInstanceRef]
  orderLines: [OrderLineRef]
  parent: WorkflowInstanceRef
  properties: [WorkflowInstancePropertyRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
}

type AddWorkflowInstancePayload {
  numUids: Int
  workflowInstance(filter: WorkflowInstanceFilter, first: Int, offset: Int, order: WorkflowInstanceOrder): [WorkflowInstance]
}

input AddWorkflowInstancePropertyInput {
  key: String!
  name: String!
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
}

type AddWorkflowInstancePropertyPayload {
  numUids: Int
  workflowInstanceProperty(filter: WorkflowInstancePropertyFilter, first: Int, offset: Int, order: WorkflowInstancePropertyOrder): [WorkflowInstanceProperty]
}

input AddWorkflowNodeEventInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  isProcessed: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowNodeEventRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  value: String
}

type AddWorkflowNodeEventPayload {
  numUids: Int
  workflowNodeEvent(filter: WorkflowNodeEventFilter, first: Int, offset: Int, order: WorkflowNodeEventOrder): [WorkflowNodeEvent]
}

input AddWorkflowNodeInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  form: FormRef
  height: Int
  inflows: [WorkflowConnectionRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  nodeInstances: [WorkflowNodeInstanceRef]
  nodeType: WorkflowNodeTypeRef!
  outflows: [WorkflowConnectionRef]
  positionX: Int
  positionY: Int
  properties: [WorkflowPropertyRef]
  role: RoleRef
  uiComponent: String
  width: Int
  workflowSpecification: WorkflowSpecificationRef!
}

input AddWorkflowNodeInstanceInput {
  access: [ACLRef]
  assignedUser: UserRef
  createdBy: UserRef
  createdDateTime: DateTime
  events: [WorkflowNodeEventRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  node: WorkflowNodeRef!
  status: WorkflowNodeStatus
  workflowInstance: WorkflowInstanceRef!
}

type AddWorkflowNodeInstancePayload {
  numUids: Int
  workflowNodeInstance(filter: WorkflowNodeInstanceFilter, first: Int, offset: Int, order: WorkflowNodeInstanceOrder): [WorkflowNodeInstance]
}

type AddWorkflowNodePayload {
  numUids: Int
  workflowNode(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode]
}

input AddWorkflowNodeTypeInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  nodeClass: WorkflowNodeClass!
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

type AddWorkflowNodeTypePayload {
  numUids: Int
  workflowNodeType(filter: WorkflowNodeTypeFilter, first: Int, offset: Int, order: WorkflowNodeTypeOrder): [WorkflowNodeType]
}

input AddWorkflowPropertyInput {
  access: [ACLRef]
  connection: WorkflowConnectionRef
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  dataType: DataType
  definedBy: WorkflowPropertyRef
  description: String!
  instances: [WorkflowPropertyInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  node: WorkflowNodeRef
  nodeType: WorkflowNodeTypeRef
  propertyType: WorkflowPropertyType!
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input AddWorkflowPropertyInstanceInput {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
}

type AddWorkflowPropertyInstancePayload {
  numUids: Int
  workflowPropertyInstance(filter: WorkflowPropertyInstanceFilter, first: Int, offset: Int, order: WorkflowPropertyInstanceOrder): [WorkflowPropertyInstance]
}

type AddWorkflowPropertyPayload {
  numUids: Int
  workflowProperty(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty]
}

input AddWorkflowPropertyValueInput {
  createdBy: UserRef
  createdDateTime: DateTime
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowPropertyValueRef
  previous: WorkflowPropertyValueRef
  propertyInstance: WorkflowPropertyInstanceRef!
  value: String
}

type AddWorkflowPropertyValuePayload {
  numUids: Int
  workflowPropertyValue(filter: WorkflowPropertyValueFilter, first: Int, offset: Int, order: WorkflowPropertyValueOrder): [WorkflowPropertyValue]
}

input AddWorkflowSpecificationInput {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String!
  instances: [WorkflowInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String!
  nodes: [WorkflowNodeRef]
}

type AddWorkflowSpecificationPayload {
  numUids: Int
  workflowSpecification(filter: WorkflowSpecificationFilter, first: Int, offset: Int, order: WorkflowSpecificationOrder): [WorkflowSpecification]
}

input AllEventsInTimeRangeFilter {
  From: DateTime!
  To: DateTime
}

type ASNStaging {
  errorList: [String]
  isValid: Boolean
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input ASNStagingInput {
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input AuthRule {
  and: [AuthRule]
  not: AuthRule
  or: [AuthRule]
  rule: String
}

input BackfillCancelRequest {
  requestId: String!
}

input BackfillRequest {
  equipment: [String!]!
  startDateTime: DateTime!
  username: String!
}

type BackfillResponse {
  message: String
  status: BackfillStatus!
  topic: String
}

enum BackfillStatus {
  CANCELED
  CREATED
  REJECTED
}

type BillOfMaterial
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  materialSpecifications(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification] @join__field(graph: SCHEMA)
  materialSpecificationsAggregate(filter: MaterialSpecificationFilter): MaterialSpecificationAggregateResult @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  operationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinition @join__field(graph: SCHEMA)
  version: String! @join__field(graph: SCHEMA)
}

type BillOfMaterialAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
  versionMax: String
  versionMin: String
}

input BillOfMaterialFilter {
  and: [BillOfMaterialFilter]
  has: [BillOfMaterialHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: BillOfMaterialFilter
  or: [BillOfMaterialFilter]
}

enum BillOfMaterialHasFilter {
  description
  isActive
  materialSpecifications
  name
  operationsDefinition
  version
}

input BillOfMaterialOrder {
  asc: BillOfMaterialOrderable
  desc: BillOfMaterialOrderable
  then: BillOfMaterialOrder
}

enum BillOfMaterialOrderable {
  description
  name
  version
}

input BillOfMaterialPatch {
  description: String
  isActive: Boolean
  materialSpecifications: [MaterialSpecificationRef]
  name: String
  operationsDefinition: OperationsDefinitionRef
  version: String
}

input BillOfMaterialRef {
  description: String
  id: ID
  isActive: Boolean
  materialSpecifications: [MaterialSpecificationRef]
  name: String
  operationsDefinition: OperationsDefinitionRef
  version: String
}

type Box {
  id: ID!
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

type BoxAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  sizeDepthCmAvg: Float
  sizeDepthCmMax: Int
  sizeDepthCmMin: Int
  sizeDepthCmSum: Int
  sizeHeightCmAvg: Float
  sizeHeightCmMax: Int
  sizeHeightCmMin: Int
  sizeHeightCmSum: Int
  sizeWidthCmAvg: Float
  sizeWidthCmMax: Int
  sizeWidthCmMin: Int
  sizeWidthCmSum: Int
}

input BoxFilter {
  and: [BoxFilter]
  has: [BoxHasFilter]
  id: [ID!]
  not: BoxFilter
  or: [BoxFilter]
}

enum BoxHasFilter {
  name
  sizeDepthCm
  sizeHeightCm
  sizeWidthCm
}

input BoxOrder {
  asc: BoxOrderable
  desc: BoxOrderable
  then: BoxOrder
}

enum BoxOrderable {
  name
  sizeDepthCm
  sizeHeightCm
  sizeWidthCm
}

input BoxPatch {
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

input BoxRef {
  id: ID
  name: String
  sizeDepthCm: Int
  sizeHeightCm: Int
  sizeWidthCm: Int
}

type Carrier
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  barcodeImage: String @join__field(graph: SCHEMA)
  code: String! @join__field(graph: SCHEMA)
  contents: [CarrierContents] @join__field(graph: WMS)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  owner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
  status(filter: MaterialStatusFilter): MaterialStatus! @join__field(graph: SCHEMA)
  storageLocation(filter: EquipmentFilter): Equipment! @join__field(graph: SCHEMA)
  subLots: [CarrierSubLots] @join__field(graph: WMS)
}

type CarrierAggregateResult {
  barcodeImageMax: String
  barcodeImageMin: String
  codeMax: String
  codeMin: String
  count: Int
}

type CarrierContents {
  material: MaterialDefinition! @join__field(graph: WMS, provides: "code")
  owner: Partner
  quantity: Float
}

input CarrierFilter {
  and: [CarrierFilter]
  code: StringHashFilter
  has: [CarrierHasFilter]
  id: [ID!]
  isActive: Boolean
  not: CarrierFilter
  or: [CarrierFilter]
}

enum CarrierHasFilter {
  barcodeImage
  code
  isActive
  owner
  status
  storageLocation
}

input CarrierOrder {
  asc: CarrierOrderable
  desc: CarrierOrderable
  then: CarrierOrder
}

enum CarrierOrderable {
  barcodeImage
  code
}

input CarrierPatch {
  barcodeImage: String
  code: String
  isActive: Boolean
  owner: PartnerRef
  status: MaterialStatusRef
  storageLocation: EquipmentRef
}

input CarrierRef {
  barcodeImage: String
  code: String
  id: ID
  isActive: Boolean
  owner: PartnerRef
  status: MaterialStatusRef
  storageLocation: EquipmentRef
}

type CarrierSubLots {
  material: MaterialDefinition! @join__field(graph: WMS, provides: "code")
  owner: Partner
  subLot: MaterialSubLot @join__field(graph: WMS, provides: "code")
}

input CompleteWorkflowTaskInput {
  properties: [ExtWorkflowPropertyRef]
  task: ExtWorkflowNodeInstanceRef!
  user: CoreUserRef!
}

input ConfirmASNInput {
  errorList: [String]
  isValid: Boolean
  materialCode: String!
  orderNumber: String!
  quantity: Int!
  serialNumber: String
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CoreUserRef {
  username: String!
}

enum CostDriver {
  PER_HOUR
  PER_UNIT
}

input CreateWorkflowInstanceInput {
  equipment: ExtEquipmentRef!
  properties: [ExtWorkflowPropertyRef]
  specification: ExtWorkflowSpecificationRef!
  user: CoreUserRef!
}

input CustomHTTP {
  body: String
  forwardHeaders: [String!]
  graphql: String
  introspectionHeaders: [String!]
  method: HTTPMethod!
  mode: Mode
  secretHeaders: [String!]
  skipIntrospection: Boolean
  url: String!
}

type DashboardConfig {
  id: ID!
  isActive: Boolean
  name: String!
  panels(filter: DashboardPanelConfigFilter, first: Int, offset: Int, order: DashboardPanelConfigOrder): [DashboardPanelConfig]
  panelsAggregate(filter: DashboardPanelConfigFilter): DashboardPanelConfigAggregateResult
}

type DashboardConfigAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input DashboardConfigFilter {
  and: [DashboardConfigFilter]
  has: [DashboardConfigHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: DashboardConfigFilter
  or: [DashboardConfigFilter]
}

enum DashboardConfigHasFilter {
  isActive
  name
  panels
}

input DashboardConfigOrder {
  asc: DashboardConfigOrderable
  desc: DashboardConfigOrderable
  then: DashboardConfigOrder
}

enum DashboardConfigOrderable {
  name
}

input DashboardConfigPatch {
  isActive: Boolean
  name: String
  panels: [DashboardPanelConfigRef]
}

input DashboardConfigRef {
  id: ID
  isActive: Boolean
  name: String
  panels: [DashboardPanelConfigRef]
}

type DashboardPanelConfig {
  dashboard(filter: DashboardConfigFilter): DashboardConfig
  h: Int
  id: ID!
  properties(filter: DashboardWidgetConfigPropertyFilter, first: Int, offset: Int, order: DashboardWidgetConfigPropertyOrder): [DashboardWidgetConfigProperty]
  propertiesAggregate(filter: DashboardWidgetConfigPropertyFilter): DashboardWidgetConfigPropertyAggregateResult
  w: Int
  widgetName: String
  x: Int
  y: Int
}

type DashboardPanelConfigAggregateResult {
  count: Int
  hAvg: Float
  hMax: Int
  hMin: Int
  hSum: Int
  wAvg: Float
  wMax: Int
  wMin: Int
  wSum: Int
  widgetNameMax: String
  widgetNameMin: String
  xAvg: Float
  xMax: Int
  xMin: Int
  xSum: Int
  yAvg: Float
  yMax: Int
  yMin: Int
  ySum: Int
}

input DashboardPanelConfigFilter {
  and: [DashboardPanelConfigFilter]
  has: [DashboardPanelConfigHasFilter]
  id: [ID!]
  not: DashboardPanelConfigFilter
  or: [DashboardPanelConfigFilter]
  widgetName: StringHashFilter
}

enum DashboardPanelConfigHasFilter {
  dashboard
  h
  properties
  w
  widgetName
  x
  y
}

input DashboardPanelConfigOrder {
  asc: DashboardPanelConfigOrderable
  desc: DashboardPanelConfigOrderable
  then: DashboardPanelConfigOrder
}

enum DashboardPanelConfigOrderable {
  h
  w
  widgetName
  x
  y
}

input DashboardPanelConfigPatch {
  dashboard: DashboardConfigRef
  h: Int
  properties: [DashboardWidgetConfigPropertyRef]
  w: Int
  widgetName: String
  x: Int
  y: Int
}

input DashboardPanelConfigRef {
  dashboard: DashboardConfigRef
  h: Int
  id: ID
  properties: [DashboardWidgetConfigPropertyRef]
  w: Int
  widgetName: String
  x: Int
  y: Int
}

type DashboardWidgetConfigProperty {
  id: ID!
  key: String!
  panel(filter: DashboardPanelConfigFilter): DashboardPanelConfig
  value: String!
}

type DashboardWidgetConfigPropertyAggregateResult {
  count: Int
  keyMax: String
  keyMin: String
  valueMax: String
  valueMin: String
}

input DashboardWidgetConfigPropertyFilter {
  and: [DashboardWidgetConfigPropertyFilter]
  has: [DashboardWidgetConfigPropertyHasFilter]
  id: [ID!]
  not: DashboardWidgetConfigPropertyFilter
  or: [DashboardWidgetConfigPropertyFilter]
}

enum DashboardWidgetConfigPropertyHasFilter {
  key
  panel
  value
}

input DashboardWidgetConfigPropertyOrder {
  asc: DashboardWidgetConfigPropertyOrderable
  desc: DashboardWidgetConfigPropertyOrderable
  then: DashboardWidgetConfigPropertyOrder
}

enum DashboardWidgetConfigPropertyOrderable {
  key
  value
}

input DashboardWidgetConfigPropertyPatch {
  key: String
  panel: DashboardPanelConfigRef
  value: String
}

input DashboardWidgetConfigPropertyRef {
  id: ID
  key: String
  panel: DashboardPanelConfigRef
  value: String
}

type DataError {
  message: String
}

"""
Data Providers are the client libraries that have been implemented in the edge agent.
We need to make these plugins that that the library can be extended easily.
At the moment, MQTT is all we have. We will add OPC-UA next
"""
enum DataProvider {
  MQTT
  OPCUA
}

enum DataType {
  BOOL
  FLOAT
  FLOAT64
  INT
  INT32
  STRING
}

scalar DateTime

input DateTimeFilter {
  between: DateTimeRange
  eq: DateTime
  ge: DateTime
  gt: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
}

input DateTimeRange {
  max: DateTime!
  min: DateTime!
}

type DeleteAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  msg: String
  numUids: Int
}

type DeleteACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  msg: String
  numUids: Int
}

type DeleteAddressPayload {
  address(filter: AddressFilter, first: Int, offset: Int, order: AddressOrder): [Address]
  msg: String
  numUids: Int
}

type DeleteBillOfMaterialPayload {
  billOfMaterial(filter: BillOfMaterialFilter, first: Int, offset: Int, order: BillOfMaterialOrder): [BillOfMaterial]
  msg: String
  numUids: Int
}

type DeleteBoxPayload {
  box(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box]
  msg: String
  numUids: Int
}

type DeleteCarrierPayload {
  carrier(filter: CarrierFilter, first: Int, offset: Int, order: CarrierOrder): [Carrier]
  msg: String
  numUids: Int
}

type DeleteDashboardConfigPayload {
  dashboardConfig(filter: DashboardConfigFilter, first: Int, offset: Int, order: DashboardConfigOrder): [DashboardConfig]
  msg: String
  numUids: Int
}

type DeleteDashboardPanelConfigPayload {
  dashboardPanelConfig(filter: DashboardPanelConfigFilter, first: Int, offset: Int, order: DashboardPanelConfigOrder): [DashboardPanelConfig]
  msg: String
  numUids: Int
}

type DeleteDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(filter: DashboardWidgetConfigPropertyFilter, first: Int, offset: Int, order: DashboardWidgetConfigPropertyOrder): [DashboardWidgetConfigProperty]
  msg: String
  numUids: Int
}

type DeleteDeliveryPayload {
  delivery(filter: DeliveryFilter, first: Int, offset: Int, order: DeliveryOrder): [Delivery]
  msg: String
  numUids: Int
}

type DeleteEquipmentActualPayload {
  equipmentActual(filter: EquipmentActualFilter, first: Int, offset: Int, order: EquipmentActualOrder): [EquipmentActual]
  msg: String
  numUids: Int
}

type DeleteEquipmentClassPayload {
  equipmentClass(filter: EquipmentClassFilter, first: Int, offset: Int, order: EquipmentClassOrder): [EquipmentClass]
  msg: String
  numUids: Int
}

type DeleteEquipmentNameAliasPayload {
  equipmentNameAlias(filter: EquipmentNameAliasFilter, first: Int, offset: Int, order: EquipmentNameAliasOrder): [EquipmentNameAlias]
  msg: String
  numUids: Int
}

type DeleteEquipmentPayload {
  equipment(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment]
  msg: String
  numUids: Int
}

type DeleteEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(filter: EquipmentPropertyOverrideFilter, first: Int, offset: Int, order: EquipmentPropertyOverrideOrder): [EquipmentPropertyOverride]
  msg: String
  numUids: Int
}

type DeleteEquipmentReasonOverridePayload {
  equipmentReasonOverride(filter: EquipmentReasonOverrideFilter, first: Int, offset: Int, order: EquipmentReasonOverrideOrder): [EquipmentReasonOverride]
  msg: String
  numUids: Int
}

type DeleteEquipmentRelationPayload {
  equipmentRelation(filter: EquipmentRelationFilter, first: Int, offset: Int, order: EquipmentRelationOrder): [EquipmentRelation]
  msg: String
  numUids: Int
}

type DeleteEquipmentSpecificationPayload {
  equipmentSpecification(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification]
  msg: String
  numUids: Int
}

type DeleteEventDefinitionPayload {
  eventDefinition(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition]
  msg: String
  numUids: Int
}

type DeleteEventLogPayload {
  eventLog(filter: EventLogFilter, first: Int, offset: Int, order: EventLogOrder): [EventLog]
  msg: String
  numUids: Int
}

type DeleteFormPayload {
  form(filter: FormFilter, first: Int, offset: Int, order: FormOrder): [Form]
  msg: String
  numUids: Int
}

type DeleteGeneralLedgerAccountPayload {
  generalLedgerAccount(filter: GeneralLedgerAccountFilter, first: Int, offset: Int, order: GeneralLedgerAccountOrder): [GeneralLedgerAccount]
  msg: String
  numUids: Int
}

type DeleteInterfaceMessageLogPayload {
  interfaceMessageLog(filter: InterfaceMessageLogFilter, first: Int, offset: Int, order: InterfaceMessageLogOrder): [InterfaceMessageLog]
  msg: String
  numUids: Int
}

type DeleteInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter, first: Int, offset: Int, order: InventoryHandlingPolicyOrder): [InventoryHandlingPolicy]
  msg: String
  numUids: Int
}

type DeleteInventoryHandlingRulePayload {
  inventoryHandlingRule(filter: InventoryHandlingRuleFilter, first: Int, offset: Int): [InventoryHandlingRule]
  msg: String
  numUids: Int
}

type DeleteInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter, first: Int, offset: Int, order: InventoryHoldingPolicyOrder): [InventoryHoldingPolicy]
  msg: String
  numUids: Int
}

type DeleteJobOrderDependencyPayload {
  jobOrderDependency(filter: JobOrderDependencyFilter, first: Int, offset: Int, order: JobOrderDependencyOrder): [JobOrderDependency]
  msg: String
  numUids: Int
}

type DeleteJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(filter: JobOrderDispatchStateModelFilter, first: Int, offset: Int): [JobOrderDispatchStateModel]
  msg: String
  numUids: Int
}

type DeleteJobOrderNotePayload {
  jobOrderNote(filter: JobOrderNoteFilter, first: Int, offset: Int, order: JobOrderNoteOrder): [JobOrderNote]
  msg: String
  numUids: Int
}

type DeleteJobOrderPayload {
  jobOrder(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder]
  msg: String
  numUids: Int
}

type DeleteJobResponsePayload {
  jobResponse(filter: JobResponseFilter, first: Int, offset: Int, order: JobResponseOrder): [JobResponse]
  msg: String
  numUids: Int
}

type DeleteLibreServicePayload {
  libreService(filter: LibreServiceFilter, first: Int, offset: Int, order: LibreServiceOrder): [LibreService]
  msg: String
  numUids: Int
}

type DeleteMaterialActualPayload {
  materialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual]
  msg: String
  numUids: Int
}

type DeleteMaterialAlternatePayload {
  materialAlternate(filter: MaterialAlternateFilter, first: Int, offset: Int, order: MaterialAlternateOrder): [MaterialAlternate]
  msg: String
  numUids: Int
}

type DeleteMaterialClassPayload {
  materialClass(filter: MaterialClassFilter, first: Int, offset: Int, order: MaterialClassOrder): [MaterialClass]
  msg: String
  numUids: Int
}

type DeleteMaterialDefinitionPayload {
  materialDefinition(filter: MaterialDefinitionFilter, first: Int, offset: Int, order: MaterialDefinitionOrder): [MaterialDefinition]
  msg: String
  numUids: Int
}

type DeleteMaterialEventRulesetPayload {
  materialEventRuleset(filter: MaterialEventRulesetFilter, first: Int, offset: Int, order: MaterialEventRulesetOrder): [MaterialEventRuleset]
  msg: String
  numUids: Int
}

type DeleteMaterialLotPayload {
  materialLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot]
  msg: String
  numUids: Int
}

type DeleteMaterialSpecificationPayload {
  materialSpecification(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification]
  msg: String
  numUids: Int
}

type DeleteMaterialStateModelPayload {
  materialStateModel(filter: MaterialStateModelFilter, first: Int, offset: Int, order: MaterialStateModelOrder): [MaterialStateModel]
  msg: String
  numUids: Int
}

type DeleteMaterialStateTransitionPayload {
  materialStateTransition(filter: MaterialStateTransitionFilter, first: Int, offset: Int): [MaterialStateTransition]
  msg: String
  numUids: Int
}

type DeleteMaterialStatusPayload {
  materialStatus(filter: MaterialStatusFilter, first: Int, offset: Int, order: MaterialStatusOrder): [MaterialStatus]
  msg: String
  numUids: Int
}

type DeleteMaterialSubLotPayload {
  materialSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot]
  msg: String
  numUids: Int
}

type DeleteMaterialUnitPayload {
  materialUnit(filter: MaterialUnitFilter, first: Int, offset: Int, order: MaterialUnitOrder): [MaterialUnit]
  msg: String
  numUids: Int
}

type DeleteMenuPayload {
  menu(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu]
  msg: String
  numUids: Int
}

type DeleteOperationsDefinitionPayload {
  msg: String
  numUids: Int
  operationsDefinition(filter: OperationsDefinitionFilter, first: Int, offset: Int, order: OperationsDefinitionOrder): [OperationsDefinition]
}

type DeleteOperationsRequestPayload {
  msg: String
  numUids: Int
  operationsRequest(filter: OperationsRequestFilter, first: Int, offset: Int, order: OperationsRequestOrder): [OperationsRequest]
}

type DeleteOperationsSegmentPayload {
  msg: String
  numUids: Int
  operationsSegment(filter: OperationsSegmentFilter, first: Int, offset: Int, order: OperationsSegmentOrder): [OperationsSegment]
}

type DeleteOrderLinePayload {
  msg: String
  numUids: Int
  orderLine(filter: OrderLineFilter, first: Int, offset: Int, order: OrderLineOrder): [OrderLine]
}

type DeleteOrderPayload {
  msg: String
  numUids: Int
  order(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order]
}

type DeleteOrderStartRulesetPayload {
  msg: String
  numUids: Int
  orderStartRuleset(filter: OrderStartRulesetFilter, first: Int, offset: Int, order: OrderStartRulesetOrder): [OrderStartRuleset]
}

type DeleteParameterSpecificationPayload {
  msg: String
  numUids: Int
  parameterSpecification(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification]
}

type DeletePartnerPayload {
  msg: String
  numUids: Int
  partner(filter: PartnerFilter, first: Int, offset: Int, order: PartnerOrder): [Partner]
}

type DeletePayloadFieldDefinitionPayload {
  msg: String
  numUids: Int
  payloadFieldDefinition(filter: PayloadFieldDefinitionFilter, first: Int, offset: Int, order: PayloadFieldDefinitionOrder): [PayloadFieldDefinition]
}

type DeletePersonnelActualPayload {
  msg: String
  numUids: Int
  personnelActual(filter: PersonnelActualFilter, first: Int, offset: Int, order: PersonnelActualOrder): [PersonnelActual]
}

type DeletePersonnelClassPayload {
  msg: String
  numUids: Int
  personnelClass(filter: PersonnelClassFilter, first: Int, offset: Int, order: PersonnelClassOrder): [PersonnelClass]
}

type DeletePersonnelSpecificationPayload {
  msg: String
  numUids: Int
  personnelSpecification(filter: PersonnelSpecificationFilter, first: Int, offset: Int, order: PersonnelSpecificationOrder): [PersonnelSpecification]
}

type DeletePersonPayload {
  msg: String
  numUids: Int
  person(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person]
}

type DeletePropertyNameAliasPayload {
  msg: String
  numUids: Int
  propertyNameAlias(filter: PropertyNameAliasFilter, first: Int, offset: Int, order: PropertyNameAliasOrder): [PropertyNameAlias]
}

type DeletePropertyPayload {
  msg: String
  numUids: Int
  property(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property]
}

type DeletePropertyValueAliasPayload {
  msg: String
  numUids: Int
  propertyValueAlias(filter: PropertyValueAliasFilter, first: Int, offset: Int, order: PropertyValueAliasOrder): [PropertyValueAlias]
}

type DeleteQuantityLogPayload {
  msg: String
  numUids: Int
  quantityLog(filter: QuantityLogFilter, first: Int, offset: Int, order: QuantityLogOrder): [QuantityLog]
}

type DeleteReasonCategoryPayload {
  msg: String
  numUids: Int
  reasonCategory(filter: ReasonCategoryFilter, first: Int, offset: Int, order: ReasonCategoryOrder): [ReasonCategory]
}

type DeleteReasonPayload {
  msg: String
  numUids: Int
  reason(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason]
}

type DeleteRequestStatePayload {
  msg: String
  numUids: Int
  requestState(filter: RequestStateFilter, first: Int, offset: Int, order: RequestStateOrder): [RequestState]
}

type DeleteRolePayload {
  msg: String
  numUids: Int
  role(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role]
}

type DeleteSegmentDependencyPayload {
  msg: String
  numUids: Int
  segmentDependency(filter: SegmentDependencyFilter, first: Int, offset: Int, order: SegmentDependencyOrder): [SegmentDependency]
}

type DeleteSegmentInvoiceSettingPayload {
  msg: String
  numUids: Int
  segmentInvoiceSetting(filter: SegmentInvoiceSettingFilter, first: Int, offset: Int, order: SegmentInvoiceSettingOrder): [SegmentInvoiceSetting]
}

type DeleteShipmentItemPayload {
  msg: String
  numUids: Int
  shipmentItem(filter: ShipmentItemFilter, first: Int, offset: Int, order: ShipmentItemOrder): [ShipmentItem]
}

type DeleteShipmentPayload {
  msg: String
  numUids: Int
  shipment(filter: ShipmentFilter, first: Int, offset: Int, order: ShipmentOrder): [Shipment]
}

type DeleteShippingAccountPayload {
  msg: String
  numUids: Int
  shippingAccount(filter: ShippingAccountFilter, first: Int, offset: Int, order: ShippingAccountOrder): [ShippingAccount]
}

type DeleteStateEventRulesetPayload {
  msg: String
  numUids: Int
  stateEventRuleset(filter: StateEventRulesetFilter, first: Int, offset: Int, order: StateEventRulesetOrder): [StateEventRuleset]
}

type DeleteTestResultPayload {
  msg: String
  numUids: Int
  testResult(filter: TestResultFilter, first: Int, offset: Int, order: TestResultOrder): [TestResult]
}

type DeleteTestSpecificationPayload {
  msg: String
  numUids: Int
  testSpecification(filter: TestSpecificationFilter, first: Int, offset: Int, order: TestSpecificationOrder): [TestSpecification]
}

type DeleteTransitionEventRulesetPayload {
  msg: String
  numUids: Int
  transitionEventRuleset(filter: TransitionEventRulesetFilter, first: Int, offset: Int, order: TransitionEventRulesetOrder): [TransitionEventRuleset]
}

type DeleteUnitOfMeasureConversionPayload {
  msg: String
  numUids: Int
  unitOfMeasureConversion(filter: UnitOfMeasureConversionFilter, first: Int, offset: Int, order: UnitOfMeasureConversionOrder): [UnitOfMeasureConversion]
}

type DeleteUnitOfMeasurePayload {
  msg: String
  numUids: Int
  unitOfMeasure(filter: UnitOfMeasureFilter, first: Int, offset: Int, order: UnitOfMeasureOrder): [UnitOfMeasure]
}

type DeleteUserPayload {
  msg: String
  numUids: Int
  user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

type DeleteUserRolePayload {
  msg: String
  numUids: Int
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
}

type DeleteWorkCalendarDefinitionEntryPayload {
  msg: String
  numUids: Int
  workCalendarDefinitionEntry(filter: WorkCalendarDefinitionEntryFilter, first: Int, offset: Int, order: WorkCalendarDefinitionEntryOrder): [WorkCalendarDefinitionEntry]
}

type DeleteWorkCalendarEntryPayload {
  msg: String
  numUids: Int
  workCalendarEntry(filter: WorkCalendarEntryFilter, first: Int, offset: Int, order: WorkCalendarEntryOrder): [WorkCalendarEntry]
}

type DeleteWorkCalendarPayload {
  msg: String
  numUids: Int
  workCalendar(filter: WorkCalendarFilter, first: Int, offset: Int, order: WorkCalendarOrder): [WorkCalendar]
}

type DeleteWorkflowConnectionPayload {
  msg: String
  numUids: Int
  workflowConnection(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection]
}

type DeleteWorkflowConnectionTypePayload {
  msg: String
  numUids: Int
  workflowConnectionType(filter: WorkflowConnectionTypeFilter, first: Int, offset: Int, order: WorkflowConnectionTypeOrder): [WorkflowConnectionType]
}

type DeleteWorkflowInstancePayload {
  msg: String
  numUids: Int
  workflowInstance(filter: WorkflowInstanceFilter, first: Int, offset: Int, order: WorkflowInstanceOrder): [WorkflowInstance]
}

type DeleteWorkflowInstancePropertyPayload {
  msg: String
  numUids: Int
  workflowInstanceProperty(filter: WorkflowInstancePropertyFilter, first: Int, offset: Int, order: WorkflowInstancePropertyOrder): [WorkflowInstanceProperty]
}

type DeleteWorkflowNodeEventPayload {
  msg: String
  numUids: Int
  workflowNodeEvent(filter: WorkflowNodeEventFilter, first: Int, offset: Int, order: WorkflowNodeEventOrder): [WorkflowNodeEvent]
}

type DeleteWorkflowNodeInstancePayload {
  msg: String
  numUids: Int
  workflowNodeInstance(filter: WorkflowNodeInstanceFilter, first: Int, offset: Int, order: WorkflowNodeInstanceOrder): [WorkflowNodeInstance]
}

type DeleteWorkflowNodePayload {
  msg: String
  numUids: Int
  workflowNode(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode]
}

type DeleteWorkflowNodeTypePayload {
  msg: String
  numUids: Int
  workflowNodeType(filter: WorkflowNodeTypeFilter, first: Int, offset: Int, order: WorkflowNodeTypeOrder): [WorkflowNodeType]
}

type DeleteWorkflowPropertyInstancePayload {
  msg: String
  numUids: Int
  workflowPropertyInstance(filter: WorkflowPropertyInstanceFilter, first: Int, offset: Int, order: WorkflowPropertyInstanceOrder): [WorkflowPropertyInstance]
}

type DeleteWorkflowPropertyPayload {
  msg: String
  numUids: Int
  workflowProperty(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty]
}

type DeleteWorkflowPropertyValuePayload {
  msg: String
  numUids: Int
  workflowPropertyValue(filter: WorkflowPropertyValueFilter, first: Int, offset: Int, order: WorkflowPropertyValueOrder): [WorkflowPropertyValue]
}

type DeleteWorkflowSpecificationPayload {
  msg: String
  numUids: Int
  workflowSpecification(filter: WorkflowSpecificationFilter, first: Int, offset: Int, order: WorkflowSpecificationOrder): [WorkflowSpecification]
}

type Delivery
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  dateTime: DateTime! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  location(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  operator(filter: UserFilter): User @join__field(graph: SCHEMA)
  partner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
  shipments(filter: ShipmentFilter, first: Int, offset: Int, order: ShipmentOrder): [Shipment] @join__field(graph: SCHEMA)
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult @join__field(graph: SCHEMA)
  transportCompany: TransportCompany @join__field(graph: SCHEMA)
  transportCompanyDeliveryId: String @join__field(graph: SCHEMA)
}

type DeliveryAggregateResult {
  count: Int
  dateTimeMax: DateTime
  dateTimeMin: DateTime
  transportCompanyDeliveryIdMax: String
  transportCompanyDeliveryIdMin: String
}

input DeliveryFilter {
  and: [DeliveryFilter]
  has: [DeliveryHasFilter]
  id: [ID!]
  not: DeliveryFilter
  or: [DeliveryFilter]
}

enum DeliveryHasFilter {
  dateTime
  location
  operator
  partner
  shipments
  transportCompany
  transportCompanyDeliveryId
}

input DeliveryOrder {
  asc: DeliveryOrderable
  desc: DeliveryOrderable
  then: DeliveryOrder
}

enum DeliveryOrderable {
  dateTime
  transportCompanyDeliveryId
}

input DeliveryPatch {
  dateTime: DateTime
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  shipments: [ShipmentRef]
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

input DeliveryRef {
  dateTime: DateTime
  id: ID
  location: EquipmentRef
  operator: UserRef
  partner: PartnerRef
  shipments: [ShipmentRef]
  transportCompany: TransportCompany
  transportCompanyDeliveryId: String
}

enum DependencyType {
  CanRunParallel
  CannotRunParallel
  EndAfterEnd
  EndAfterStart
  StartAfterEnd
  StartAfterStart
}

input DgraphDefault {
  value: String
}

enum DgraphIndex {
  bool
  day
  exact
  float
  fulltext
  geo
  hash
  hour
  int
  int64
  month
  regexp
  term
  trigram
  year
}

enum DispatchStatus {
  ACTIVE
  CANCELED
  CLOSED
  COMPLETE
  CREATED
  PARKED
  PENDING
  RELEASED
}

input DispatchStatus_hash {
  eq: DispatchStatus
  in: [DispatchStatus]
}

type Equipment
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
  @join__type(graph: WMS, key: "id")
{
  addressTemplate: String @join__field(graph: SCHEMA)
  allowAdhocWorklog: Boolean @join__field(graph: SCHEMA)
  backfillStatus: EquipmentBackfillStatus @join__field(graph: CORE)
  carriers(filter: CarrierFilter, first: Int, offset: Int, order: CarrierOrder): [Carrier] @join__field(graph: SCHEMA)
  carriersAggregate(filter: CarrierFilter): CarrierAggregateResult @join__field(graph: SCHEMA)
  children(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment] @join__field(graph: SCHEMA)
  childrenAggregate(filter: EquipmentFilter): EquipmentAggregateResult @join__field(graph: SCHEMA)
  currentStatus: EventsByField @join__field(graph: CORE)
  dataProvider: DataProvider @join__field(graph: SCHEMA)
  dataProviderConnection: String @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  displayName: String @join__field(graph: SCHEMA)
  equipmentActual(filter: EquipmentActualFilter, first: Int, offset: Int, order: EquipmentActualOrder): [EquipmentActual] @join__field(graph: SCHEMA)
  equipmentActualAggregate(filter: EquipmentActualFilter): EquipmentActualAggregateResult @join__field(graph: SCHEMA)
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass @join__field(graph: SCHEMA)
  equipmentLevel: EquipmentElementLevel @join__field(graph: SCHEMA)
  erpAssetID: String @join__field(graph: SCHEMA)
  eventSummaryByReason(filter: EventSummaryByReasonFilter): [EventSummaryByReason] @join__field(graph: CORE)
  events(filter: EventLogFilter, first: Int, offset: Int, order: EventLogOrder): [EventLog] @join__field(graph: SCHEMA)
  eventsAggregate(filter: EventLogFilter): EventLogAggregateResult @join__field(graph: SCHEMA)
  eventsByField(filter: EventsByFieldFilter!): [EventsByField] @join__field(graph: CORE)

  """deprecated"""
  eventsByTimeRange(filter: TimeRangeFilter): [EventLog] @join__field(graph: CORE, provides: "startDateTime endDateTime duration")
  id: ID! @join__field(graph: SCHEMA)
  inflows(filter: EquipmentRelationFilter, first: Int, offset: Int, order: EquipmentRelationOrder): [EquipmentRelation] @join__field(graph: SCHEMA)
  inflowsAggregate(filter: EquipmentRelationFilter): EquipmentRelationAggregateResult @join__field(graph: SCHEMA)
  inventoryHandlingRules(filter: InventoryHandlingRuleFilter, first: Int, offset: Int): [InventoryHandlingRule] @join__field(graph: SCHEMA)
  inventoryHandlingRulesAggregate(filter: InventoryHandlingRuleFilter): InventoryHandlingRuleAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrders(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder] @join__field(graph: SCHEMA)
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult @join__field(graph: SCHEMA)
  jobResponses(filter: JobResponseFilter, first: Int, offset: Int, order: JobResponseOrder): [JobResponse] @join__field(graph: SCHEMA)
  jobResponsesAggregate(filter: JobResponseFilter): JobResponseAggregateResult @join__field(graph: SCHEMA)
  jobResponsesByTimeRange(filter: TimeRangeFilter): [JobResponse] @join__field(graph: CORE, provides: "startDateTime endDateTime actualDuration")
  kpi(filter: TimeRangeFilter!): Kpi @join__field(graph: CORE)
  kpiByWorkCalendarEntry(filter: TimeRangeFilter!): [KpiByWorkCalendarEntry] @join__field(graph: CORE)
  label: String @join__field(graph: SCHEMA)
  maintenanceCallsByTimeRange(filter: TimeRangeFilter!): [MaintenanceLog] @join__field(graph: CORE)
  materialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment] @join__field(graph: WMS)
  materialSubLots(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  materialSubLotsAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  mpmAutoIdentMatchSource: String @join__field(graph: SCHEMA)
  mpmEnableAutoIdentMatching: Boolean @join__field(graph: SCHEMA)
  mpmEnableCallMaintenanceEvent: Boolean @join__field(graph: SCHEMA)
  mpmEnableJobInterlock: Boolean @join__field(graph: SCHEMA)
  mpmEnableMaintenanceHandover: Boolean @join__field(graph: SCHEMA)
  mpmEnableManualBreak: Boolean @join__field(graph: SCHEMA)
  mpmEnableManualPlannedMaint: Boolean @join__field(graph: SCHEMA)
  mpmEnableManualShiftEnd: Boolean @join__field(graph: SCHEMA)
  mpmEnableManualShiftStart: Boolean @join__field(graph: SCHEMA)
  mpmEnableORCBlockNextOrder: Boolean @join__field(graph: SCHEMA)
  mpmEnableORCRevokePermissive: Boolean @join__field(graph: SCHEMA)
  mpmEnableORCWarning: Boolean @join__field(graph: SCHEMA)
  mpmEnableSetupCloseDetection: Boolean @join__field(graph: SCHEMA)
  mpmEnableSetupStartDetection: Boolean @join__field(graph: SCHEMA)
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers @join__field(graph: SCHEMA)
  mpmORCWarnTrigger: mpmORCWarnTriggers @join__field(graph: SCHEMA)
  mpmPermissiveOutputName: String @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  ocsChosenStopTime: DateTime @join__field(graph: SCHEMA)
  ocsEnabled: Boolean @join__field(graph: SCHEMA)
  ocsPageState: String @join__field(graph: SCHEMA)
  ocsWorkflowSelector: String @join__field(graph: SCHEMA)
  operationsRequests(filter: OperationsRequestFilter, first: Int, offset: Int, order: OperationsRequestOrder): [OperationsRequest] @join__field(graph: SCHEMA)
  operationsRequestsAggregate(filter: OperationsRequestFilter): OperationsRequestAggregateResult @join__field(graph: SCHEMA)
  orders(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order] @join__field(graph: SCHEMA)
  ordersAggregate(filter: OrderFilter): OrderAggregateResult @join__field(graph: SCHEMA)
  outflows(filter: EquipmentRelationFilter, first: Int, offset: Int, order: EquipmentRelationOrder): [EquipmentRelation] @join__field(graph: SCHEMA)
  outflowsAggregate(filter: EquipmentRelationFilter): EquipmentRelationAggregateResult @join__field(graph: SCHEMA)
  parent(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)

  """
   PropertyList contains a list properties that are inherited by this equipment's class. Properties that defined at multiple levels
  in the class inheritance are child dominant. Domination is on property name only.
  """
  propertyList(filter: PropertyListFilter): [Property] @join__field(graph: CORE, provides: "name expression value storeHistory")

  """
   PropertyListWithOverrides contains a list of properties directly associated with this equipment, and properties that are
  inherited by this equipments's class. Properties directly assocated with this equipment are dominant over class inherited properties.
  """
  propertyListWithOverrides(filter: PropertyListFilter): [Property] @join__field(graph: CORE, provides: "name expression value storeHistory")
  propertyNameAliases(filter: PropertyNameAliasFilter, first: Int, offset: Int, order: PropertyNameAliasOrder): [PropertyNameAlias] @join__field(graph: SCHEMA)
  propertyNameAliasesAggregate(filter: PropertyNameAliasFilter): PropertyNameAliasAggregateResult @join__field(graph: SCHEMA)
  propertyOverrides(filter: EquipmentPropertyOverrideFilter, first: Int, offset: Int, order: EquipmentPropertyOverrideOrder): [EquipmentPropertyOverride] @join__field(graph: SCHEMA)
  propertyOverridesAggregate(filter: EquipmentPropertyOverrideFilter): EquipmentPropertyOverrideAggregateResult @join__field(graph: SCHEMA)
  propertyValues(filter: PropertyValuesFilter!): [PropertyValue] @join__field(graph: CORE)
  quantities(filter: QuantityLogFilter, first: Int, offset: Int, order: QuantityLogOrder): [QuantityLog] @join__field(graph: SCHEMA)
  quantitiesAggregate(filter: QuantityLogFilter): QuantityLogAggregateResult @join__field(graph: SCHEMA)
  reasonList: [Reason] @join__field(graph: CORE, provides: "standardValue")
  reasonListWithOverrides(filter: ReasonFilter): [Reason] @join__field(graph: CORE, provides: "standardValue")
  reasonOverrides(filter: EquipmentReasonOverrideFilter, first: Int, offset: Int, order: EquipmentReasonOverrideOrder): [EquipmentReasonOverride] @join__field(graph: SCHEMA)
  reasonOverridesAggregate(filter: EquipmentReasonOverrideFilter): EquipmentReasonOverrideAggregateResult @join__field(graph: SCHEMA)
  reasons(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason] @join__field(graph: SCHEMA)
  reasonsAggregate(filter: ReasonFilter): ReasonAggregateResult @join__field(graph: SCHEMA)
  shipmentItems(filter: ShipmentItemFilter, first: Int, offset: Int, order: ShipmentItemOrder): [ShipmentItem] @join__field(graph: SCHEMA)
  shipmentItemsAggregate(filter: ShipmentItemFilter): ShipmentItemAggregateResult @join__field(graph: SCHEMA)
  shipments(filter: ShipmentFilter, first: Int, offset: Int, order: ShipmentOrder): [Shipment] @join__field(graph: SCHEMA)
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult @join__field(graph: SCHEMA)
  stagedOrders(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order] @join__field(graph: SCHEMA)
  stagedOrdersAggregate(filter: OrderFilter): OrderAggregateResult @join__field(graph: SCHEMA)
  timeZoneName: String @join__field(graph: SCHEMA)
  userRoles(filter: UserRoleFilter, first: Int, offset: Int): [UserRole] @join__field(graph: SCHEMA)
  userRolesAggregate(filter: UserRoleFilter): UserRoleAggregateResult @join__field(graph: SCHEMA)
  workCalendar(filter: WorkCalendarFilter): WorkCalendar @join__field(graph: SCHEMA)
  workSpecifications(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification] @join__field(graph: SCHEMA)
  workSpecificationsAggregate(filter: EquipmentSpecificationFilter): EquipmentSpecificationAggregateResult @join__field(graph: SCHEMA)
  workflowInstances(filter: WorkflowInstanceFilter, first: Int, offset: Int, order: WorkflowInstanceOrder): [WorkflowInstance] @join__field(graph: SCHEMA)
  workflowInstancesAggregate(filter: WorkflowInstanceFilter): WorkflowInstanceAggregateResult @join__field(graph: SCHEMA)
}

type EquipmentActual
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobResponse(filter: JobResponseFilter): JobResponse! @join__field(graph: SCHEMA)
  quantity: Float @join__field(graph: SCHEMA)
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type EquipmentActualAggregateResult {
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input EquipmentActualFilter {
  and: [EquipmentActualFilter]
  has: [EquipmentActualHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentActualFilter
  or: [EquipmentActualFilter]
}

enum EquipmentActualHasFilter {
  equipment
  isActive
  jobResponse
  quantity
  quantityUoM
}

input EquipmentActualOrder {
  asc: EquipmentActualOrderable
  desc: EquipmentActualOrderable
  then: EquipmentActualOrder
}

enum EquipmentActualOrderable {
  quantity
}

input EquipmentActualPatch {
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input EquipmentActualRef {
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type EquipmentAggregateResult {
  addressTemplateMax: String
  addressTemplateMin: String
  count: Int
  dataProviderConnectionMax: String
  dataProviderConnectionMin: String
  descriptionMax: String
  descriptionMin: String
  displayNameMax: String
  displayNameMin: String
  erpAssetIDMax: String
  erpAssetIDMin: String
  labelMax: String
  labelMin: String
  mpmAutoIdentMatchSourceMax: String
  mpmAutoIdentMatchSourceMin: String
  mpmPermissiveOutputNameMax: String
  mpmPermissiveOutputNameMin: String
  nameMax: String
  nameMin: String
  ocsChosenStopTimeMax: DateTime
  ocsChosenStopTimeMin: DateTime
  ocsPageStateMax: String
  ocsPageStateMin: String
  ocsWorkflowSelectorMax: String
  ocsWorkflowSelectorMin: String
  timeZoneNameMax: String
  timeZoneNameMin: String
}

enum EquipmentBackfillStatus {
  CANCELED
  COMPLETE
  ERROR
  INITIALIZING
  READY
  RUNNING
}

"""
EquipmentClasses are used to manage configuration that is common to a number of similar equipment
The data properties that an equipment is expected to have are defined on the equipment class
"""
type EquipmentClass
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  addressTemplate: String @join__field(graph: SCHEMA)
  children(filter: EquipmentClassFilter, first: Int, offset: Int, order: EquipmentClassOrder): [EquipmentClass] @join__field(graph: SCHEMA)
  childrenAggregate(filter: EquipmentClassFilter): EquipmentClassAggregateResult @join__field(graph: SCHEMA)
  dashboardConfig(filter: DashboardConfigFilter): DashboardConfig @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  displayName: String @join__field(graph: SCHEMA)
  equipmentLevel: EquipmentElementLevel @join__field(graph: SCHEMA)
  equipmentSpecifications(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification] @join__field(graph: SCHEMA)
  equipmentSpecificationsAggregate(filter: EquipmentSpecificationFilter): EquipmentSpecificationAggregateResult @join__field(graph: SCHEMA)
  equipments(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment] @join__field(graph: SCHEMA)
  equipmentsAggregate(filter: EquipmentFilter): EquipmentAggregateResult @join__field(graph: SCHEMA)
  eventDefinitions(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition] @join__field(graph: SCHEMA)
  eventDefinitionsAggregate(filter: EventDefinitionFilter): EventDefinitionAggregateResult @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  image: String @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  label: String @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  parent(filter: EquipmentClassFilter): EquipmentClass @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  propertyList(filter: PropertyListFilter): [Property] @join__field(graph: CORE, provides: "name expression value storeHistory")
  reasons(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason] @join__field(graph: SCHEMA)
  reasonsAggregate(filter: ReasonFilter): ReasonAggregateResult @join__field(graph: SCHEMA)
}

type EquipmentClassAggregateResult {
  addressTemplateMax: String
  addressTemplateMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  displayNameMax: String
  displayNameMin: String
  imageMax: String
  imageMin: String
  labelMax: String
  labelMin: String
  nameMax: String
  nameMin: String
}

input EquipmentClassFilter {
  and: [EquipmentClassFilter]
  description: StringHashFilter
  displayName: StringHashFilter
  has: [EquipmentClassHasFilter]
  id: [ID!]
  isActive: Boolean
  label: StringHashFilter
  name: StringHashFilter
  not: EquipmentClassFilter
  or: [EquipmentClassFilter]
}

enum EquipmentClassHasFilter {
  addressTemplate
  children
  dashboardConfig
  description
  displayName
  equipmentLevel
  equipmentSpecifications
  equipments
  eventDefinitions
  image
  isActive
  label
  name
  parent
  properties
  reasons
}

input EquipmentClassOrder {
  asc: EquipmentClassOrderable
  desc: EquipmentClassOrderable
  then: EquipmentClassOrder
}

enum EquipmentClassOrderable {
  addressTemplate
  description
  displayName
  image
  label
  name
}

input EquipmentClassPatch {
  addressTemplate: String
  children: [EquipmentClassRef]
  dashboardConfig: DashboardConfigRef
  description: String
  displayName: String
  equipmentLevel: EquipmentElementLevel
  equipmentSpecifications: [EquipmentSpecificationRef]
  equipments: [EquipmentRef]
  eventDefinitions: [EventDefinitionRef]
  image: String
  isActive: Boolean
  label: String
  name: String
  parent: EquipmentClassRef
  properties: [PropertyRef]
  reasons: [ReasonRef]
}

input EquipmentClassRef {
  addressTemplate: String
  children: [EquipmentClassRef]
  dashboardConfig: DashboardConfigRef
  description: String
  displayName: String
  equipmentLevel: EquipmentElementLevel
  equipmentSpecifications: [EquipmentSpecificationRef]
  equipments: [EquipmentRef]
  eventDefinitions: [EventDefinitionRef]
  id: ID
  image: String
  isActive: Boolean
  label: String
  name: String
  parent: EquipmentClassRef
  properties: [PropertyRef]
  reasons: [ReasonRef]
}

enum EquipmentElementLevel {
  Area
  ControlModule
  Enterprise
  EquipmentModule
  Other
  ProcessCell
  ProductionLine
  ProductionUnit
  Site
  StorageUnit
  StorageZone
  Unit
  Warehouse
  WorkCell
  WorkCenter
  WorkUnit
}

input EquipmentElementLevel_hash {
  eq: EquipmentElementLevel
  in: [EquipmentElementLevel]
}

input EquipmentFilter {
  and: [EquipmentFilter]
  description: StringHashFilter
  displayName: StringHashFilter
  equipmentLevel: EquipmentElementLevel_hash
  erpAssetID: StringHashFilter
  has: [EquipmentHasFilter]
  id: [ID!]
  isActive: Boolean
  label: StringHashFilter
  name: StringHashFilter
  not: EquipmentFilter
  or: [EquipmentFilter]
}

enum EquipmentHasFilter {
  addressTemplate
  allowAdhocWorklog
  carriers
  children
  dataProvider
  dataProviderConnection
  description
  displayName
  equipmentActual
  equipmentClass
  equipmentLevel
  erpAssetID
  events
  inflows
  inventoryHandlingRules
  isActive
  jobOrders
  jobResponses
  label
  materialSubLots
  mpmAutoIdentMatchSource
  mpmEnableAutoIdentMatching
  mpmEnableCallMaintenanceEvent
  mpmEnableJobInterlock
  mpmEnableMaintenanceHandover
  mpmEnableManualBreak
  mpmEnableManualPlannedMaint
  mpmEnableManualShiftEnd
  mpmEnableManualShiftStart
  mpmEnableORCBlockNextOrder
  mpmEnableORCRevokePermissive
  mpmEnableORCWarning
  mpmEnableSetupCloseDetection
  mpmEnableSetupStartDetection
  mpmORCRevokePermissiveTrigger
  mpmORCWarnTrigger
  mpmPermissiveOutputName
  name
  ocsChosenStopTime
  ocsEnabled
  ocsPageState
  ocsWorkflowSelector
  operationsRequests
  orders
  outflows
  parent
  properties
  propertyNameAliases
  propertyOverrides
  quantities
  reasonOverrides
  reasons
  shipmentItems
  shipments
  stagedOrders
  timeZoneName
  userRoles
  workCalendar
  workSpecifications
  workflowInstances
}

type EquipmentNameAlias {
  alias: String!
  equipment(filter: EquipmentFilter): Equipment!
  id: ID!
  system: String!
}

type EquipmentNameAliasAggregateResult {
  aliasMax: String
  aliasMin: String
  count: Int
  systemMax: String
  systemMin: String
}

input EquipmentNameAliasFilter {
  alias: StringFullTextFilter
  and: [EquipmentNameAliasFilter]
  has: [EquipmentNameAliasHasFilter]
  id: [ID!]
  not: EquipmentNameAliasFilter
  or: [EquipmentNameAliasFilter]
  system: StringFullTextFilter
}

enum EquipmentNameAliasHasFilter {
  alias
  equipment
  system
}

input EquipmentNameAliasOrder {
  asc: EquipmentNameAliasOrderable
  desc: EquipmentNameAliasOrderable
  then: EquipmentNameAliasOrder
}

enum EquipmentNameAliasOrderable {
  alias
  system
}

input EquipmentNameAliasPatch {
  alias: String
  equipment: EquipmentRef
  system: String
}

input EquipmentNameAliasRef {
  alias: String
  equipment: EquipmentRef
  id: ID
  system: String
}

input EquipmentOrder {
  asc: EquipmentOrderable
  desc: EquipmentOrderable
  then: EquipmentOrder
}

enum EquipmentOrderable {
  addressTemplate
  dataProviderConnection
  description
  displayName
  erpAssetID
  label
  mpmAutoIdentMatchSource
  mpmPermissiveOutputName
  name
  ocsChosenStopTime
  ocsPageState
  ocsWorkflowSelector
  timeZoneName
}

input EquipmentPatch {
  addressTemplate: String
  allowAdhocWorklog: Boolean
  carriers: [CarrierRef]
  children: [EquipmentRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  description: String
  displayName: String
  equipmentActual: [EquipmentActualRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  erpAssetID: String
  events: [EventLogRef]
  inflows: [EquipmentRelationRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  jobResponses: [JobResponseRef]
  label: String
  materialSubLots: [MaterialSubLotRef]
  mpmAutoIdentMatchSource: String
  mpmEnableAutoIdentMatching: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableJobInterlock: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableORCRevokePermissive: Boolean
  mpmEnableORCWarning: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableSetupStartDetection: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmPermissiveOutputName: String
  name: String
  ocsChosenStopTime: DateTime
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  operationsRequests: [OperationsRequestRef]
  orders: [OrderRef]
  outflows: [EquipmentRelationRef]
  parent: EquipmentRef
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  quantities: [QuantityLogRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  reasons: [ReasonRef]
  shipmentItems: [ShipmentItemRef]
  shipments: [ShipmentRef]
  stagedOrders: [OrderRef]
  timeZoneName: String
  userRoles: [UserRoleRef]
  workCalendar: WorkCalendarRef
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
}

type EquipmentPropertyOverride
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  address: String @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment! @join__field(graph: SCHEMA)
  expression: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  ignore: Boolean @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  property(filter: PropertyFilter): Property! @join__field(graph: SCHEMA)
  storeHistory: Boolean @join__field(graph: SCHEMA)
  value: String @join__field(graph: SCHEMA)
}

type EquipmentPropertyOverrideAggregateResult {
  addressMax: String
  addressMin: String
  count: Int
  expressionMax: String
  expressionMin: String
  valueMax: String
  valueMin: String
}

input EquipmentPropertyOverrideFilter {
  and: [EquipmentPropertyOverrideFilter]
  has: [EquipmentPropertyOverrideHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentPropertyOverrideFilter
  or: [EquipmentPropertyOverrideFilter]
}

enum EquipmentPropertyOverrideHasFilter {
  address
  equipment
  expression
  ignore
  isActive
  property
  storeHistory
  value
}

input EquipmentPropertyOverrideOrder {
  asc: EquipmentPropertyOverrideOrderable
  desc: EquipmentPropertyOverrideOrderable
  then: EquipmentPropertyOverrideOrder
}

enum EquipmentPropertyOverrideOrderable {
  address
  expression
  value
}

input EquipmentPropertyOverridePatch {
  address: String
  equipment: EquipmentRef
  expression: String
  ignore: Boolean
  isActive: Boolean
  property: PropertyRef
  storeHistory: Boolean
  value: String
}

input EquipmentPropertyOverrideRef {
  address: String
  equipment: EquipmentRef
  expression: String
  id: ID
  ignore: Boolean
  isActive: Boolean
  property: PropertyRef
  storeHistory: Boolean
  value: String
}

"""
EquipmentReasonOverrides are used to make equipment specific changes to equipment class reasons.
This allows 'Master Lists' of reasons to be defined on the equipment class and for overrides to the master
reasons to be made at the equipment level
"""
type EquipmentReasonOverride
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  ignore: Boolean @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  reason(filter: ReasonFilter): Reason @join__field(graph: SCHEMA)
  standardValue: Float @join__field(graph: SCHEMA)
}

type EquipmentReasonOverrideAggregateResult {
  count: Int
  standardValueAvg: Float
  standardValueMax: Float
  standardValueMin: Float
  standardValueSum: Float
}

input EquipmentReasonOverrideFilter {
  and: [EquipmentReasonOverrideFilter]
  has: [EquipmentReasonOverrideHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentReasonOverrideFilter
  or: [EquipmentReasonOverrideFilter]
}

enum EquipmentReasonOverrideHasFilter {
  equipment
  ignore
  isActive
  reason
  standardValue
}

input EquipmentReasonOverrideOrder {
  asc: EquipmentReasonOverrideOrderable
  desc: EquipmentReasonOverrideOrderable
  then: EquipmentReasonOverrideOrder
}

enum EquipmentReasonOverrideOrderable {
  standardValue
}

input EquipmentReasonOverridePatch {
  equipment: EquipmentRef
  ignore: Boolean
  isActive: Boolean
  reason: ReasonRef
  standardValue: Float
}

input EquipmentReasonOverrideRef {
  equipment: EquipmentRef
  id: ID
  ignore: Boolean
  isActive: Boolean
  reason: ReasonRef
  standardValue: Float
}

input EquipmentRef {
  addressTemplate: String
  allowAdhocWorklog: Boolean
  carriers: [CarrierRef]
  children: [EquipmentRef]
  dataProvider: DataProvider
  dataProviderConnection: String
  description: String
  displayName: String
  equipmentActual: [EquipmentActualRef]
  equipmentClass: EquipmentClassRef
  equipmentLevel: EquipmentElementLevel
  erpAssetID: String
  events: [EventLogRef]
  id: ID
  inflows: [EquipmentRelationRef]
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  jobResponses: [JobResponseRef]
  label: String
  materialSubLots: [MaterialSubLotRef]
  mpmAutoIdentMatchSource: String
  mpmEnableAutoIdentMatching: Boolean
  mpmEnableCallMaintenanceEvent: Boolean
  mpmEnableJobInterlock: Boolean
  mpmEnableMaintenanceHandover: Boolean
  mpmEnableManualBreak: Boolean
  mpmEnableManualPlannedMaint: Boolean
  mpmEnableManualShiftEnd: Boolean
  mpmEnableManualShiftStart: Boolean
  mpmEnableORCBlockNextOrder: Boolean
  mpmEnableORCRevokePermissive: Boolean
  mpmEnableORCWarning: Boolean
  mpmEnableSetupCloseDetection: Boolean
  mpmEnableSetupStartDetection: Boolean
  mpmORCRevokePermissiveTrigger: mpmORCRevokeTriggers
  mpmORCWarnTrigger: mpmORCWarnTriggers
  mpmPermissiveOutputName: String
  name: String
  ocsChosenStopTime: DateTime
  ocsEnabled: Boolean
  ocsPageState: String
  ocsWorkflowSelector: String
  operationsRequests: [OperationsRequestRef]
  orders: [OrderRef]
  outflows: [EquipmentRelationRef]
  parent: EquipmentRef
  properties: [PropertyRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  quantities: [QuantityLogRef]
  reasonOverrides: [EquipmentReasonOverrideRef]
  reasons: [ReasonRef]
  shipmentItems: [ShipmentItemRef]
  shipments: [ShipmentRef]
  stagedOrders: [OrderRef]
  timeZoneName: String
  userRoles: [UserRoleRef]
  workCalendar: WorkCalendarRef
  workSpecifications: [EquipmentSpecificationRef]
  workflowInstances: [WorkflowInstanceRef]
}

type EquipmentRelation
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  code: String @join__field(graph: SCHEMA)
  from(filter: EquipmentFilter): Equipment! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  to(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  type: EquipmentRelationshipType! @join__field(graph: SCHEMA)
}

type EquipmentRelationAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
}

input EquipmentRelationFilter {
  and: [EquipmentRelationFilter]
  code: StringHashFilter
  has: [EquipmentRelationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentRelationFilter
  or: [EquipmentRelationFilter]
}

enum EquipmentRelationHasFilter {
  code
  from
  isActive
  to
  type
}

input EquipmentRelationOrder {
  asc: EquipmentRelationOrderable
  desc: EquipmentRelationOrderable
  then: EquipmentRelationOrder
}

enum EquipmentRelationOrderable {
  code
}

input EquipmentRelationPatch {
  code: String
  from: EquipmentRef
  isActive: Boolean
  to: EquipmentRef
  type: EquipmentRelationshipType
}

input EquipmentRelationRef {
  code: String
  from: EquipmentRef
  id: ID
  isActive: Boolean
  to: EquipmentRef
  type: EquipmentRelationshipType
}

enum EquipmentRelationshipType {
  PERMANENT
  TEMPORARY
}

type EquipmentSpecification
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrder(filter: JobOrderFilter): JobOrder @join__field(graph: SCHEMA)
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment @join__field(graph: SCHEMA)
  quantity: Float @join__field(graph: SCHEMA)
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type EquipmentSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input EquipmentSpecificationFilter {
  and: [EquipmentSpecificationFilter]
  has: [EquipmentSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EquipmentSpecificationFilter
  or: [EquipmentSpecificationFilter]
}

enum EquipmentSpecificationHasFilter {
  description
  equipment
  equipmentClass
  isActive
  jobOrder
  operationsSegment
  quantity
  uom
}

input EquipmentSpecificationOrder {
  asc: EquipmentSpecificationOrderable
  desc: EquipmentSpecificationOrderable
  then: EquipmentSpecificationOrder
}

enum EquipmentSpecificationOrderable {
  description
  quantity
}

input EquipmentSpecificationPatch {
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

input EquipmentSpecificationRef {
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

"""Multiple equipment events can be defined for an Equipment Template."""
type EventDefinition
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  delayOption: Boolean @join__field(graph: SCHEMA)
  delayTime: Int @join__field(graph: SCHEMA)
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  materialEventRuleset(filter: MaterialEventRulesetFilter): MaterialEventRuleset @join__field(graph: SCHEMA)
  messageClass: MessageClass! @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  orderStartRuleset(filter: OrderStartRulesetFilter): OrderStartRuleset @join__field(graph: SCHEMA)
  payloadFields(filter: PayloadFieldDefinitionFilter, first: Int, offset: Int, order: PayloadFieldDefinitionOrder): [PayloadFieldDefinition] @join__field(graph: SCHEMA)
  payloadFieldsAggregate(filter: PayloadFieldDefinitionFilter): PayloadFieldDefinitionAggregateResult @join__field(graph: SCHEMA)
  payloadProperties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  payloadPropertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  stateEventRuleset(filter: StateEventRulesetFilter): StateEventRuleset @join__field(graph: SCHEMA)
  transitionEventRuleset(filter: TransitionEventRulesetFilter): TransitionEventRuleset @join__field(graph: SCHEMA)
  triggerExpression: String! @join__field(graph: SCHEMA)
  triggerProperties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  triggerPropertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
}

type EventDefinitionAggregateResult {
  count: Int
  delayTimeAvg: Float
  delayTimeMax: Int
  delayTimeMin: Int
  delayTimeSum: Int
  nameMax: String
  nameMin: String
  triggerExpressionMax: String
  triggerExpressionMin: String
}

input EventDefinitionFilter {
  and: [EventDefinitionFilter]
  has: [EventDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: EventDefinitionFilter
  or: [EventDefinitionFilter]
}

enum EventDefinitionHasFilter {
  delayOption
  delayTime
  equipmentClass
  isActive
  materialEventRuleset
  messageClass
  name
  orderStartRuleset
  payloadFields
  payloadProperties
  stateEventRuleset
  transitionEventRuleset
  triggerExpression
  triggerProperties
}

input EventDefinitionOrder {
  asc: EventDefinitionOrderable
  desc: EventDefinitionOrderable
  then: EventDefinitionOrder
}

enum EventDefinitionOrderable {
  delayTime
  name
  triggerExpression
}

input EventDefinitionPatch {
  delayOption: Boolean
  delayTime: Int
  equipmentClass: EquipmentClassRef
  isActive: Boolean
  materialEventRuleset: MaterialEventRulesetRef
  messageClass: MessageClass
  name: String
  orderStartRuleset: OrderStartRulesetRef
  payloadFields: [PayloadFieldDefinitionRef]
  payloadProperties: [PropertyRef]
  stateEventRuleset: StateEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  triggerExpression: String
  triggerProperties: [PropertyRef]
}

input EventDefinitionRef {
  delayOption: Boolean
  delayTime: Int
  equipmentClass: EquipmentClassRef
  id: ID
  isActive: Boolean
  materialEventRuleset: MaterialEventRulesetRef
  messageClass: MessageClass
  name: String
  orderStartRuleset: OrderStartRulesetRef
  payloadFields: [PayloadFieldDefinitionRef]
  payloadProperties: [PropertyRef]
  stateEventRuleset: StateEventRulesetRef
  transitionEventRuleset: TransitionEventRulesetRef
  triggerExpression: String
  triggerProperties: [PropertyRef]
}

type EventLog
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  comments: String @join__field(graph: SCHEMA)
  duration: Float @join__field(graph: SCHEMA)
  endDateTime: DateTime @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobResponse(filter: JobResponseFilter): JobResponse! @join__field(graph: SCHEMA)
  reasonCategoryCode: String @join__field(graph: SCHEMA)
  reasonCode: String @join__field(graph: SCHEMA)
  reasonText: String @join__field(graph: SCHEMA)
  reasonValue: Float @join__field(graph: SCHEMA)
  reasonValueUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
  startDateTime: DateTime @join__field(graph: SCHEMA)
}

type EventLogAggregateResult {
  commentsMax: String
  commentsMin: String
  count: Int
  durationAvg: Float
  durationMax: Float
  durationMin: Float
  durationSum: Float
  endDateTimeMax: DateTime
  endDateTimeMin: DateTime
  reasonCategoryCodeMax: String
  reasonCategoryCodeMin: String
  reasonCodeMax: String
  reasonCodeMin: String
  reasonTextMax: String
  reasonTextMin: String
  reasonValueAvg: Float
  reasonValueMax: Float
  reasonValueMin: Float
  reasonValueSum: Float
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input EventLogFilter {
  and: [EventLogFilter]
  comments: StringHashFilter
  endDateTime: DateTimeFilter
  has: [EventLogHasFilter]
  id: [ID!]
  isActive: Boolean
  not: EventLogFilter
  or: [EventLogFilter]
  reasonCategoryCode: StringHashFilter
  reasonCode: StringHashFilter
  reasonText: StringHashFilter
  startDateTime: DateTimeFilter
}

enum EventLogHasFilter {
  comments
  duration
  endDateTime
  equipment
  isActive
  jobResponse
  reasonCategoryCode
  reasonCode
  reasonText
  reasonValue
  reasonValueUoM
  startDateTime
}

input EventLogOrder {
  asc: EventLogOrderable
  desc: EventLogOrderable
  then: EventLogOrder
}

enum EventLogOrderable {
  comments
  duration
  endDateTime
  reasonCategoryCode
  reasonCode
  reasonText
  reasonValue
  startDateTime
}

input EventLogPatch {
  comments: String
  duration: Float
  endDateTime: DateTime
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  startDateTime: DateTime
}

input EventLogRef {
  comments: String
  duration: Float
  endDateTime: DateTime
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: UnitOfMeasureRef
  startDateTime: DateTime
}

type EventLogTs {
  ISO22400Status: String
  PackMLStatus: String
  comment: String
  equipment: Equipment
  eventTime: DateTime
  previousTime: DateTime
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
}

"""input for splitEventLog or updateEventLog methods"""
input EventLogTsInput {
  comment: String

  """a reference to the equipment the event is on"""
  equipment: ExtEquipmentRef!

  """the start time of the inputted event"""
  eventStartTime: DateTime!
  packMLStatus: String
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
}

"""An event from the eventLog"""
type EventsByField {
  """
  Returns the duration if packML is execute, otherwise returns 0. Useful for visualisation tools
  """
  availability: Int
  comment: String

  """The elapsed time between startDateTime and endDateTime"""
  duration: Int

  """The end of the event"""
  endDateTime: DateTime
  packMLStatus: String
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String

  """The description of the work calendar entry associated with this event"""
  shiftDescription: String
  shiftFinishDateTime: DateTime

  """The id of the work calendar entry associated with this event"""
  shiftId: String
  shiftStartDateTime: DateTime

  """The start of the event"""
  startDateTime: DateTime
}

"""the filter for an eventsByField query"""
input EventsByFieldFilter {
  """
  when used with filterValue, returns all records except those that contain the value
  specified by filterValue in the field specified by this variable
  """
  filterField: String

  """
  when used with filterField, returns all records except those that contain the
  value specified by this variable in the field specified by filterfield
  """
  filterValue: String

  """
  if the the query result would be empty,
  instead return the last result within the last 4 weeks of the start of the query
  """
  findPreviousWhenEmpty: Boolean

  """
  returns all events between this timestamp and the timestamp specified by to.
  If only from is specified, to defaults to the current time
  """
  from: DateTime

  """
  when true, changes the start time of the first response in the event list to be the start of the job response,
  or the filter's from field if the original time is earlier than the modified time
  """
  interpolateAtRangeBoundary: Boolean

  """
  will associate and split events based on work calendar entries when set to true
  """
  provideShiftInformation: Boolean

  """
  records will only return if the field specified by this variable is null
  """
  returnUnassignedField: String

  """
  returns all events between this timestamp and the timestamp specified by from.
  If only from is specified, this value defaults to the current time
  """
  to: DateTime

  """limits the number of results that return"""
  topN: Int
}

"""aggregated information about a group of events"""
type EventSummaryByReason {
  comment: String

  """the number of events in the group"""
  count: Int

  """the total duration of the group of events"""
  durationSum: Int
  iSO22400Status: String
  packMLStatus: String
  reasonCategoryCode: String
  reasonCode: String
  reasonText: String
  reasonValue: Float
  reasonValueUoM: String
}

"""the filter for an eventSummaryByReason query"""
input EventSummaryByReasonFilter {
  """
  if set to true, will only perform grouping and aggregations on events that have
  packmlStatus != execute
  """
  downtimeOnly: Boolean
  from: DateTime

  """
  specifies the field that events will group on. the default value is reasonText
  """
  groupBy: String

  """
  specifies whether the results should be sorted by duration or by count.
  Valid inputs are 'duration' and 'count'
  """
  sortBy: String
  to: DateTime

  """limits the number of results that return"""
  topN: Int
}

input ExtCarrierRef {
  id: ID
}

input ExtDeliveryRef {
  id: ID
}

input ExtEquipmentRef {
  id: ID
  name: String
}

input ExtJobResponseRef {
  id: ID
}

input ExtMaterialDefinitionRef {
  code: String
  id: ID
}

input ExtMaterialLotRef {
  id: ID
}

input ExtMaterialStatusRef {
  code: String
  id: ID
}

input ExtMaterialSubLotRef {
  code: String
  id: ID
}

input ExtPartnerRef {
  id: ID
}

input ExtShipmentItemRef {
  id: ID
}

input ExtShipmentRef {
  id: ID
}

input ExtUnitOfMeasureRef {
  id: ID
}

input ExtUserRef {
  id: ID
  username: String
}

input ExtWorkflowNodeInstanceRef {
  id: String!
}

input ExtWorkflowPropertyRef {
  name: String!
  value: String!
}

input ExtWorkflowSpecificationRef {
  id: String!
}

input FloatFilter {
  between: FloatRange
  eq: Float
  ge: Float
  gt: Float
  in: [Float]
  le: Float
  lt: Float
}

input FloatRange {
  max: Float!
  min: Float!
}

type Form
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jsonSchema: String @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  uiSchema: String @join__field(graph: SCHEMA)
  workflowNodes(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode] @join__field(graph: SCHEMA)
  workflowNodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult @join__field(graph: SCHEMA)
}

type FormAggregateResult {
  count: Int
  jsonSchemaMax: String
  jsonSchemaMin: String
  nameMax: String
  nameMin: String
  uiSchemaMax: String
  uiSchemaMin: String
}

input FormFilter {
  and: [FormFilter]
  has: [FormHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: FormFilter
  or: [FormFilter]
}

enum FormHasFilter {
  isActive
  jsonSchema
  name
  uiSchema
  workflowNodes
}

input FormOrder {
  asc: FormOrderable
  desc: FormOrderable
  then: FormOrder
}

enum FormOrderable {
  jsonSchema
  name
  uiSchema
}

input FormPatch {
  isActive: Boolean
  jsonSchema: String
  name: String
  uiSchema: String
  workflowNodes: [WorkflowNodeRef]
}

input FormRef {
  id: ID
  isActive: Boolean
  jsonSchema: String
  name: String
  uiSchema: String
  workflowNodes: [WorkflowNodeRef]
}

enum Frequency {
  DAILY
  HOURLY
  MINUTELY
  MONTHLY
  SECONDLY
  WEEKLY
  YEARLY
}

type GeneralLedgerAccount {
  code: String!
  id: ID!
  name: String
  type: String
}

type GeneralLedgerAccountAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  nameMax: String
  nameMin: String
  typeMax: String
  typeMin: String
}

input GeneralLedgerAccountFilter {
  and: [GeneralLedgerAccountFilter]
  code: StringHashFilter
  has: [GeneralLedgerAccountHasFilter]
  id: [ID!]
  not: GeneralLedgerAccountFilter
  or: [GeneralLedgerAccountFilter]
}

enum GeneralLedgerAccountHasFilter {
  code
  name
  type
}

input GeneralLedgerAccountOrder {
  asc: GeneralLedgerAccountOrderable
  desc: GeneralLedgerAccountOrderable
  then: GeneralLedgerAccountOrder
}

enum GeneralLedgerAccountOrderable {
  code
  name
  type
}

input GeneralLedgerAccountPatch {
  code: String
  name: String
  type: String
}

input GeneralLedgerAccountRef {
  code: String
  id: ID
  name: String
  type: String
}

input GenerateMutationParams {
  add: Boolean
  delete: Boolean
  update: Boolean
}

input GenerateQueryParams {
  aggregate: Boolean
  get: Boolean
  password: Boolean
  query: Boolean
}

input GetPackingReturnInstructionsPDFInput {
  OrderNumber: String!
  SerialNumbers: [String!]!
}

enum HTTPMethod {
  DELETE
  GET
  PATCH
  POST
  PUT
}

enum IncoTerms {
  CPT
  DAP
  DDP
}

type InputError {
  message: String
}

"""
The Int64 scalar type represents a signed 64bit numeric nonfractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  between: Int64Range
  eq: Int64
  ge: Int64
  gt: Int64
  in: [Int64]
  le: Int64
  lt: Int64
}

input Int64Range {
  max: Int64!
  min: Int64!
}

type InterfaceMessageLog {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  id: ID!
  level: String
  message: String
  payload: String
  status: String
}

type InterfaceMessageLogAggregateResult {
  componentMax: String
  componentMin: String
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  errorMessageMax: String
  errorMessageMin: String
  levelMax: String
  levelMin: String
  messageMax: String
  messageMin: String
  payloadMax: String
  payloadMin: String
  statusMax: String
  statusMin: String
}

input InterfaceMessageLogFilter {
  and: [InterfaceMessageLogFilter]
  component: StringTermFilter
  createdDateTime: DateTimeFilter
  has: [InterfaceMessageLogHasFilter]
  id: [ID!]
  level: StringTermFilter
  message: StringTermFilter
  not: InterfaceMessageLogFilter
  or: [InterfaceMessageLogFilter]
  status: StringTermFilter
}

enum InterfaceMessageLogHasFilter {
  component
  createdDateTime
  errorMessage
  level
  message
  payload
  status
}

input InterfaceMessageLogOrder {
  asc: InterfaceMessageLogOrderable
  desc: InterfaceMessageLogOrderable
  then: InterfaceMessageLogOrder
}

enum InterfaceMessageLogOrderable {
  component
  createdDateTime
  errorMessage
  level
  message
  payload
  status
}

input InterfaceMessageLogPatch {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  level: String
  message: String
  payload: String
  status: String
}

input InterfaceMessageLogRef {
  component: String
  createdDateTime: DateTime
  errorMessage: String
  id: ID
  level: String
  message: String
  payload: String
  status: String
}

input IntersectsFilter {
  multiPolygon: MultiPolygonRef
  polygon: PolygonRef
}

input IntFilter {
  between: IntRange
  eq: Int
  ge: Int
  gt: Int
  in: [Int]
  le: Int
  lt: Int
}

input IntRange {
  max: Int!
  min: Int!
}

type InventoryHandlingPolicy
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  materialClass(filter: MaterialClassFilter, first: Int, offset: Int, order: MaterialClassOrder): [MaterialClass] @join__field(graph: SCHEMA)
  materialClassAggregate(filter: MaterialClassFilter): MaterialClassAggregateResult @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  rules(filter: InventoryHandlingRuleFilter, first: Int, offset: Int): [InventoryHandlingRule] @join__field(graph: SCHEMA)
  rulesAggregate(filter: InventoryHandlingRuleFilter): InventoryHandlingRuleAggregateResult @join__field(graph: SCHEMA)
  trackByCarrier: Boolean @join__field(graph: SCHEMA)
  trackBySerialNumber: Boolean @join__field(graph: SCHEMA)
  verifySerialNumberOnPacking: Boolean @join__field(graph: SCHEMA)
  verifySerialNumberOnReceipt: Boolean @join__field(graph: SCHEMA)
}

type InventoryHandlingPolicyAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input InventoryHandlingPolicyFilter {
  and: [InventoryHandlingPolicyFilter]
  has: [InventoryHandlingPolicyHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: InventoryHandlingPolicyFilter
  or: [InventoryHandlingPolicyFilter]
}

enum InventoryHandlingPolicyHasFilter {
  isActive
  materialClass
  name
  rules
  trackByCarrier
  trackBySerialNumber
  verifySerialNumberOnPacking
  verifySerialNumberOnReceipt
}

input InventoryHandlingPolicyOrder {
  asc: InventoryHandlingPolicyOrderable
  desc: InventoryHandlingPolicyOrderable
  then: InventoryHandlingPolicyOrder
}

enum InventoryHandlingPolicyOrderable {
  name
}

input InventoryHandlingPolicyPatch {
  isActive: Boolean
  materialClass: [MaterialClassRef]
  name: String
  rules: [InventoryHandlingRuleRef]
  trackByCarrier: Boolean
  trackBySerialNumber: Boolean
  verifySerialNumberOnPacking: Boolean
  verifySerialNumberOnReceipt: Boolean
}

input InventoryHandlingPolicyRef {
  id: ID
  isActive: Boolean
  materialClass: [MaterialClassRef]
  name: String
  rules: [InventoryHandlingRuleRef]
  trackByCarrier: Boolean
  trackBySerialNumber: Boolean
  verifySerialNumberOnPacking: Boolean
  verifySerialNumberOnReceipt: Boolean
}

type InventoryHandlingRule
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  customer(filter: PartnerFilter): Partner! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  inventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter): InventoryHandlingPolicy! @join__field(graph: SCHEMA)
  inventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter, first: Int, offset: Int, order: InventoryHoldingPolicyOrder): [InventoryHoldingPolicy] @join__field(graph: SCHEMA)
  inventoryHoldingPolicyAggregate(filter: InventoryHoldingPolicyFilter): InventoryHoldingPolicyAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  stateModel(filter: MaterialStateModelFilter): MaterialStateModel! @join__field(graph: SCHEMA)
  stockType: StockType! @join__field(graph: SCHEMA)
  warehouse(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment!]! @join__field(graph: SCHEMA)
  warehouseAggregate(filter: EquipmentFilter): EquipmentAggregateResult @join__field(graph: SCHEMA)
}

type InventoryHandlingRuleAggregateResult {
  count: Int
}

input InventoryHandlingRuleFilter {
  and: [InventoryHandlingRuleFilter]
  has: [InventoryHandlingRuleHasFilter]
  id: [ID!]
  isActive: Boolean
  not: InventoryHandlingRuleFilter
  or: [InventoryHandlingRuleFilter]
  stockType: StockType_hash
}

enum InventoryHandlingRuleHasFilter {
  customer
  inventoryHandlingPolicy
  inventoryHoldingPolicy
  isActive
  stateModel
  stockType
  warehouse
}

input InventoryHandlingRulePatch {
  customer: PartnerRef
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  stateModel: MaterialStateModelRef
  stockType: StockType
  warehouse: [EquipmentRef!]
}

input InventoryHandlingRuleRef {
  customer: PartnerRef
  id: ID
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  stateModel: MaterialStateModelRef
  stockType: StockType
  warehouse: [EquipmentRef!]
}

"""
The settings used to plan for when more material should be processed or purchased
"""
type InventoryHoldingPolicy
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  inventoryHandlingRule(filter: InventoryHandlingRuleFilter): InventoryHandlingRule! @join__field(graph: SCHEMA)
  inventoryMax: Int @join__field(graph: SCHEMA)
  inventoryMin: Int @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  materialStatus(filter: MaterialStatusFilter): MaterialStatus! @join__field(graph: SCHEMA)
}

type InventoryHoldingPolicyAggregateResult {
  count: Int
  inventoryMaxAvg: Float
  inventoryMaxMax: Int
  inventoryMaxMin: Int
  inventoryMaxSum: Int
  inventoryMinAvg: Float
  inventoryMinMax: Int
  inventoryMinMin: Int
  inventoryMinSum: Int
}

input InventoryHoldingPolicyFilter {
  and: [InventoryHoldingPolicyFilter]
  has: [InventoryHoldingPolicyHasFilter]
  id: [ID!]
  isActive: Boolean
  not: InventoryHoldingPolicyFilter
  or: [InventoryHoldingPolicyFilter]
}

enum InventoryHoldingPolicyHasFilter {
  inventoryHandlingRule
  inventoryMax
  inventoryMin
  isActive
  material
  materialStatus
}

input InventoryHoldingPolicyOrder {
  asc: InventoryHoldingPolicyOrderable
  desc: InventoryHoldingPolicyOrderable
  then: InventoryHoldingPolicyOrder
}

enum InventoryHoldingPolicyOrderable {
  inventoryMax
  inventoryMin
}

input InventoryHoldingPolicyPatch {
  inventoryHandlingRule: InventoryHandlingRuleRef
  inventoryMax: Int
  inventoryMin: Int
  isActive: Boolean
  material: MaterialDefinitionRef
  materialStatus: MaterialStatusRef
}

input InventoryHoldingPolicyRef {
  id: ID
  inventoryHandlingRule: InventoryHandlingRuleRef
  inventoryMax: Int
  inventoryMin: Int
  isActive: Boolean
  material: MaterialDefinitionRef
  materialStatus: MaterialStatusRef
}

type InventoryTransaction {
  carrier: Carrier
  comment: String
  effectiveTimestamp: DateTime
  jobResponse: JobResponse
  material: MaterialDefinition @join__field(graph: WMS, provides: "code")
  materialLot: MaterialLot
  materialSubLot: MaterialSubLot @join__field(graph: WMS, provides: "code")
  materialUse: MaterialUse
  owner: Partner
  quantity: Float!
  reason: String
  shipment: Shipment
  shipmentItem: ShipmentItem
  status: MaterialStatus
  storageLocation: Equipment @join__field(graph: WMS, provides: "name")
  timestamp: DateTime!
  transactionId: String
  user: User
}

input InventoryTransactionInput {
  carrier: ExtCarrierRef
  effectiveDateTime: DateTime
  material: ExtMaterialDefinitionRef
  materialSubLot: ExtMaterialSubLotRef
  materialUse: MaterialUse
  owner: ExtPartnerRef
  quantity: Float
  shipment: ExtShipmentRef
  shipmentItem: ExtShipmentItemRef
  status: ExtMaterialStatusRef
  storageLocation: ExtEquipmentRef
  user: ExtUserRef
}

input InventoryTransactionsRawFilter {
  carrier: ExtCarrierRef
  filterReversed: Boolean
  from: DateTime
  jobResponse: ExtJobResponseRef
  material: ExtMaterialDefinitionRef
  materialSubLot: ExtMaterialSubLotRef
  shipment: ExtShipmentRef
  shipmentItem: ExtShipmentItemRef
  status: ExtMaterialStatusRef
  storageLocation: ExtEquipmentRef
  to: DateTime
  transactionId: String
}

type JobOrder
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
  @join__type(graph: SCHEDULER, key: "id")
  @join__type(graph: WMS, key: "id")
{
  children(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder] @join__field(graph: SCHEMA)
  childrenAggregate(filter: JobOrderFilter): JobOrderAggregateResult @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  dispatchStatus: DispatchStatus @join__field(graph: SCHEMA)
  duration: Float @join__field(graph: SCHEMA)
  durationUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  equipmentSpecifications(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification] @join__field(graph: SCHEMA)
  equipmentSpecificationsAggregate(filter: EquipmentSpecificationFilter): EquipmentSpecificationAggregateResult @join__field(graph: SCHEMA)
  hierarchyScope: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  inflows(filter: JobOrderDependencyFilter, first: Int, offset: Int, order: JobOrderDependencyOrder): [JobOrderDependency] @join__field(graph: SCHEMA)
  inflowsAggregate(filter: JobOrderDependencyFilter): JobOrderDependencyAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrderNotes(filter: JobOrderNoteFilter, first: Int, offset: Int, order: JobOrderNoteOrder): [JobOrderNote] @join__field(graph: SCHEMA)
  jobOrderNotesAggregate(filter: JobOrderNoteFilter): JobOrderNoteAggregateResult @join__field(graph: SCHEMA)
  jobResponses(filter: JobResponseFilter, first: Int, offset: Int, order: JobResponseOrder): [JobResponse] @join__field(graph: SCHEMA)
  jobResponsesAggregate(filter: JobResponseFilter): JobResponseAggregateResult @join__field(graph: SCHEMA)
  lastEvent(filter: LastEventFilter): EventsByField @join__field(graph: CORE, requires: "scheduledStartDateTime")
  materialSpecifications(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification] @join__field(graph: SCHEMA)
  materialSpecificationsAggregate(filter: MaterialSpecificationFilter): MaterialSpecificationAggregateResult @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  next(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder] @join__field(graph: SCHEMA)
  nextAggregate(filter: JobOrderFilter): JobOrderAggregateResult @join__field(graph: SCHEMA)
  operationsRequest(filter: OperationsRequestFilter): OperationsRequest @join__field(graph: SCHEMA)
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment @join__field(graph: SCHEMA)
  outflows(filter: JobOrderDependencyFilter, first: Int, offset: Int, order: JobOrderDependencyOrder): [JobOrderDependency] @join__field(graph: SCHEMA)
  outflowsAggregate(filter: JobOrderDependencyFilter): JobOrderDependencyAggregateResult @join__field(graph: SCHEMA)
  parameterSpecifications(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification] @join__field(graph: SCHEMA)
  parameterSpecificationsAggregate(filter: ParameterSpecificationFilter): ParameterSpecificationAggregateResult @join__field(graph: SCHEMA)
  parent(filter: JobOrderFilter): JobOrder @join__field(graph: SCHEMA)
  personnelSpecifications(filter: PersonnelSpecificationFilter, first: Int, offset: Int, order: PersonnelSpecificationOrder): [PersonnelSpecification] @join__field(graph: SCHEMA)
  personnelSpecificationsAggregate(filter: PersonnelSpecificationFilter): PersonnelSpecificationAggregateResult @join__field(graph: SCHEMA)
  previous(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder] @join__field(graph: SCHEMA)
  previousAggregate(filter: JobOrderFilter): JobOrderAggregateResult @join__field(graph: SCHEMA)
  priority: Int @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  quantity: Float @join__field(graph: SCHEMA)
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
  scheduledDuration: Float @join__field(graph: SCHEMA)
  scheduledEndDateTime: DateTime @join__field(graph: SCHEMA)
  scheduledStartDateTime: DateTime @join__field(graph: SCHEMA)
  version: String @join__field(graph: SCHEMA)
  workDefinitionType: String @join__field(graph: SCHEMA)
  workType: WorkType @join__field(graph: SCHEMA)
}

type JobOrderAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  durationAvg: Float
  durationMax: Float
  durationMin: Float
  durationSum: Float
  hierarchyScopeMax: String
  hierarchyScopeMin: String
  nameMax: String
  nameMin: String
  priorityAvg: Float
  priorityMax: Int
  priorityMin: Int
  prioritySum: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
  scheduledDurationAvg: Float
  scheduledDurationMax: Float
  scheduledDurationMin: Float
  scheduledDurationSum: Float
  scheduledEndDateTimeMax: DateTime
  scheduledEndDateTimeMin: DateTime
  scheduledStartDateTimeMax: DateTime
  scheduledStartDateTimeMin: DateTime
  versionMax: String
  versionMin: String
  workDefinitionTypeMax: String
  workDefinitionTypeMin: String
}

"""
 Defines the planned relationship between JobOrders. The JobOrderDependency is created from a copy
of the SegmentDependency during the production dispatch activity 
"""
type JobOrderDependency {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM(filter: UnitOfMeasureFilter): UnitOfMeasure
  from(filter: JobOrderFilter): JobOrder!
  id: ID!
  isActive: Boolean
  segmentDependency(filter: SegmentDependencyFilter): SegmentDependency
  to(filter: JobOrderFilter): JobOrder!
}

type JobOrderDependencyAggregateResult {
  conditionMax: String
  conditionMin: String
  count: Int
  dependencyFactorAvg: Float
  dependencyFactorMax: Float
  dependencyFactorMin: Float
  dependencyFactorSum: Float
  descriptionMax: String
  descriptionMin: String
}

input JobOrderDependencyFilter {
  and: [JobOrderDependencyFilter]
  has: [JobOrderDependencyHasFilter]
  id: [ID!]
  isActive: Boolean
  not: JobOrderDependencyFilter
  or: [JobOrderDependencyFilter]
}

enum JobOrderDependencyHasFilter {
  condition
  dependencyFactor
  dependencyType
  description
  factorUoM
  from
  isActive
  segmentDependency
  to
}

input JobOrderDependencyOrder {
  asc: JobOrderDependencyOrderable
  desc: JobOrderDependencyOrderable
  then: JobOrderDependencyOrder
}

enum JobOrderDependencyOrderable {
  condition
  dependencyFactor
  description
}

input JobOrderDependencyPatch {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: JobOrderRef
  isActive: Boolean
  segmentDependency: SegmentDependencyRef
  to: JobOrderRef
}

input JobOrderDependencyRef {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: JobOrderRef
  id: ID
  isActive: Boolean
  segmentDependency: SegmentDependencyRef
  to: JobOrderRef
}

""" Define the allowable DispatchStatus transitions for JobOrder.dispatchStatus
"""
type JobOrderDispatchStateModel {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus!
}

type JobOrderDispatchStateModelAggregateResult {
  count: Int
}

input JobOrderDispatchStateModelFilter {
  and: [JobOrderDispatchStateModelFilter]
  has: [JobOrderDispatchStateModelHasFilter]
  not: JobOrderDispatchStateModelFilter
  or: [JobOrderDispatchStateModelFilter]
}

enum JobOrderDispatchStateModelHasFilter {
  allowedTransition
  fromStatus
}

input JobOrderDispatchStateModelPatch {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus
}

input JobOrderDispatchStateModelRef {
  allowedTransition: [DispatchStatus]
  fromStatus: DispatchStatus
}

input JobOrderFilter {
  and: [JobOrderFilter]
  createdDateTime: DateTimeFilter
  description: StringHashFilter
  dispatchStatus: DispatchStatus_hash
  has: [JobOrderHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter_StringRegExpFilter
  not: JobOrderFilter
  or: [JobOrderFilter]
  scheduledEndDateTime: DateTimeFilter
  scheduledStartDateTime: DateTimeFilter
  workDefinitionType: StringHashFilter
  workType: WorkType_hash
}

enum JobOrderHasFilter {
  children
  createdDateTime
  description
  dispatchStatus
  duration
  durationUoM
  equipment
  equipmentSpecifications
  hierarchyScope
  inflows
  isActive
  jobOrderNotes
  jobResponses
  materialSpecifications
  name
  next
  operationsRequest
  operationsSegment
  outflows
  parameterSpecifications
  parent
  personnelSpecifications
  previous
  priority
  properties
  quantity
  quantityUoM
  scheduledDuration
  scheduledEndDateTime
  scheduledStartDateTime
  version
  workDefinitionType
  workType
}

type JobOrderNote {
  comment: String
  createdBy(filter: UserFilter): User
  createdDateTime: DateTime
  editedDateTime: DateTime
  id: ID!
  isActive: Boolean
  jobOrder(filter: JobOrderFilter): JobOrder
  modifiedBy(filter: UserFilter): User
}

type JobOrderNoteAggregateResult {
  commentMax: String
  commentMin: String
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  editedDateTimeMax: DateTime
  editedDateTimeMin: DateTime
}

input JobOrderNoteFilter {
  and: [JobOrderNoteFilter]
  has: [JobOrderNoteHasFilter]
  id: [ID!]
  not: JobOrderNoteFilter
  or: [JobOrderNoteFilter]
}

enum JobOrderNoteHasFilter {
  comment
  createdBy
  createdDateTime
  editedDateTime
  isActive
  jobOrder
  modifiedBy
}

input JobOrderNoteOrder {
  asc: JobOrderNoteOrderable
  desc: JobOrderNoteOrderable
  then: JobOrderNoteOrder
}

enum JobOrderNoteOrderable {
  comment
  createdDateTime
  editedDateTime
}

input JobOrderNotePatch {
  comment: String
  createdBy: UserRef
  createdDateTime: DateTime
  editedDateTime: DateTime
  isActive: Boolean
  jobOrder: JobOrderRef
  modifiedBy: UserRef
}

input JobOrderNoteRef {
  comment: String
  createdBy: UserRef
  createdDateTime: DateTime
  editedDateTime: DateTime
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  modifiedBy: UserRef
}

input JobOrderOrder {
  asc: JobOrderOrderable
  desc: JobOrderOrderable
  then: JobOrderOrder
}

enum JobOrderOrderable {
  createdDateTime
  description
  duration
  hierarchyScope
  name
  priority
  quantity
  scheduledDuration
  scheduledEndDateTime
  scheduledStartDateTime
  version
  workDefinitionType
}

input JobOrderPatch {
  children: [JobOrderRef]
  createdDateTime: DateTime
  description: String
  dispatchStatus: DispatchStatus
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipment: EquipmentRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  hierarchyScope: String
  inflows: [JobOrderDependencyRef]
  isActive: Boolean
  jobOrderNotes: [JobOrderNoteRef]
  jobResponses: [JobResponseRef]
  materialSpecifications: [MaterialSpecificationRef]
  name: String
  next: [JobOrderRef]
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  outflows: [JobOrderDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: JobOrderRef
  personnelSpecifications: [PersonnelSpecificationRef]
  previous: [JobOrderRef]
  priority: Int
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  scheduledDuration: Float
  scheduledEndDateTime: DateTime
  scheduledStartDateTime: DateTime
  version: String
  workDefinitionType: String
  workType: WorkType
}

input JobOrderRef {
  children: [JobOrderRef]
  createdDateTime: DateTime
  description: String
  dispatchStatus: DispatchStatus
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipment: EquipmentRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  hierarchyScope: String
  id: ID
  inflows: [JobOrderDependencyRef]
  isActive: Boolean
  jobOrderNotes: [JobOrderNoteRef]
  jobResponses: [JobResponseRef]
  materialSpecifications: [MaterialSpecificationRef]
  name: String
  next: [JobOrderRef]
  operationsRequest: OperationsRequestRef
  operationsSegment: OperationsSegmentRef
  outflows: [JobOrderDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: JobOrderRef
  personnelSpecifications: [PersonnelSpecificationRef]
  previous: [JobOrderRef]
  priority: Int
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  scheduledDuration: Float
  scheduledEndDateTime: DateTime
  scheduledStartDateTime: DateTime
  version: String
  workDefinitionType: String
  workType: WorkType
}

type JobOrderStaging {
  equipment: String
  errList: [String]
  isValid: Boolean
  operationsRequest: String
  orderNo: String
  segment: String
}

input JobOrderStagingInput {
  operationsRequest: String!
  orderNo: String!
  segment: String!
}

input JobOrderStatusPatch {
  dispatchStatus: DispatchStatus
}

type JobResponse
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
  @join__type(graph: WMS, key: "id")
{
  actualDuration: Float @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  duration: Float @join__field(graph: CORE, requires: "startDateTime endDateTime")
  endDateTime: DateTime @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  equipmentActual(filter: EquipmentActualFilter, first: Int, offset: Int, order: EquipmentActualOrder): [EquipmentActual] @join__field(graph: SCHEMA)
  equipmentActualAggregate(filter: EquipmentActualFilter): EquipmentActualAggregateResult @join__field(graph: SCHEMA)

  """deprecated"""
  eventList: [EventLog] @join__field(graph: CORE)
  eventSummaryByReason(filter: EventSummaryByReasonFilter): [EventSummaryByReason] @join__field(graph: CORE, requires: "startDateTime endDateTime")
  events(filter: EventLogFilter, first: Int, offset: Int, order: EventLogOrder): [EventLog] @join__field(graph: SCHEMA)
  eventsAggregate(filter: EventLogFilter): EventLogAggregateResult @join__field(graph: SCHEMA)
  eventsByField(filter: EventsByFieldFilter): [EventsByField] @join__field(graph: CORE, requires: "startDateTime endDateTime")
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrder(filter: JobOrderFilter): JobOrder @join__field(graph: SCHEMA)
  maintenanceCalls: [MaintenanceLog] @join__field(graph: CORE, requires: "startDateTime endDateTime")
  materialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual] @join__field(graph: SCHEMA)
  materialActualAggregate(filter: MaterialActualFilter): MaterialActualAggregateResult @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  operator(filter: UserFilter): User @join__field(graph: SCHEMA)
  personnelActual(filter: PersonnelActualFilter, first: Int, offset: Int, order: PersonnelActualOrder): [PersonnelActual] @join__field(graph: SCHEMA)
  personnelActualAggregate(filter: PersonnelActualFilter): PersonnelActualAggregateResult @join__field(graph: SCHEMA)
  productionDate: String @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  quantities(filter: QuantityLogFilter, first: Int, offset: Int, order: QuantityLogOrder): [QuantityLog] @join__field(graph: SCHEMA)
  quantitiesAggregate(filter: QuantityLogFilter): QuantityLogAggregateResult @join__field(graph: SCHEMA)
  quantitySummary(filter: QuantitySummaryFilter): [QuantitySummary] @join__field(graph: CORE, requires: "startDateTime endDateTime")
  runRateSummary(filter: RunRateFilter): RunRateSummary @join__field(graph: CORE, requires: "startDateTime endDateTime")
  startDateTime: DateTime @join__field(graph: SCHEMA)
}

type JobResponseAggregateResult {
  actualDurationAvg: Float
  actualDurationMax: Float
  actualDurationMin: Float
  actualDurationSum: Float
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  endDateTimeMax: DateTime
  endDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  productionDateMax: String
  productionDateMin: String
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input JobResponseFilter {
  and: [JobResponseFilter]
  endDateTime: DateTimeFilter
  has: [JobResponseHasFilter]
  id: [ID!]
  isActive: Boolean
  not: JobResponseFilter
  or: [JobResponseFilter]
  productionDate: StringHashFilter
  startDateTime: DateTimeFilter
}

enum JobResponseHasFilter {
  actualDuration
  createdDateTime
  endDateTime
  equipment
  equipmentActual
  events
  isActive
  jobOrder
  materialActual
  modifiedDateTime
  operator
  personnelActual
  productionDate
  properties
  quantities
  startDateTime
}

input JobResponseOrder {
  asc: JobResponseOrderable
  desc: JobResponseOrderable
  then: JobResponseOrder
}

enum JobResponseOrderable {
  actualDuration
  createdDateTime
  endDateTime
  modifiedDateTime
  productionDate
  startDateTime
}

input JobResponsePatch {
  actualDuration: Float
  createdDateTime: DateTime
  endDateTime: DateTime
  equipment: EquipmentRef
  equipmentActual: [EquipmentActualRef]
  events: [EventLogRef]
  isActive: Boolean
  jobOrder: JobOrderRef
  materialActual: [MaterialActualRef]
  modifiedDateTime: DateTime
  operator: UserRef
  personnelActual: [PersonnelActualRef]
  productionDate: String
  properties: [PropertyRef]
  quantities: [QuantityLogRef]
  startDateTime: DateTime
}

input JobResponseRef {
  actualDuration: Float
  createdDateTime: DateTime
  endDateTime: DateTime
  equipment: EquipmentRef
  equipmentActual: [EquipmentActualRef]
  events: [EventLogRef]
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  materialActual: [MaterialActualRef]
  modifiedDateTime: DateTime
  operator: UserRef
  personnelActual: [PersonnelActualRef]
  productionDate: String
  properties: [PropertyRef]
  quantities: [QuantityLogRef]
  startDateTime: DateTime
}

scalar join__FieldSet

enum join__Graph {
  CORE @join__graph(name: "core" url: "http://localhost:4002/query")
  SCHEDULER @join__graph(name: "scheduler" url: "http://localhost:10001/query")
  SCHEMA @join__graph(name: "schema" url: "http://localhost:8087/graphql")
  WMS @join__graph(name: "wms" url: "http://localhost:7001/query")
}

type Kpi {
  OEE: Float
  OEEUnit: String
  availability: Float
  availabilityUnit: String
  effectiveness: Float
  effectivenessUnit: String
  equipment: Equipment
  quality: Float
  qualityUnit: String
  rawData: RawKpi
}

type KpiByWorkCalendarEntry {
  OEE: Float
  OEEUnit: String
  availability: Float
  availabilityUnit: String
  effectiveness: Float
  effectivenessUnit: String
  equipment: Equipment
  quality: Float
  qualityUnit: String
  rawData: RawKpi
  workCalendarEntry: WorkCalendarEntry
}

input LastEventFilter {
  includeField: String
  includeValue: String
}

"""
Store the heartbeat timestamps of connected libre-services.
microservices can subscribe to this entity to check the status of their subscription
"""
type LibreService
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  heartbeat: DateTime @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
}

type LibreServiceAggregateResult {
  count: Int
  heartbeatMax: DateTime
  heartbeatMin: DateTime
  nameMax: String
  nameMin: String
}

input LibreServiceFilter {
  and: [LibreServiceFilter]
  has: [LibreServiceHasFilter]
  id: [ID!]
  name: StringHashFilter
  not: LibreServiceFilter
  or: [LibreServiceFilter]
}

enum LibreServiceHasFilter {
  heartbeat
  name
}

input LibreServiceOrder {
  asc: LibreServiceOrderable
  desc: LibreServiceOrderable
  then: LibreServiceOrder
}

enum LibreServiceOrderable {
  heartbeat
  name
}

input LibreServicePatch {
  heartbeat: DateTime
  name: String
}

input LibreServiceRef {
  heartbeat: DateTime
  id: ID
  name: String
}

enum MachineState {
  Aborted
  Aborting
  Clearing
  Complete
  Completing
  Execute
  Held
  Holding
  Idle
  Resetting
  Starting
  Stopped
  Stopping
  Suspended
  Suspending
  Unholding
  Unsuspending
}

"""An event from the maintenanceLog"""
type MaintenanceLog {
  comment: String
  priority: String
  requestType: String
  state: String
  time: DateTime
  type: String
  workflowInstanceID: String
}

type MaterialActual
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobResponse(filter: JobResponseFilter): JobResponse! @join__field(graph: SCHEMA)
  materialDefinition(filter: MaterialDefinitionFilter): MaterialDefinition @join__field(graph: SCHEMA)
  materialLot(filter: MaterialLotFilter): MaterialLot @join__field(graph: SCHEMA)
  materialSubLot(filter: MaterialSubLotFilter): MaterialSubLot @join__field(graph: SCHEMA)
  materialUse: MaterialUse @join__field(graph: SCHEMA)
  quantity: Float @join__field(graph: SCHEMA)
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type MaterialActualAggregateResult {
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input MaterialActualFilter {
  and: [MaterialActualFilter]
  has: [MaterialActualHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialActualFilter
  or: [MaterialActualFilter]
}

enum MaterialActualHasFilter {
  isActive
  jobResponse
  materialDefinition
  materialLot
  materialSubLot
  materialUse
  quantity
  quantityUoM
}

input MaterialActualOrder {
  asc: MaterialActualOrderable
  desc: MaterialActualOrderable
  then: MaterialActualOrder
}

enum MaterialActualOrderable {
  quantity
}

input MaterialActualPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input MaterialActualRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  materialDefinition: MaterialDefinitionRef
  materialLot: MaterialLotRef
  materialSubLot: MaterialSubLotRef
  materialUse: MaterialUse
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

type MaterialAlternate
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  alternateMaterial(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  effectiveDateTime: DateTime! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  priorityOrder: Int! @join__field(graph: SCHEMA)
}

type MaterialAlternateAggregateResult {
  count: Int
  effectiveDateTimeMax: DateTime
  effectiveDateTimeMin: DateTime
  priorityOrderAvg: Float
  priorityOrderMax: Int
  priorityOrderMin: Int
  priorityOrderSum: Int
}

input MaterialAlternateFilter {
  and: [MaterialAlternateFilter]
  has: [MaterialAlternateHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialAlternateFilter
  or: [MaterialAlternateFilter]
}

enum MaterialAlternateHasFilter {
  alternateMaterial
  effectiveDateTime
  isActive
  material
  priorityOrder
}

input MaterialAlternateOrder {
  asc: MaterialAlternateOrderable
  desc: MaterialAlternateOrderable
  then: MaterialAlternateOrder
}

enum MaterialAlternateOrderable {
  effectiveDateTime
  priorityOrder
}

input MaterialAlternatePatch {
  alternateMaterial: MaterialDefinitionRef
  effectiveDateTime: DateTime
  isActive: Boolean
  material: MaterialDefinitionRef
  priorityOrder: Int
}

input MaterialAlternateRef {
  alternateMaterial: MaterialDefinitionRef
  effectiveDateTime: DateTime
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  priorityOrder: Int
}

"""
A unique identification of a specific material class, within the scope
of the information exchanged (production capability, production
schedule, production performance, )
The ID shall be used in other parts of the model when the material
class needs to be identified, such as the production capability for
this material class, or a production response identifying the
material class used.
"""
type MaterialClass
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  children(filter: MaterialClassFilter, first: Int, offset: Int, order: MaterialClassOrder): [MaterialClass] @join__field(graph: SCHEMA)
  childrenAggregate(filter: MaterialClassFilter): MaterialClassAggregateResult @join__field(graph: SCHEMA)
  code: String! @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  inventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter): InventoryHandlingPolicy @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  parent(filter: MaterialClassFilter): MaterialClass @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  scheduleSortOrder: Int @join__field(graph: SCHEMA)
}

type MaterialClassAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  scheduleSortOrderAvg: Float
  scheduleSortOrderMax: Int
  scheduleSortOrderMin: Int
  scheduleSortOrderSum: Int
}

input MaterialClassFilter {
  and: [MaterialClassFilter]
  code: StringHashFilter
  has: [MaterialClassHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialClassFilter
  or: [MaterialClassFilter]
}

enum MaterialClassHasFilter {
  children
  code
  description
  inventoryHandlingPolicy
  isActive
  parent
  properties
  scheduleSortOrder
}

input MaterialClassOrder {
  asc: MaterialClassOrderable
  desc: MaterialClassOrderable
  then: MaterialClassOrder
}

enum MaterialClassOrderable {
  code
  description
  scheduleSortOrder
}

input MaterialClassPatch {
  children: [MaterialClassRef]
  code: String
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  isActive: Boolean
  parent: MaterialClassRef
  properties: [PropertyRef]
  scheduleSortOrder: Int
}

input MaterialClassRef {
  children: [MaterialClassRef]
  code: String
  description: String
  id: ID
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  isActive: Boolean
  parent: MaterialClassRef
  properties: [PropertyRef]
  scheduleSortOrder: Int
}

type MaterialDefinition
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
  @join__type(graph: WMS, key: "id")
{
  OrderLines(filter: OrderLineFilter, first: Int, offset: Int, order: OrderLineOrder): [OrderLine] @join__field(graph: SCHEMA)
  OrderLinesAggregate(filter: OrderLineFilter): OrderLineAggregateResult @join__field(graph: SCHEMA)
  alternates(filter: MaterialAlternateFilter, first: Int, offset: Int, order: MaterialAlternateOrder): [MaterialAlternate] @join__field(graph: SCHEMA)
  alternatesAggregate(filter: MaterialAlternateFilter): MaterialAlternateAggregateResult @join__field(graph: SCHEMA)
  baseUnitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure! @join__field(graph: SCHEMA)
  code: String! @join__field(graph: SCHEMA)
  customerMaterialCode: String @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  inventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter): InventoryHandlingPolicy @join__field(graph: SCHEMA)
  inventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter, first: Int, offset: Int, order: InventoryHoldingPolicyOrder): [InventoryHoldingPolicy] @join__field(graph: SCHEMA)
  inventoryHoldingPolicyAggregate(filter: InventoryHoldingPolicyFilter): InventoryHoldingPolicyAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  lots(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot] @join__field(graph: SCHEMA)
  lotsAggregate(filter: MaterialLotFilter): MaterialLotAggregateResult @join__field(graph: SCHEMA)
  materialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual] @join__field(graph: SCHEMA)
  materialActualAggregate(filter: MaterialActualFilter): MaterialActualAggregateResult @join__field(graph: SCHEMA)
  materialClass(filter: MaterialClassFilter): MaterialClass @join__field(graph: SCHEMA)
  materialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment] @join__field(graph: WMS)
  name: String @join__field(graph: SCHEMA)
  operationsDefinitions(filter: OperationsDefinitionFilter, first: Int, offset: Int, order: OperationsDefinitionOrder): [OperationsDefinition] @join__field(graph: SCHEMA)
  operationsDefinitionsAggregate(filter: OperationsDefinitionFilter): OperationsDefinitionAggregateResult @join__field(graph: SCHEMA)
  parameterSpecifications(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification] @join__field(graph: SCHEMA)
  parameterSpecificationsAggregate(filter: ParameterSpecificationFilter): ParameterSpecificationAggregateResult @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  scheduleSortOrder: Int @join__field(graph: SCHEMA)
  serialMask: String @join__field(graph: SCHEMA)
  shipmentItems(filter: ShipmentItemFilter, first: Int, offset: Int, order: ShipmentItemOrder): [ShipmentItem] @join__field(graph: SCHEMA)
  shipmentItemsAggregate(filter: ShipmentItemFilter): ShipmentItemAggregateResult @join__field(graph: SCHEMA)
  sublots(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  sublotsAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  supplier: String @join__field(graph: SCHEMA)
  transferrableMaterials(filter: MaterialDefinitionFilter, first: Int, offset: Int, order: MaterialDefinitionOrder): [MaterialDefinition] @join__field(graph: SCHEMA)
  transferrableMaterialsAggregate(filter: MaterialDefinitionFilter): MaterialDefinitionAggregateResult @join__field(graph: SCHEMA)
  units(filter: MaterialUnitFilter, first: Int, offset: Int, order: MaterialUnitOrder): [MaterialUnit] @join__field(graph: SCHEMA)
  unitsAggregate(filter: MaterialUnitFilter): MaterialUnitAggregateResult @join__field(graph: SCHEMA)
  uomConversions(filter: UnitOfMeasureConversionFilter, first: Int, offset: Int, order: UnitOfMeasureConversionOrder): [UnitOfMeasureConversion] @join__field(graph: SCHEMA)
  uomConversionsAggregate(filter: UnitOfMeasureConversionFilter): UnitOfMeasureConversionAggregateResult @join__field(graph: SCHEMA)
  value: Float @join__field(graph: SCHEMA)
  valueCurrency: String @join__field(graph: SCHEMA)
  weightKG: Float @join__field(graph: SCHEMA)
  workSpecifications(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification] @join__field(graph: SCHEMA)
  workSpecificationsAggregate(filter: MaterialSpecificationFilter): MaterialSpecificationAggregateResult @join__field(graph: SCHEMA)
}

type MaterialDefinitionAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  customerMaterialCodeMax: String
  customerMaterialCodeMin: String
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
  scheduleSortOrderAvg: Float
  scheduleSortOrderMax: Int
  scheduleSortOrderMin: Int
  scheduleSortOrderSum: Int
  serialMaskMax: String
  serialMaskMin: String
  supplierMax: String
  supplierMin: String
  valueAvg: Float
  valueCurrencyMax: String
  valueCurrencyMin: String
  valueMax: Float
  valueMin: Float
  valueSum: Float
  weightKGAvg: Float
  weightKGMax: Float
  weightKGMin: Float
  weightKGSum: Float
}

input MaterialDefinitionFilter {
  and: [MaterialDefinitionFilter]
  code: StringHashFilter
  customerMaterialCode: StringHashFilter
  has: [MaterialDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: MaterialDefinitionFilter
  or: [MaterialDefinitionFilter]
}

enum MaterialDefinitionHasFilter {
  OrderLines
  alternates
  baseUnitOfMeasure
  code
  customerMaterialCode
  description
  inventoryHandlingPolicy
  inventoryHoldingPolicy
  isActive
  lots
  materialActual
  materialClass
  name
  operationsDefinitions
  parameterSpecifications
  properties
  scheduleSortOrder
  serialMask
  shipmentItems
  sublots
  supplier
  transferrableMaterials
  units
  uomConversions
  value
  valueCurrency
  weightKG
  workSpecifications
}

input MaterialDefinitionOrder {
  asc: MaterialDefinitionOrderable
  desc: MaterialDefinitionOrderable
  then: MaterialDefinitionOrder
}

enum MaterialDefinitionOrderable {
  code
  customerMaterialCode
  description
  name
  scheduleSortOrder
  serialMask
  supplier
  value
  valueCurrency
  weightKG
}

input MaterialDefinitionPatch {
  OrderLines: [OrderLineRef]
  alternates: [MaterialAlternateRef]
  baseUnitOfMeasure: UnitOfMeasureRef
  code: String
  customerMaterialCode: String
  description: String
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  lots: [MaterialLotRef]
  materialActual: [MaterialActualRef]
  materialClass: MaterialClassRef
  name: String
  operationsDefinitions: [OperationsDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
  properties: [PropertyRef]
  scheduleSortOrder: Int
  serialMask: String
  shipmentItems: [ShipmentItemRef]
  sublots: [MaterialSubLotRef]
  supplier: String
  transferrableMaterials: [MaterialDefinitionRef]
  units: [MaterialUnitRef]
  uomConversions: [UnitOfMeasureConversionRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  workSpecifications: [MaterialSpecificationRef]
}

input MaterialDefinitionRef {
  OrderLines: [OrderLineRef]
  alternates: [MaterialAlternateRef]
  baseUnitOfMeasure: UnitOfMeasureRef
  code: String
  customerMaterialCode: String
  description: String
  id: ID
  inventoryHandlingPolicy: InventoryHandlingPolicyRef
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
  lots: [MaterialLotRef]
  materialActual: [MaterialActualRef]
  materialClass: MaterialClassRef
  name: String
  operationsDefinitions: [OperationsDefinitionRef]
  parameterSpecifications: [ParameterSpecificationRef]
  properties: [PropertyRef]
  scheduleSortOrder: Int
  serialMask: String
  shipmentItems: [ShipmentItemRef]
  sublots: [MaterialSubLotRef]
  supplier: String
  transferrableMaterials: [MaterialDefinitionRef]
  units: [MaterialUnitRef]
  uomConversions: [UnitOfMeasureConversionRef]
  value: Float
  valueCurrency: String
  weightKG: Float
  workSpecifications: [MaterialSpecificationRef]
}

type MaterialEquipment {
  equipment: Equipment
  material: MaterialDefinition
  planningSummaryByState(filter: StateFilter): [MaterialEquipmentState]
}

input MaterialEquipmentFilter {
  equipmentID: [String]
  materialID: [String]
  siteID: [String]
}

type MaterialEquipmentState {
  inventoryMax: Int
  inventoryMin: Int
  planQty: Float
  productionOrderQuantity: Float
  saleOrderQty: Float
  state: MaterialStateTransitionAttributes
  stockOnHand: Float
}

type MaterialEventRuleset {
  eventDefs(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition]
  eventDefsAggregate(filter: EventDefinitionFilter): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segment(filter: OperationsSegmentFilter): OperationsSegment
  targetMaterial: String!
  targetMaterialOp: String!
  triggerWhen: [RulesetTriggerOption]
}

type MaterialEventRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  targetMaterialMax: String
  targetMaterialMin: String
  targetMaterialOpMax: String
  targetMaterialOpMin: String
}

input MaterialEventRulesetFilter {
  and: [MaterialEventRulesetFilter]
  has: [MaterialEventRulesetHasFilter]
  id: [ID!]
  not: MaterialEventRulesetFilter
  or: [MaterialEventRulesetFilter]
}

enum MaterialEventRulesetHasFilter {
  eventDefs
  name
  segment
  targetMaterial
  targetMaterialOp
  triggerWhen
}

input MaterialEventRulesetOrder {
  asc: MaterialEventRulesetOrderable
  desc: MaterialEventRulesetOrderable
  then: MaterialEventRulesetOrder
}

enum MaterialEventRulesetOrderable {
  name
  targetMaterial
  targetMaterialOp
}

input MaterialEventRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segment: OperationsSegmentRef
  targetMaterial: String
  targetMaterialOp: String
  triggerWhen: [RulesetTriggerOption]
}

input MaterialEventRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segment: OperationsSegmentRef
  targetMaterial: String
  targetMaterialOp: String
  triggerWhen: [RulesetTriggerOption]
}

"""
A uniquely identified specific amount of material, either countable or weighable shall be presented as a material lot.
A material lot describes the planned or actual total quantity or amount of material available, its current state
and its specific property values.
ref-IEC62264-2 5.4.6
"""
type MaterialLot
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  childSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  childSubLotAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  code: String! @join__field(graph: SCHEMA)
  dataType: DataType @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isAssembledFromLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot] @join__field(graph: SCHEMA)
  isAssembledFromLotAggregate(filter: MaterialLotFilter): MaterialLotAggregateResult @join__field(graph: SCHEMA)
  isAssembledFromSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  isAssembledFromSubLotAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  isComponentOfLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot] @join__field(graph: SCHEMA)
  isComponentOfLotAggregate(filter: MaterialLotFilter): MaterialLotAggregateResult @join__field(graph: SCHEMA)
  isComponentOfSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  isComponentOfSubLotAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  materialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual] @join__field(graph: SCHEMA)
  materialActualAggregate(filter: MaterialActualFilter): MaterialActualAggregateResult @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  quantity: String @join__field(graph: SCHEMA)
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type MaterialLotAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityMax: String
  quantityMin: String
}

input MaterialLotFilter {
  and: [MaterialLotFilter]
  code: StringHashFilter
  has: [MaterialLotHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialLotFilter
  or: [MaterialLotFilter]
}

enum MaterialLotHasFilter {
  childSubLot
  code
  dataType
  description
  isActive
  isAssembledFromLot
  isAssembledFromSubLot
  isComponentOfLot
  isComponentOfSubLot
  material
  materialActual
  properties
  quantity
  unitOfMeasure
}

input MaterialLotOrder {
  asc: MaterialLotOrderable
  desc: MaterialLotOrderable
  then: MaterialLotOrder
}

enum MaterialLotOrderable {
  code
  description
  quantity
}

input MaterialLotPatch {
  childSubLot: [MaterialSubLotRef]
  code: String
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  properties: [PropertyRef]
  quantity: String
  unitOfMeasure: UnitOfMeasureRef
}

input MaterialLotRef {
  childSubLot: [MaterialSubLotRef]
  code: String
  dataType: DataType
  description: String
  id: ID
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  properties: [PropertyRef]
  quantity: String
  unitOfMeasure: UnitOfMeasureRef
}

input MaterialQuantityMovement {
  materialDefinition: ExtMaterialDefinitionRef!
  quantity: Float!
}

type MaterialSpecification
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  allowedStates(filter: MaterialStatusFilter, first: Int, offset: Int, order: MaterialStatusOrder): [MaterialStatus] @join__field(graph: SCHEMA)
  allowedStatesAggregate(filter: MaterialStatusFilter): MaterialStatusAggregateResult @join__field(graph: SCHEMA)
  backFlushFromLocation(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  billOfMaterial(filter: BillOfMaterialFilter): BillOfMaterial @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isBackFlushed: Boolean @join__field(graph: SCHEMA)
  isTracked: Boolean @join__field(graph: SCHEMA)
  jobOrder(filter: JobOrderFilter): JobOrder @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition @join__field(graph: SCHEMA)
  materialClass(filter: MaterialClassFilter): MaterialClass @join__field(graph: SCHEMA)
  materialUse: MaterialUse! @join__field(graph: SCHEMA)
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment @join__field(graph: SCHEMA)
  quantity: Float @join__field(graph: SCHEMA)
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type MaterialSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input MaterialSpecificationFilter {
  and: [MaterialSpecificationFilter]
  has: [MaterialSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  isBackFlushed: Boolean
  materialUse: MaterialUse_hash
  not: MaterialSpecificationFilter
  or: [MaterialSpecificationFilter]
}

enum MaterialSpecificationHasFilter {
  allowedStates
  backFlushFromLocation
  billOfMaterial
  description
  isActive
  isBackFlushed
  isTracked
  jobOrder
  material
  materialClass
  materialUse
  operationsSegment
  quantity
  uom
}

input MaterialSpecificationOrder {
  asc: MaterialSpecificationOrderable
  desc: MaterialSpecificationOrderable
  then: MaterialSpecificationOrder
}

enum MaterialSpecificationOrderable {
  description
  quantity
}

input MaterialSpecificationPatch {
  allowedStates: [MaterialStatusRef]
  backFlushFromLocation: EquipmentRef
  billOfMaterial: BillOfMaterialRef
  description: String
  isActive: Boolean
  isBackFlushed: Boolean
  isTracked: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  materialUse: MaterialUse
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

input MaterialSpecificationRef {
  allowedStates: [MaterialStatusRef]
  backFlushFromLocation: EquipmentRef
  billOfMaterial: BillOfMaterialRef
  description: String
  id: ID
  isActive: Boolean
  isBackFlushed: Boolean
  isTracked: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  materialClass: MaterialClassRef
  materialUse: MaterialUse
  operationsSegment: OperationsSegmentRef
  quantity: Float
  uom: UnitOfMeasureRef
}

type MaterialStateModel
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  inventoryHandlingRules(filter: InventoryHandlingRuleFilter, first: Int, offset: Int): [InventoryHandlingRule] @join__field(graph: SCHEMA)
  inventoryHandlingRulesAggregate(filter: InventoryHandlingRuleFilter): InventoryHandlingRuleAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  states(filter: MaterialStateTransitionFilter, first: Int, offset: Int): [MaterialStateTransition!]! @join__field(graph: SCHEMA)
  statesAggregate(filter: MaterialStateTransitionFilter): MaterialStateTransitionAggregateResult @join__field(graph: SCHEMA)
}

type MaterialStateModelAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input MaterialStateModelFilter {
  and: [MaterialStateModelFilter]
  has: [MaterialStateModelHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: MaterialStateModelFilter
  or: [MaterialStateModelFilter]
}

enum MaterialStateModelHasFilter {
  inventoryHandlingRules
  isActive
  name
  states
}

input MaterialStateModelOrder {
  asc: MaterialStateModelOrderable
  desc: MaterialStateModelOrderable
  then: MaterialStateModelOrder
}

enum MaterialStateModelOrderable {
  name
}

input MaterialStateModelPatch {
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  name: String
  states: [MaterialStateTransitionRef!]
}

input MaterialStateModelRef {
  id: ID
  inventoryHandlingRules: [InventoryHandlingRuleRef]
  isActive: Boolean
  name: String
  states: [MaterialStateTransitionRef!]
}

type MaterialStateTransition
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  canPack: Boolean @join__field(graph: SCHEMA)
  canReceive: Boolean @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isPlanned: Boolean @join__field(graph: SCHEMA)
  status(filter: MaterialStatusFilter): MaterialStatus! @join__field(graph: SCHEMA)
  to(filter: MaterialStatusFilter, first: Int, offset: Int, order: MaterialStatusOrder): [MaterialStatus] @join__field(graph: SCHEMA)
  toAggregate(filter: MaterialStatusFilter): MaterialStatusAggregateResult @join__field(graph: SCHEMA)
}

type MaterialStateTransitionAggregateResult {
  count: Int
}

type MaterialStateTransitionAttributes {
  canPack: Boolean
  canReceive: Boolean
  id: ID!
  isPlanned: Boolean
  status: MaterialStatus
}

input MaterialStateTransitionFilter {
  and: [MaterialStateTransitionFilter]
  canPack: Boolean
  canReceive: Boolean
  has: [MaterialStateTransitionHasFilter]
  id: [ID!]
  isPlanned: Boolean
  not: MaterialStateTransitionFilter
  or: [MaterialStateTransitionFilter]
}

enum MaterialStateTransitionHasFilter {
  canPack
  canReceive
  isPlanned
  status
  to
}

input MaterialStateTransitionPatch {
  canPack: Boolean
  canReceive: Boolean
  isPlanned: Boolean
  status: MaterialStatusRef
  to: [MaterialStatusRef]
}

input MaterialStateTransitionRef {
  canPack: Boolean
  canReceive: Boolean
  id: ID
  isPlanned: Boolean
  status: MaterialStatusRef
  to: [MaterialStatusRef]
}

type MaterialStatus
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  code: String! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  inventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter, first: Int, offset: Int, order: InventoryHoldingPolicyOrder): [InventoryHoldingPolicy] @join__field(graph: SCHEMA)
  inventoryHoldingPolicyAggregate(filter: InventoryHoldingPolicyFilter): InventoryHoldingPolicyAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
}

type MaterialStatusAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
}

input MaterialStatusFilter {
  and: [MaterialStatusFilter]
  code: StringHashFilter
  has: [MaterialStatusHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialStatusFilter
  or: [MaterialStatusFilter]
}

enum MaterialStatusHasFilter {
  code
  inventoryHoldingPolicy
  isActive
}

input MaterialStatusOrder {
  asc: MaterialStatusOrderable
  desc: MaterialStatusOrderable
  then: MaterialStatusOrder
}

enum MaterialStatusOrderable {
  code
}

input MaterialStatusPatch {
  code: String
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
}

input MaterialStatusRef {
  code: String
  id: ID
  inventoryHoldingPolicy: [InventoryHoldingPolicyRef]
  isActive: Boolean
}

"""
Each separately identifiable quantity of the same material lot shall be presented as a material sublot.
A material lot by be stored in separately identifiable quantities. All material sublots are part of the
material lot, so they have the material lot's property values. A material sublot may be just a single item.
ref-IEC62264-2 5.4.8
"""
type MaterialSubLot
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  carrier: Carrier @join__field(graph: WMS, requires: "code")
  childSubLot(filter: MaterialSubLotFilter): MaterialSubLot @join__field(graph: SCHEMA)
  code: String! @join__field(graph: SCHEMA)
  dataType: DataType @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isAssembledFromLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot] @join__field(graph: SCHEMA)
  isAssembledFromLotAggregate(filter: MaterialLotFilter): MaterialLotAggregateResult @join__field(graph: SCHEMA)
  isAssembledFromSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  isAssembledFromSubLotAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  isComponentOfLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot] @join__field(graph: SCHEMA)
  isComponentOfLotAggregate(filter: MaterialLotFilter): MaterialLotAggregateResult @join__field(graph: SCHEMA)
  isComponentOfSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  isComponentOfSubLotAggregate(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  materialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual] @join__field(graph: SCHEMA)
  materialActualAggregate(filter: MaterialActualFilter): MaterialActualAggregateResult @join__field(graph: SCHEMA)
  parentLot(filter: MaterialLotFilter): MaterialLot @join__field(graph: SCHEMA)
  parentSubLot(filter: MaterialSubLotFilter): MaterialSubLot @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  quantity: String @join__field(graph: SCHEMA)
  status(filter: MaterialStatusFilter): MaterialStatus! @join__field(graph: SCHEMA)
  storageLocation(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type MaterialSubLotAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  quantityMax: String
  quantityMin: String
}

input MaterialSubLotFilter {
  and: [MaterialSubLotFilter]
  code: StringHashFilter
  has: [MaterialSubLotHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialSubLotFilter
  or: [MaterialSubLotFilter]
}

enum MaterialSubLotHasFilter {
  childSubLot
  code
  dataType
  description
  isActive
  isAssembledFromLot
  isAssembledFromSubLot
  isComponentOfLot
  isComponentOfSubLot
  material
  materialActual
  parentLot
  parentSubLot
  properties
  quantity
  status
  storageLocation
  unitOfMeasure
}

input MaterialSubLotOrder {
  asc: MaterialSubLotOrderable
  desc: MaterialSubLotOrderable
  then: MaterialSubLotOrder
}

enum MaterialSubLotOrderable {
  code
  description
  quantity
}

input MaterialSubLotPatch {
  childSubLot: MaterialSubLotRef
  code: String
  dataType: DataType
  description: String
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  properties: [PropertyRef]
  quantity: String
  status: MaterialStatusRef
  storageLocation: EquipmentRef
  unitOfMeasure: UnitOfMeasureRef
}

input MaterialSubLotRef {
  childSubLot: MaterialSubLotRef
  code: String
  dataType: DataType
  description: String
  id: ID
  isActive: Boolean
  isAssembledFromLot: [MaterialLotRef]
  isAssembledFromSubLot: [MaterialSubLotRef]
  isComponentOfLot: [MaterialLotRef]
  isComponentOfSubLot: [MaterialSubLotRef]
  material: MaterialDefinitionRef
  materialActual: [MaterialActualRef]
  parentLot: MaterialLotRef
  parentSubLot: MaterialSubLotRef
  properties: [PropertyRef]
  quantity: String
  status: MaterialStatusRef
  storageLocation: EquipmentRef
  unitOfMeasure: UnitOfMeasureRef
}

type MaterialUnit
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  serialNumber: String! @join__field(graph: SCHEMA)
}

type MaterialUnitAggregateResult {
  count: Int
  serialNumberMax: String
  serialNumberMin: String
}

input MaterialUnitFilter {
  and: [MaterialUnitFilter]
  has: [MaterialUnitHasFilter]
  id: [ID!]
  isActive: Boolean
  not: MaterialUnitFilter
  or: [MaterialUnitFilter]
  serialNumber: StringHashFilter
}

enum MaterialUnitHasFilter {
  isActive
  material
  properties
  serialNumber
}

input MaterialUnitOrder {
  asc: MaterialUnitOrderable
  desc: MaterialUnitOrderable
  then: MaterialUnitOrder
}

enum MaterialUnitOrderable {
  serialNumber
}

input MaterialUnitPatch {
  isActive: Boolean
  material: MaterialDefinitionRef
  properties: [PropertyRef]
  serialNumber: String
}

input MaterialUnitRef {
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  properties: [PropertyRef]
  serialNumber: String
}

enum MaterialUse {
  ByProduct
  CoProduct
  Consumable
  Consumed
  Initial
  Packed
  Produced
  Received
  Rework
  Scrap
  Shipped
  Transferred
}

input MaterialUse_hash {
  eq: MaterialUse
  in: [MaterialUse]
}

type Menu {
  access(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role!]!
  accessAggregate(filter: RoleFilter): RoleAggregateResult
  children(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu!]
  childrenAggregate(filter: MenuFilter): MenuAggregateResult
  icon: String
  id: ID!
  isPage: Boolean!
  isSection: Boolean!
  label: String!
  menuPage: String
  orderNumber: Int
  parent(filter: MenuFilter): Menu
}

type MenuAggregateResult {
  count: Int
  iconMax: String
  iconMin: String
  labelMax: String
  labelMin: String
  menuPageMax: String
  menuPageMin: String
  orderNumberAvg: Float
  orderNumberMax: Int
  orderNumberMin: Int
  orderNumberSum: Int
}

input MenuFilter {
  and: [MenuFilter]
  has: [MenuHasFilter]
  id: [ID!]
  label: StringHashFilter
  not: MenuFilter
  or: [MenuFilter]
}

enum MenuHasFilter {
  access
  children
  icon
  isPage
  isSection
  label
  menuPage
  orderNumber
  parent
}

input MenuOrder {
  asc: MenuOrderable
  desc: MenuOrderable
  then: MenuOrder
}

enum MenuOrderable {
  icon
  label
  menuPage
  orderNumber
}

input MenuPatch {
  access: [RoleRef!]
  children: [MenuRef!]
  icon: String
  isPage: Boolean
  isSection: Boolean
  label: String
  menuPage: String
  orderNumber: Int
  parent: MenuRef
}

input MenuRef {
  access: [RoleRef!]
  children: [MenuRef!]
  icon: String
  id: ID
  isPage: Boolean
  isSection: Boolean
  label: String
  menuPage: String
  orderNumber: Int
  parent: MenuRef
}

enum MessageClass {
  AttendanceLog
  EventLog
  JobOrderStateChange
  JobOrderTransition
  JobRequest
  JobResponse
  OperationsRequestStart
  PerformanceLog
  PropertyValueTransfer
  QuantityLog
}

enum Mode {
  BATCH
  SINGLE
}

input MoveMaterialQuantitiesBetweenCarriersInput {
  carrierDestination: ExtCarrierRef!
  carrierInitial: ExtCarrierRef!
  materialQuantities: [MaterialQuantityMovement]!
  user: ExtUserRef!
}

input MoveMaterialSubLotsInput {
  materialSubLots: [ExtMaterialSubLotRef!]!
  newLocation: ExtCarrierRef!
  user: ExtUserRef!
}

enum mpmORCRevokeTriggers {
  BREAK_TIME_END
  BREAK_TIME_START
  FIFTEEN_MINUTES
  FORTYFIVE_MINUTES
  ORDER_CLOSE
  SIXTY_MINUTES
  THIRTY_MINUTES
}

enum mpmORCWarnTriggers {
  BREAK_TIME_END
  BREAK_TIME_START
  FIFTEEN_MINUTES
  FORTYFIVE_MINUTES
  ORDER_CLOSE
  SIXTY_MINUTES
  THIRTY_MINUTES
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addACL(input: [AddACLInput!]!): AddACLPayload @join__field(graph: SCHEMA)
  addAccessRight(input: [AddAccessRightInput!]!): AddAccessRightPayload @join__field(graph: SCHEMA)
  addAddress(input: [AddAddressInput!]!): AddAddressPayload @join__field(graph: SCHEMA)

  """
   Backfill iterates through the an equipment properties from the given timestamp until now, and evaulates
  events and rulesets and re-recreates responses for the time period given. Any existing data is delete.
  This is a long running process. Subscribe to the topic in the mqtt broker for updates.
  """
  addBackfill(input: BackfillRequest!): BackfillResponse @join__field(graph: CORE)

  """ Cancel a running Backfill  """
  addBackfillCancel(input: BackfillCancelRequest!): BackfillResponse @join__field(graph: CORE)
  addBillOfMaterial(input: [AddBillOfMaterialInput!]!, upsert: Boolean): AddBillOfMaterialPayload @join__field(graph: SCHEMA)
  addBox(input: [AddBoxInput!]!): AddBoxPayload @join__field(graph: SCHEMA)
  addCarrier(input: [AddCarrierInput!]!, upsert: Boolean): AddCarrierPayload @join__field(graph: SCHEMA)
  addDashboardConfig(input: [AddDashboardConfigInput!]!, upsert: Boolean): AddDashboardConfigPayload @join__field(graph: SCHEMA)
  addDashboardPanelConfig(input: [AddDashboardPanelConfigInput!]!): AddDashboardPanelConfigPayload @join__field(graph: SCHEMA)
  addDashboardWidgetConfigProperty(input: [AddDashboardWidgetConfigPropertyInput!]!): AddDashboardWidgetConfigPropertyPayload @join__field(graph: SCHEMA)
  addDelivery(input: [AddDeliveryInput!]!): AddDeliveryPayload @join__field(graph: SCHEMA)
  addEquipment(input: [AddEquipmentInput!]!): AddEquipmentPayload @join__field(graph: SCHEMA)
  addEquipmentActual(input: [AddEquipmentActualInput!]!): AddEquipmentActualPayload @join__field(graph: SCHEMA)
  addEquipmentClass(input: [AddEquipmentClassInput!]!): AddEquipmentClassPayload @join__field(graph: SCHEMA)
  addEquipmentNameAlias(input: [AddEquipmentNameAliasInput!]!): AddEquipmentNameAliasPayload @join__field(graph: SCHEMA)
  addEquipmentPropertyOverride(input: [AddEquipmentPropertyOverrideInput!]!): AddEquipmentPropertyOverridePayload @join__field(graph: SCHEMA)
  addEquipmentReasonOverride(input: [AddEquipmentReasonOverrideInput!]!): AddEquipmentReasonOverridePayload @join__field(graph: SCHEMA)
  addEquipmentRelation(input: [AddEquipmentRelationInput!]!): AddEquipmentRelationPayload @join__field(graph: SCHEMA)
  addEquipmentSpecification(input: [AddEquipmentSpecificationInput!]!): AddEquipmentSpecificationPayload @join__field(graph: SCHEMA)
  addEventDefinition(input: [AddEventDefinitionInput!]!): AddEventDefinitionPayload @join__field(graph: SCHEMA)
  addEventLog(input: [AddEventLogInput!]!): AddEventLogPayload @join__field(graph: SCHEMA)
  addForm(input: [AddFormInput!]!, upsert: Boolean): AddFormPayload @join__field(graph: SCHEMA)
  addGeneralLedgerAccount(input: [AddGeneralLedgerAccountInput!]!, upsert: Boolean): AddGeneralLedgerAccountPayload @join__field(graph: SCHEMA)
  addInterfaceMessageLog(input: [AddInterfaceMessageLogInput!]!): AddInterfaceMessageLogPayload @join__field(graph: SCHEMA)

  """
  method assumes that any backflushed materials are not tracked by carrier
  """
  addInventoryActual(input: [AddInventoryActualInput!]!): [AddInventoryActualPayload] @join__field(graph: WMS)
  addInventoryHandlingPolicy(input: [AddInventoryHandlingPolicyInput!]!, upsert: Boolean): AddInventoryHandlingPolicyPayload @join__field(graph: SCHEMA)
  addInventoryHandlingRule(input: [AddInventoryHandlingRuleInput!]!): AddInventoryHandlingRulePayload @join__field(graph: SCHEMA)
  addInventoryHoldingPolicy(input: [AddInventoryHoldingPolicyInput!]!): AddInventoryHoldingPolicyPayload @join__field(graph: SCHEMA)

  """method is deprecated, use addInventoryTransactions instead"""
  addInventoryTransactionReceive(input: [InventoryTransactionInput!]!): [InventoryTransaction] @deprecated @join__field(graph: WMS)
  addInventoryTransactions(input: [AddInventoryTransactionInput!]!): [InventoryTransaction] @join__field(graph: WMS)
  addJobOrder(input: [AddJobOrderInput!]!, upsert: Boolean): AddJobOrderPayload @join__field(graph: SCHEMA)
  addJobOrderDependency(input: [AddJobOrderDependencyInput!]!): AddJobOrderDependencyPayload @join__field(graph: SCHEMA)
  addJobOrderDispatchStateModel(input: [AddJobOrderDispatchStateModelInput!]!): AddJobOrderDispatchStateModelPayload @join__field(graph: SCHEMA)
  addJobOrderNote(input: [AddJobOrderNoteInput!]!): AddJobOrderNotePayload @join__field(graph: SCHEMA)
  addJobResponse(input: [AddJobResponseInput!]!): AddJobResponsePayload @join__field(graph: SCHEMA)
  addLibreService(input: [AddLibreServiceInput!]!, upsert: Boolean): AddLibreServicePayload @join__field(graph: SCHEMA)
  addMaterialActual(input: [AddMaterialActualInput!]!): AddMaterialActualPayload @join__field(graph: SCHEMA)
  addMaterialAlternate(input: [AddMaterialAlternateInput!]!): AddMaterialAlternatePayload @join__field(graph: SCHEMA)
  addMaterialClass(input: [AddMaterialClassInput!]!, upsert: Boolean): AddMaterialClassPayload @join__field(graph: SCHEMA)
  addMaterialDefinition(input: [AddMaterialDefinitionInput!]!, upsert: Boolean): AddMaterialDefinitionPayload @join__field(graph: SCHEMA)
  addMaterialEventRuleset(input: [AddMaterialEventRulesetInput!]!): AddMaterialEventRulesetPayload @join__field(graph: SCHEMA)
  addMaterialLot(input: [AddMaterialLotInput!]!, upsert: Boolean): AddMaterialLotPayload @join__field(graph: SCHEMA)
  addMaterialSpecification(input: [AddMaterialSpecificationInput!]!): AddMaterialSpecificationPayload @join__field(graph: SCHEMA)
  addMaterialStateModel(input: [AddMaterialStateModelInput!]!, upsert: Boolean): AddMaterialStateModelPayload @join__field(graph: SCHEMA)
  addMaterialStateTransition(input: [AddMaterialStateTransitionInput!]!): AddMaterialStateTransitionPayload @join__field(graph: SCHEMA)
  addMaterialStatus(input: [AddMaterialStatusInput!]!, upsert: Boolean): AddMaterialStatusPayload @join__field(graph: SCHEMA)
  addMaterialSubLot(input: [AddMaterialSubLotInput!]!, upsert: Boolean): AddMaterialSubLotPayload @join__field(graph: SCHEMA)
  addMaterialUnit(input: [AddMaterialUnitInput!]!, upsert: Boolean): AddMaterialUnitPayload @join__field(graph: SCHEMA)
  addMenu(input: [AddMenuInput!]!): AddMenuPayload @join__field(graph: SCHEMA)
  addOperationsDefinition(input: [AddOperationsDefinitionInput!]!, upsert: Boolean): AddOperationsDefinitionPayload @join__field(graph: SCHEMA)
  addOperationsRequest(input: [AddOperationsRequestInput!]!, upsert: Boolean): AddOperationsRequestPayload @join__field(graph: SCHEMA)
  addOperationsSegment(input: [AddOperationsSegmentInput!]!): AddOperationsSegmentPayload @join__field(graph: SCHEMA)
  addOrder(input: [AddOrderInput!]!): AddOrderPayload @join__field(graph: SCHEMA)
  addOrderLine(input: [AddOrderLineInput!]!): AddOrderLinePayload @join__field(graph: SCHEMA)
  addOrderStartRuleset(input: [AddOrderStartRulesetInput!]!): AddOrderStartRulesetPayload @join__field(graph: SCHEMA)
  addParameterSpecification(input: [AddParameterSpecificationInput!]!): AddParameterSpecificationPayload @join__field(graph: SCHEMA)
  addPartner(input: [AddPartnerInput!]!): AddPartnerPayload @join__field(graph: SCHEMA)
  addPayloadFieldDefinition(input: [AddPayloadFieldDefinitionInput!]!): AddPayloadFieldDefinitionPayload @join__field(graph: SCHEMA)
  addPerson(input: [AddPersonInput!]!, upsert: Boolean): AddPersonPayload @join__field(graph: SCHEMA)
  addPersonnelActual(input: [AddPersonnelActualInput!]!): AddPersonnelActualPayload @join__field(graph: SCHEMA)
  addPersonnelClass(input: [AddPersonnelClassInput!]!, upsert: Boolean): AddPersonnelClassPayload @join__field(graph: SCHEMA)
  addPersonnelSpecification(input: [AddPersonnelSpecificationInput!]!): AddPersonnelSpecificationPayload @join__field(graph: SCHEMA)
  addProperty(input: [AddPropertyInput!]!): AddPropertyPayload @join__field(graph: SCHEMA)
  addPropertyNameAlias(input: [AddPropertyNameAliasInput!]!): AddPropertyNameAliasPayload @join__field(graph: SCHEMA)
  addPropertyValueAlias(input: [AddPropertyValueAliasInput!]!): AddPropertyValueAliasPayload @join__field(graph: SCHEMA)
  addQuantityLog(input: [AddQuantityLogInput!]!): AddQuantityLogPayload @join__field(graph: SCHEMA)
  addQuantityLogTs(input: QuantityLogTsInput!): QuantityLogTs @join__field(graph: CORE)
  addReason(input: [AddReasonInput!]!): AddReasonPayload @join__field(graph: SCHEMA)
  addReasonCategory(input: [AddReasonCategoryInput!]!, upsert: Boolean): AddReasonCategoryPayload @join__field(graph: SCHEMA)
  addRequestState(input: [AddRequestStateInput!]!, upsert: Boolean): AddRequestStatePayload @join__field(graph: SCHEMA)
  addRole(input: [AddRoleInput!]!, upsert: Boolean): AddRolePayload @join__field(graph: SCHEMA)
  addSegmentDependency(input: [AddSegmentDependencyInput!]!): AddSegmentDependencyPayload @join__field(graph: SCHEMA)
  addSegmentInvoiceSetting(input: [AddSegmentInvoiceSettingInput!]!): AddSegmentInvoiceSettingPayload @join__field(graph: SCHEMA)
  addShipment(input: [AddShipmentInput!]!): AddShipmentPayload @join__field(graph: SCHEMA)
  addShipmentItem(input: [AddShipmentItemInput!]!): AddShipmentItemPayload @join__field(graph: SCHEMA)

  """method used to add shipment items to a shipment for a delivery company"""
  addShipmentItemsToDeliveryShipment(shipment: ExtShipmentRef!, shipmentItems: [ExtShipmentItemRef!]!, shippingAccountData: ShippingAccountData!): Shipment @join__field(graph: WMS)
  addShippingAccount(input: [AddShippingAccountInput!]!): AddShippingAccountPayload @join__field(graph: SCHEMA)
  addStateEventRuleset(input: [AddStateEventRulesetInput!]!): AddStateEventRulesetPayload @join__field(graph: SCHEMA)
  addTestResult(input: [AddTestResultInput!]!): AddTestResultPayload @join__field(graph: SCHEMA)
  addTestSpecification(input: [AddTestSpecificationInput!]!): AddTestSpecificationPayload @join__field(graph: SCHEMA)
  addTransitionEventRuleset(input: [AddTransitionEventRulesetInput!]!): AddTransitionEventRulesetPayload @join__field(graph: SCHEMA)
  addUnitOfMeasure(input: [AddUnitOfMeasureInput!]!, upsert: Boolean): AddUnitOfMeasurePayload @join__field(graph: SCHEMA)
  addUnitOfMeasureConversion(input: [AddUnitOfMeasureConversionInput!]!): AddUnitOfMeasureConversionPayload @join__field(graph: SCHEMA)
  addUser(input: [AddUserInput!]!, upsert: Boolean): AddUserPayload @join__field(graph: SCHEMA)
  addUserRole(input: [AddUserRoleInput!]!): AddUserRolePayload @join__field(graph: SCHEMA)
  addWorkCalendar(input: [AddWorkCalendarInput!]!, upsert: Boolean): AddWorkCalendarPayload @join__field(graph: SCHEMA)
  addWorkCalendarDefinitionEntry(input: [AddWorkCalendarDefinitionEntryInput!]!): AddWorkCalendarDefinitionEntryPayload @join__field(graph: SCHEMA)
  addWorkCalendarEntry(input: [AddWorkCalendarEntryInput!]!): AddWorkCalendarEntryPayload @join__field(graph: SCHEMA)
  addWorkflowConnection(input: [AddWorkflowConnectionInput!]!): AddWorkflowConnectionPayload @join__field(graph: SCHEMA)
  addWorkflowConnectionType(input: [AddWorkflowConnectionTypeInput!]!): AddWorkflowConnectionTypePayload @join__field(graph: SCHEMA)
  addWorkflowInstance(input: [AddWorkflowInstanceInput!]!): AddWorkflowInstancePayload @join__field(graph: SCHEMA)
  addWorkflowInstanceProperty(input: [AddWorkflowInstancePropertyInput!]!, upsert: Boolean): AddWorkflowInstancePropertyPayload @join__field(graph: SCHEMA)
  addWorkflowNode(input: [AddWorkflowNodeInput!]!): AddWorkflowNodePayload @join__field(graph: SCHEMA)
  addWorkflowNodeEvent(input: [AddWorkflowNodeEventInput!]!): AddWorkflowNodeEventPayload @join__field(graph: SCHEMA)
  addWorkflowNodeInstance(input: [AddWorkflowNodeInstanceInput!]!): AddWorkflowNodeInstancePayload @join__field(graph: SCHEMA)
  addWorkflowNodeType(input: [AddWorkflowNodeTypeInput!]!): AddWorkflowNodeTypePayload @join__field(graph: SCHEMA)
  addWorkflowProperty(input: [AddWorkflowPropertyInput!]!): AddWorkflowPropertyPayload @join__field(graph: SCHEMA)
  addWorkflowPropertyInstance(input: [AddWorkflowPropertyInstanceInput!]!): AddWorkflowPropertyInstancePayload @join__field(graph: SCHEMA)
  addWorkflowPropertyValue(input: [AddWorkflowPropertyValueInput!]!): AddWorkflowPropertyValuePayload @join__field(graph: SCHEMA)
  addWorkflowSpecification(input: [AddWorkflowSpecificationInput!]!): AddWorkflowSpecificationPayload @join__field(graph: SCHEMA)
  completeShipment(shipment: ExtShipmentRef!): Shipment @join__field(graph: WMS)

  """
   Complete a workflow node instance. If the specification contains a next task, it will be started
  otherwise the workflow instance will be completed.
  """
  completeWorkflowTask(input: CompleteWorkflowTaskInput!): WorkflowNodeInstance @join__field(graph: CORE)
  confirmASN(input: [ConfirmASNInput!]!, siteID: String!): [Order] @join__field(graph: WMS)
  createDeliveryOrderFromShipments(shipments: [ExtShipmentRef!]!, shippingAccountData: ShippingAccountData!): Delivery @join__field(graph: WMS)
  createDeliveryShipmentItemLabel(item: ExtShipmentItemRef!, shipment: ExtShipmentRef!, shippingAccountData: ShippingAccountData!): String @join__field(graph: WMS)

  """method used to create a shipment label to use with a delivery company"""
  createDeliveryShipmentLabel(shipment: ExtShipmentRef!, shippingAccountData: ShippingAccountData!): String @join__field(graph: WMS)

  """
  method used to create an empty outbbound shipment to use with a delivery company
  """
  createEmptyDeliveryShipment(shipment: ExtShipmentRef!, shippingAccountData: ShippingAccountData!): Shipment @join__field(graph: WMS)

  """
   Create a new instance of a given workflow specification and start the first task
  in the specification after the "START_EVENT". Properties can be supplied.
  """
  createWorkflowInstance(input: CreateWorkflowInstanceInput!): WorkflowInstance @join__field(graph: CORE)
  deleteACL(filter: ACLFilter!): DeleteACLPayload @join__field(graph: SCHEMA)
  deleteAccessRight(filter: AccessRightFilter!): DeleteAccessRightPayload @join__field(graph: SCHEMA)
  deleteAddress(filter: AddressFilter!): DeleteAddressPayload @join__field(graph: SCHEMA)
  deleteBillOfMaterial(filter: BillOfMaterialFilter!): DeleteBillOfMaterialPayload @join__field(graph: SCHEMA)
  deleteBox(filter: BoxFilter!): DeleteBoxPayload @join__field(graph: SCHEMA)
  deleteCarrier(filter: CarrierFilter!): DeleteCarrierPayload @join__field(graph: SCHEMA)
  deleteDashboardConfig(filter: DashboardConfigFilter!): DeleteDashboardConfigPayload @join__field(graph: SCHEMA)
  deleteDashboardPanelConfig(filter: DashboardPanelConfigFilter!): DeleteDashboardPanelConfigPayload @join__field(graph: SCHEMA)
  deleteDashboardWidgetConfigProperty(filter: DashboardWidgetConfigPropertyFilter!): DeleteDashboardWidgetConfigPropertyPayload @join__field(graph: SCHEMA)
  deleteDelivery(filter: DeliveryFilter!): DeleteDeliveryPayload @join__field(graph: SCHEMA)
  deleteDeliveryShipment(shipment: ExtShipmentRef!, shippingAccountData: ShippingAccountData!): Shipment @join__field(graph: WMS)
  deleteDeliveryShipmentItem(shipmentItem: ExtShipmentItemRef!, shippingAccountData: ShippingAccountData!): ShipmentItem @join__field(graph: WMS)
  deleteEquipment(filter: EquipmentFilter!): DeleteEquipmentPayload @join__field(graph: SCHEMA)
  deleteEquipmentActual(filter: EquipmentActualFilter!): DeleteEquipmentActualPayload @join__field(graph: SCHEMA)
  deleteEquipmentClass(filter: EquipmentClassFilter!): DeleteEquipmentClassPayload @join__field(graph: SCHEMA)
  deleteEquipmentNameAlias(filter: EquipmentNameAliasFilter!): DeleteEquipmentNameAliasPayload @join__field(graph: SCHEMA)
  deleteEquipmentPropertyOverride(filter: EquipmentPropertyOverrideFilter!): DeleteEquipmentPropertyOverridePayload @join__field(graph: SCHEMA)
  deleteEquipmentReasonOverride(filter: EquipmentReasonOverrideFilter!): DeleteEquipmentReasonOverridePayload @join__field(graph: SCHEMA)
  deleteEquipmentRelation(filter: EquipmentRelationFilter!): DeleteEquipmentRelationPayload @join__field(graph: SCHEMA)
  deleteEquipmentSpecification(filter: EquipmentSpecificationFilter!): DeleteEquipmentSpecificationPayload @join__field(graph: SCHEMA)
  deleteEventDefinition(filter: EventDefinitionFilter!): DeleteEventDefinitionPayload @join__field(graph: SCHEMA)
  deleteEventLog(filter: EventLogFilter!): DeleteEventLogPayload @join__field(graph: SCHEMA)
  deleteForm(filter: FormFilter!): DeleteFormPayload @join__field(graph: SCHEMA)
  deleteGeneralLedgerAccount(filter: GeneralLedgerAccountFilter!): DeleteGeneralLedgerAccountPayload @join__field(graph: SCHEMA)
  deleteInterfaceMessageLog(filter: InterfaceMessageLogFilter!): DeleteInterfaceMessageLogPayload @join__field(graph: SCHEMA)
  deleteInventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter!): DeleteInventoryHandlingPolicyPayload @join__field(graph: SCHEMA)
  deleteInventoryHandlingRule(filter: InventoryHandlingRuleFilter!): DeleteInventoryHandlingRulePayload @join__field(graph: SCHEMA)
  deleteInventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter!): DeleteInventoryHoldingPolicyPayload @join__field(graph: SCHEMA)
  deleteJobOrder(filter: JobOrderFilter!): DeleteJobOrderPayload @join__field(graph: SCHEMA)
  deleteJobOrderDependency(filter: JobOrderDependencyFilter!): DeleteJobOrderDependencyPayload @join__field(graph: SCHEMA)
  deleteJobOrderDispatchStateModel(filter: JobOrderDispatchStateModelFilter!): DeleteJobOrderDispatchStateModelPayload @join__field(graph: SCHEMA)
  deleteJobOrderNote(filter: JobOrderNoteFilter!): DeleteJobOrderNotePayload @join__field(graph: SCHEMA)
  deleteJobResponse(filter: JobResponseFilter!): DeleteJobResponsePayload @join__field(graph: SCHEMA)
  deleteLibreService(filter: LibreServiceFilter!): DeleteLibreServicePayload @join__field(graph: SCHEMA)
  deleteMaterialActual(filter: MaterialActualFilter!): DeleteMaterialActualPayload @join__field(graph: SCHEMA)
  deleteMaterialAlternate(filter: MaterialAlternateFilter!): DeleteMaterialAlternatePayload @join__field(graph: SCHEMA)
  deleteMaterialClass(filter: MaterialClassFilter!): DeleteMaterialClassPayload @join__field(graph: SCHEMA)
  deleteMaterialDefinition(filter: MaterialDefinitionFilter!): DeleteMaterialDefinitionPayload @join__field(graph: SCHEMA)
  deleteMaterialEventRuleset(filter: MaterialEventRulesetFilter!): DeleteMaterialEventRulesetPayload @join__field(graph: SCHEMA)
  deleteMaterialLot(filter: MaterialLotFilter!): DeleteMaterialLotPayload @join__field(graph: SCHEMA)
  deleteMaterialSpecification(filter: MaterialSpecificationFilter!): DeleteMaterialSpecificationPayload @join__field(graph: SCHEMA)
  deleteMaterialStateModel(filter: MaterialStateModelFilter!): DeleteMaterialStateModelPayload @join__field(graph: SCHEMA)
  deleteMaterialStateTransition(filter: MaterialStateTransitionFilter!): DeleteMaterialStateTransitionPayload @join__field(graph: SCHEMA)
  deleteMaterialStatus(filter: MaterialStatusFilter!): DeleteMaterialStatusPayload @join__field(graph: SCHEMA)
  deleteMaterialSubLot(filter: MaterialSubLotFilter!): DeleteMaterialSubLotPayload @join__field(graph: SCHEMA)
  deleteMaterialUnit(filter: MaterialUnitFilter!): DeleteMaterialUnitPayload @join__field(graph: SCHEMA)
  deleteMenu(filter: MenuFilter!): DeleteMenuPayload @join__field(graph: SCHEMA)
  deleteOperationsDefinition(filter: OperationsDefinitionFilter!): DeleteOperationsDefinitionPayload @join__field(graph: SCHEMA)
  deleteOperationsRequest(filter: OperationsRequestFilter!): DeleteOperationsRequestPayload @join__field(graph: SCHEMA)
  deleteOperationsRequestByCode(code: String!): OperationsRequest @join__field(graph: SCHEDULER)
  deleteOperationsSegment(filter: OperationsSegmentFilter!): DeleteOperationsSegmentPayload @join__field(graph: SCHEMA)
  deleteOrder(filter: OrderFilter!): DeleteOrderPayload @join__field(graph: SCHEMA)
  deleteOrderLine(filter: OrderLineFilter!): DeleteOrderLinePayload @join__field(graph: SCHEMA)
  deleteOrderStartRuleset(filter: OrderStartRulesetFilter!): DeleteOrderStartRulesetPayload @join__field(graph: SCHEMA)
  deleteParameterSpecification(filter: ParameterSpecificationFilter!): DeleteParameterSpecificationPayload @join__field(graph: SCHEMA)
  deletePartner(filter: PartnerFilter!): DeletePartnerPayload @join__field(graph: SCHEMA)
  deletePayloadFieldDefinition(filter: PayloadFieldDefinitionFilter!): DeletePayloadFieldDefinitionPayload @join__field(graph: SCHEMA)
  deletePerson(filter: PersonFilter!): DeletePersonPayload @join__field(graph: SCHEMA)
  deletePersonnelActual(filter: PersonnelActualFilter!): DeletePersonnelActualPayload @join__field(graph: SCHEMA)
  deletePersonnelClass(filter: PersonnelClassFilter!): DeletePersonnelClassPayload @join__field(graph: SCHEMA)
  deletePersonnelSpecification(filter: PersonnelSpecificationFilter!): DeletePersonnelSpecificationPayload @join__field(graph: SCHEMA)
  deleteProperty(filter: PropertyFilter!): DeletePropertyPayload @join__field(graph: SCHEMA)
  deletePropertyNameAlias(filter: PropertyNameAliasFilter!): DeletePropertyNameAliasPayload @join__field(graph: SCHEMA)
  deletePropertyValueAlias(filter: PropertyValueAliasFilter!): DeletePropertyValueAliasPayload @join__field(graph: SCHEMA)
  deleteQuantityLog(filter: QuantityLogFilter!): DeleteQuantityLogPayload @join__field(graph: SCHEMA)
  deleteReason(filter: ReasonFilter!): DeleteReasonPayload @join__field(graph: SCHEMA)
  deleteReasonCategory(filter: ReasonCategoryFilter!): DeleteReasonCategoryPayload @join__field(graph: SCHEMA)
  deleteRequestState(filter: RequestStateFilter!): DeleteRequestStatePayload @join__field(graph: SCHEMA)
  deleteRole(filter: RoleFilter!): DeleteRolePayload @join__field(graph: SCHEMA)
  deleteSegmentDependency(filter: SegmentDependencyFilter!): DeleteSegmentDependencyPayload @join__field(graph: SCHEMA)
  deleteSegmentInvoiceSetting(filter: SegmentInvoiceSettingFilter!): DeleteSegmentInvoiceSettingPayload @join__field(graph: SCHEMA)
  deleteShipment(filter: ShipmentFilter!): DeleteShipmentPayload @join__field(graph: SCHEMA)
  deleteShipmentItem(filter: ShipmentItemFilter!): DeleteShipmentItemPayload @join__field(graph: SCHEMA)
  deleteShippingAccount(filter: ShippingAccountFilter!): DeleteShippingAccountPayload @join__field(graph: SCHEMA)
  deleteStateEventRuleset(filter: StateEventRulesetFilter!): DeleteStateEventRulesetPayload @join__field(graph: SCHEMA)
  deleteTestResult(filter: TestResultFilter!): DeleteTestResultPayload @join__field(graph: SCHEMA)
  deleteTestSpecification(filter: TestSpecificationFilter!): DeleteTestSpecificationPayload @join__field(graph: SCHEMA)
  deleteTransitionEventRuleset(filter: TransitionEventRulesetFilter!): DeleteTransitionEventRulesetPayload @join__field(graph: SCHEMA)
  deleteUnitOfMeasure(filter: UnitOfMeasureFilter!): DeleteUnitOfMeasurePayload @join__field(graph: SCHEMA)
  deleteUnitOfMeasureConversion(filter: UnitOfMeasureConversionFilter!): DeleteUnitOfMeasureConversionPayload @join__field(graph: SCHEMA)
  deleteUser(filter: UserFilter!): DeleteUserPayload @join__field(graph: SCHEMA)
  deleteUserRole(filter: UserRoleFilter!): DeleteUserRolePayload @join__field(graph: SCHEMA)
  deleteWorkCalendar(filter: WorkCalendarFilter!): DeleteWorkCalendarPayload @join__field(graph: SCHEMA)
  deleteWorkCalendarDefinitionEntry(filter: WorkCalendarDefinitionEntryFilter!): DeleteWorkCalendarDefinitionEntryPayload @join__field(graph: SCHEMA)
  deleteWorkCalendarEntry(filter: WorkCalendarEntryFilter!): DeleteWorkCalendarEntryPayload @join__field(graph: SCHEMA)
  deleteWorkflowConnection(filter: WorkflowConnectionFilter!): DeleteWorkflowConnectionPayload @join__field(graph: SCHEMA)
  deleteWorkflowConnectionType(filter: WorkflowConnectionTypeFilter!): DeleteWorkflowConnectionTypePayload @join__field(graph: SCHEMA)
  deleteWorkflowInstance(filter: WorkflowInstanceFilter!): DeleteWorkflowInstancePayload @join__field(graph: SCHEMA)
  deleteWorkflowInstanceProperty(filter: WorkflowInstancePropertyFilter!): DeleteWorkflowInstancePropertyPayload @join__field(graph: SCHEMA)
  deleteWorkflowNode(filter: WorkflowNodeFilter!): DeleteWorkflowNodePayload @join__field(graph: SCHEMA)
  deleteWorkflowNodeEvent(filter: WorkflowNodeEventFilter!): DeleteWorkflowNodeEventPayload @join__field(graph: SCHEMA)
  deleteWorkflowNodeInstance(filter: WorkflowNodeInstanceFilter!): DeleteWorkflowNodeInstancePayload @join__field(graph: SCHEMA)
  deleteWorkflowNodeType(filter: WorkflowNodeTypeFilter!): DeleteWorkflowNodeTypePayload @join__field(graph: SCHEMA)
  deleteWorkflowProperty(filter: WorkflowPropertyFilter!): DeleteWorkflowPropertyPayload @join__field(graph: SCHEMA)
  deleteWorkflowPropertyInstance(filter: WorkflowPropertyInstanceFilter!): DeleteWorkflowPropertyInstancePayload @join__field(graph: SCHEMA)
  deleteWorkflowPropertyValue(filter: WorkflowPropertyValueFilter!): DeleteWorkflowPropertyValuePayload @join__field(graph: SCHEMA)
  deleteWorkflowSpecification(filter: WorkflowSpecificationFilter!): DeleteWorkflowSpecificationPayload @join__field(graph: SCHEMA)
  moveCarrierToBin(input: [InventoryTransactionInput!]!): [InventoryTransaction] @join__field(graph: WMS)

  """method is deprecated, use addInventoryTransactions instead"""
  moveMaterialQuantitiesBetweenCarriers(input: MoveMaterialQuantitiesBetweenCarriersInput!): [InventoryTransaction] @deprecated @join__field(graph: WMS)

  """method is deprecated, use addInventoryTransactions instead"""
  moveMaterialSubLots(input: MoveMaterialSubLotsInput!): [InventoryTransaction] @deprecated @join__field(graph: WMS)

  """method is deprecated, use addInventoryTransactions instead"""
  packInventoryTransaction(input: [InventoryTransactionInput!]!): [InventoryTransaction] @deprecated @join__field(graph: WMS)
  packShipment(shipment: ExtShipmentRef!): Shipment @join__field(graph: WMS)
  receiveInboundShipments(input: [ReceiveInboundShipmentInput!]!): [Shipment] @join__field(graph: WMS)

  """
   replay raw sensor history from an InfluxDB bucket and measure for a list of equipment and time range
  Deletes the run-time data in dgraph and influxDB for that equipment and replays the raw events into MQTT 
  """
  replayRawData(input: ReplayRawDataInput!): String @join__field(graph: CORE)
  reverseInventoryTransaction(transactionId: String!): [InventoryTransaction] @join__field(graph: WMS)
  splitEventLogTs(input: [EventLogTsInput]!): [EventLogTs] @join__field(graph: CORE)
  updateACL(input: UpdateACLInput!): UpdateACLPayload @join__field(graph: SCHEMA)
  updateAccessRight(input: UpdateAccessRightInput!): UpdateAccessRightPayload @join__field(graph: SCHEMA)
  updateAddress(input: UpdateAddressInput!): UpdateAddressPayload @join__field(graph: SCHEMA)
  updateBillOfMaterial(input: UpdateBillOfMaterialInput!): UpdateBillOfMaterialPayload @join__field(graph: SCHEMA)
  updateBox(input: UpdateBoxInput!): UpdateBoxPayload @join__field(graph: SCHEMA)
  updateCarrier(input: UpdateCarrierInput!): UpdateCarrierPayload @join__field(graph: SCHEMA)
  updateDashboardConfig(input: UpdateDashboardConfigInput!): UpdateDashboardConfigPayload @join__field(graph: SCHEMA)
  updateDashboardPanelConfig(input: UpdateDashboardPanelConfigInput!): UpdateDashboardPanelConfigPayload @join__field(graph: SCHEMA)
  updateDashboardWidgetConfigProperty(input: UpdateDashboardWidgetConfigPropertyInput!): UpdateDashboardWidgetConfigPropertyPayload @join__field(graph: SCHEMA)
  updateDelivery(input: UpdateDeliveryInput!): UpdateDeliveryPayload @join__field(graph: SCHEMA)
  updateEquipment(input: UpdateEquipmentInput!): UpdateEquipmentPayload @join__field(graph: SCHEMA)
  updateEquipmentActual(input: UpdateEquipmentActualInput!): UpdateEquipmentActualPayload @join__field(graph: SCHEMA)
  updateEquipmentClass(input: UpdateEquipmentClassInput!): UpdateEquipmentClassPayload @join__field(graph: SCHEMA)
  updateEquipmentNameAlias(input: UpdateEquipmentNameAliasInput!): UpdateEquipmentNameAliasPayload @join__field(graph: SCHEMA)
  updateEquipmentPropertyOverride(input: UpdateEquipmentPropertyOverrideInput!): UpdateEquipmentPropertyOverridePayload @join__field(graph: SCHEMA)
  updateEquipmentReasonOverride(input: UpdateEquipmentReasonOverrideInput!): UpdateEquipmentReasonOverridePayload @join__field(graph: SCHEMA)
  updateEquipmentRelation(input: UpdateEquipmentRelationInput!): UpdateEquipmentRelationPayload @join__field(graph: SCHEMA)
  updateEquipmentSpecification(input: UpdateEquipmentSpecificationInput!): UpdateEquipmentSpecificationPayload @join__field(graph: SCHEMA)
  updateEventDefinition(input: UpdateEventDefinitionInput!): UpdateEventDefinitionPayload @join__field(graph: SCHEMA)
  updateEventLog(input: UpdateEventLogInput!): UpdateEventLogPayload @join__field(graph: SCHEMA)
  updateEventLogTs(input: [EventLogTsInput]!): [EventLogTs] @join__field(graph: CORE)
  updateForm(input: UpdateFormInput!): UpdateFormPayload @join__field(graph: SCHEMA)
  updateGeneralLedgerAccount(input: UpdateGeneralLedgerAccountInput!): UpdateGeneralLedgerAccountPayload @join__field(graph: SCHEMA)
  updateInterfaceMessageLog(input: UpdateInterfaceMessageLogInput!): UpdateInterfaceMessageLogPayload @join__field(graph: SCHEMA)
  updateInventoryHandlingPolicy(input: UpdateInventoryHandlingPolicyInput!): UpdateInventoryHandlingPolicyPayload @join__field(graph: SCHEMA)
  updateInventoryHandlingRule(input: UpdateInventoryHandlingRuleInput!): UpdateInventoryHandlingRulePayload @join__field(graph: SCHEMA)
  updateInventoryHoldingPolicy(input: UpdateInventoryHoldingPolicyInput!): UpdateInventoryHoldingPolicyPayload @join__field(graph: SCHEMA)
  updateJobOrder(input: UpdateJobOrderInput!): UpdateJobOrderPayload @join__field(graph: SCHEMA)
  updateJobOrderDependency(input: UpdateJobOrderDependencyInput!): UpdateJobOrderDependencyPayload @join__field(graph: SCHEMA)
  updateJobOrderDispatchStateModel(input: UpdateJobOrderDispatchStateModelInput!): UpdateJobOrderDispatchStateModelPayload @join__field(graph: SCHEMA)
  updateJobOrderNote(input: UpdateJobOrderNoteInput!): UpdateJobOrderNotePayload @join__field(graph: SCHEMA)

  """
   update the status of a JobOrder. If setting the status to active, update any existing active orders
  for the same equipment to complete and update the associated JobResponse.endDateTime.
  When setting the status to ACTIVE, if there is no open JobResponse, create one and set the jobResponse.startDateTime
  If setting the status to complete, update the associated JobResponse.endDateTime
  """
  updateJobOrderStatus(input: UpdateJobOrderStatusInput): [JobOrder] @join__field(graph: CORE)
  updateJobResponse(input: UpdateJobResponseInput!): UpdateJobResponsePayload @join__field(graph: SCHEMA)
  updateLibreService(input: UpdateLibreServiceInput!): UpdateLibreServicePayload @join__field(graph: SCHEMA)
  updateMaterialActual(input: UpdateMaterialActualInput!): UpdateMaterialActualPayload @join__field(graph: SCHEMA)
  updateMaterialAlternate(input: UpdateMaterialAlternateInput!): UpdateMaterialAlternatePayload @join__field(graph: SCHEMA)
  updateMaterialClass(input: UpdateMaterialClassInput!): UpdateMaterialClassPayload @join__field(graph: SCHEMA)
  updateMaterialDefinition(input: UpdateMaterialDefinitionInput!): UpdateMaterialDefinitionPayload @join__field(graph: SCHEMA)
  updateMaterialEventRuleset(input: UpdateMaterialEventRulesetInput!): UpdateMaterialEventRulesetPayload @join__field(graph: SCHEMA)
  updateMaterialLot(input: UpdateMaterialLotInput!): UpdateMaterialLotPayload @join__field(graph: SCHEMA)
  updateMaterialSpecification(input: UpdateMaterialSpecificationInput!): UpdateMaterialSpecificationPayload @join__field(graph: SCHEMA)
  updateMaterialStateModel(input: UpdateMaterialStateModelInput!): UpdateMaterialStateModelPayload @join__field(graph: SCHEMA)
  updateMaterialStateTransition(input: UpdateMaterialStateTransitionInput!): UpdateMaterialStateTransitionPayload @join__field(graph: SCHEMA)
  updateMaterialStatus(input: UpdateMaterialStatusInput!): UpdateMaterialStatusPayload @join__field(graph: SCHEMA)
  updateMaterialSubLot(input: UpdateMaterialSubLotInput!): UpdateMaterialSubLotPayload @join__field(graph: SCHEMA)
  updateMaterialUnit(input: UpdateMaterialUnitInput!): UpdateMaterialUnitPayload @join__field(graph: SCHEMA)
  updateMenu(input: UpdateMenuInput!): UpdateMenuPayload @join__field(graph: SCHEMA)
  updateOperationsDefinition(input: UpdateOperationsDefinitionInput!): UpdateOperationsDefinitionPayload @join__field(graph: SCHEMA)
  updateOperationsRequest(input: UpdateOperationsRequestInput!): UpdateOperationsRequestPayload @join__field(graph: SCHEMA)
  updateOperationsSegment(input: UpdateOperationsSegmentInput!): UpdateOperationsSegmentPayload @join__field(graph: SCHEMA)
  updateOrder(input: UpdateOrderInput!): UpdateOrderPayload @join__field(graph: SCHEMA)
  updateOrderLine(input: UpdateOrderLineInput!): UpdateOrderLinePayload @join__field(graph: SCHEMA)
  updateOrderStartRuleset(input: UpdateOrderStartRulesetInput!): UpdateOrderStartRulesetPayload @join__field(graph: SCHEMA)
  updateOrderStatusRetroactively(input: UpdateOrderStatusInput): UpdatedOrderStatus @join__field(graph: CORE)
  updateParameterSpecification(input: UpdateParameterSpecificationInput!): UpdateParameterSpecificationPayload @join__field(graph: SCHEMA)
  updatePartner(input: UpdatePartnerInput!): UpdatePartnerPayload @join__field(graph: SCHEMA)
  updatePayloadFieldDefinition(input: UpdatePayloadFieldDefinitionInput!): UpdatePayloadFieldDefinitionPayload @join__field(graph: SCHEMA)
  updatePerson(input: UpdatePersonInput!): UpdatePersonPayload @join__field(graph: SCHEMA)
  updatePersonnelActual(input: UpdatePersonnelActualInput!): UpdatePersonnelActualPayload @join__field(graph: SCHEMA)
  updatePersonnelClass(input: UpdatePersonnelClassInput!): UpdatePersonnelClassPayload @join__field(graph: SCHEMA)
  updatePersonnelSpecification(input: UpdatePersonnelSpecificationInput!): UpdatePersonnelSpecificationPayload @join__field(graph: SCHEMA)
  updateProperty(input: UpdatePropertyInput!): UpdatePropertyPayload @join__field(graph: SCHEMA)
  updatePropertyNameAlias(input: UpdatePropertyNameAliasInput!): UpdatePropertyNameAliasPayload @join__field(graph: SCHEMA)
  updatePropertyValueAlias(input: UpdatePropertyValueAliasInput!): UpdatePropertyValueAliasPayload @join__field(graph: SCHEMA)
  updateQuantityLog(input: UpdateQuantityLogInput!): UpdateQuantityLogPayload @join__field(graph: SCHEMA)
  updateReason(input: UpdateReasonInput!): UpdateReasonPayload @join__field(graph: SCHEMA)
  updateReasonCategory(input: UpdateReasonCategoryInput!): UpdateReasonCategoryPayload @join__field(graph: SCHEMA)
  updateRequestState(input: UpdateRequestStateInput!): UpdateRequestStatePayload @join__field(graph: SCHEMA)
  updateRole(input: UpdateRoleInput!): UpdateRolePayload @join__field(graph: SCHEMA)
  updateSegmentDependency(input: UpdateSegmentDependencyInput!): UpdateSegmentDependencyPayload @join__field(graph: SCHEMA)
  updateSegmentInvoiceSetting(input: UpdateSegmentInvoiceSettingInput!): UpdateSegmentInvoiceSettingPayload @join__field(graph: SCHEMA)
  updateShipment(input: UpdateShipmentInput!): UpdateShipmentPayload @join__field(graph: SCHEMA)
  updateShipmentItem(input: UpdateShipmentItemInput!): UpdateShipmentItemPayload @join__field(graph: SCHEMA)
  updateShippingAccount(input: UpdateShippingAccountInput!): UpdateShippingAccountPayload @join__field(graph: SCHEMA)
  updateStateEventRuleset(input: UpdateStateEventRulesetInput!): UpdateStateEventRulesetPayload @join__field(graph: SCHEMA)
  updateTestResult(input: UpdateTestResultInput!): UpdateTestResultPayload @join__field(graph: SCHEMA)
  updateTestSpecification(input: UpdateTestSpecificationInput!): UpdateTestSpecificationPayload @join__field(graph: SCHEMA)
  updateTransitionEventRuleset(input: UpdateTransitionEventRulesetInput!): UpdateTransitionEventRulesetPayload @join__field(graph: SCHEMA)
  updateUnitOfMeasure(input: UpdateUnitOfMeasureInput!): UpdateUnitOfMeasurePayload @join__field(graph: SCHEMA)
  updateUnitOfMeasureConversion(input: UpdateUnitOfMeasureConversionInput!): UpdateUnitOfMeasureConversionPayload @join__field(graph: SCHEMA)
  updateUser(input: UpdateUserInput!): UpdateUserPayload @join__field(graph: SCHEMA)
  updateUserRole(input: UpdateUserRoleInput!): UpdateUserRolePayload @join__field(graph: SCHEMA)
  updateWorkCalendar(input: UpdateWorkCalendarInput!): UpdateWorkCalendarPayload @join__field(graph: SCHEMA)
  updateWorkCalendarDefinitionEntry(input: UpdateWorkCalendarDefinitionEntryInput!): UpdateWorkCalendarDefinitionEntryPayload @join__field(graph: SCHEMA)
  updateWorkCalendarEntry(input: UpdateWorkCalendarEntryInput!): UpdateWorkCalendarEntryPayload @join__field(graph: SCHEMA)
  updateWorkflowConnection(input: UpdateWorkflowConnectionInput!): UpdateWorkflowConnectionPayload @join__field(graph: SCHEMA)
  updateWorkflowConnectionType(input: UpdateWorkflowConnectionTypeInput!): UpdateWorkflowConnectionTypePayload @join__field(graph: SCHEMA)
  updateWorkflowInstance(input: UpdateWorkflowInstanceInput!): UpdateWorkflowInstancePayload @join__field(graph: SCHEMA)
  updateWorkflowInstanceProperty(input: UpdateWorkflowInstancePropertyInput!): UpdateWorkflowInstancePropertyPayload @join__field(graph: SCHEMA)
  updateWorkflowNode(input: UpdateWorkflowNodeInput!): UpdateWorkflowNodePayload @join__field(graph: SCHEMA)
  updateWorkflowNodeEvent(input: UpdateWorkflowNodeEventInput!): UpdateWorkflowNodeEventPayload @join__field(graph: SCHEMA)
  updateWorkflowNodeInstance(input: UpdateWorkflowNodeInstanceInput!): UpdateWorkflowNodeInstancePayload @join__field(graph: SCHEMA)
  updateWorkflowNodeType(input: UpdateWorkflowNodeTypeInput!): UpdateWorkflowNodeTypePayload @join__field(graph: SCHEMA)
  updateWorkflowProperty(input: UpdateWorkflowPropertyInput!): UpdateWorkflowPropertyPayload @join__field(graph: SCHEMA)
  updateWorkflowPropertyInstance(input: UpdateWorkflowPropertyInstanceInput!): UpdateWorkflowPropertyInstancePayload @join__field(graph: SCHEMA)
  updateWorkflowPropertyValue(input: UpdateWorkflowPropertyValueInput!): UpdateWorkflowPropertyValuePayload @join__field(graph: SCHEMA)
  updateWorkflowSpecification(input: UpdateWorkflowSpecificationInput!): UpdateWorkflowSpecificationPayload @join__field(graph: SCHEMA)

  """ Update a workflow node instance. This can update the user, properties or status of the task
  """
  updateWorkflowTask(input: UpdateWorkflowTaskInput!): WorkflowNodeInstance @join__field(graph: CORE)
  uploadProductionPlan(input: String!): [JobOrder] @join__field(graph: WMS)
  uploadSchedule(input: [UploadScheduleInput]!): UploadScheduleStaging @join__field(graph: SCHEDULER)
  uploadStagedSchedule(input: UploadStagedScheduleInput!): UploadStagedScheduleOutput @join__field(graph: SCHEDULER)
}

input NearFilter {
  coordinate: PointRef!
  distance: Float!
}

type OperationsDefinition
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  billOfMaterial(filter: BillOfMaterialFilter): BillOfMaterial @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  hierarchyScope: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  operationsType: WorkType! @join__field(graph: SCHEMA)
  segments(filter: OperationsSegmentFilter, first: Int, offset: Int, order: OperationsSegmentOrder): [OperationsSegment] @join__field(graph: SCHEMA)
  segmentsAggregate(filter: OperationsSegmentFilter): OperationsSegmentAggregateResult @join__field(graph: SCHEMA)
  version: String @join__field(graph: SCHEMA)
}

type OperationsDefinitionAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  hierarchyScopeMax: String
  hierarchyScopeMin: String
  nameMax: String
  nameMin: String
  versionMax: String
  versionMin: String
}

input OperationsDefinitionFilter {
  and: [OperationsDefinitionFilter]
  has: [OperationsDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: OperationsDefinitionFilter
  operationsType: WorkType_hash
  or: [OperationsDefinitionFilter]
}

enum OperationsDefinitionHasFilter {
  billOfMaterial
  description
  hierarchyScope
  isActive
  material
  name
  operationsType
  segments
  version
}

input OperationsDefinitionOrder {
  asc: OperationsDefinitionOrderable
  desc: OperationsDefinitionOrderable
  then: OperationsDefinitionOrder
}

enum OperationsDefinitionOrderable {
  description
  hierarchyScope
  name
  version
}

input OperationsDefinitionPatch {
  billOfMaterial: BillOfMaterialRef
  description: String
  hierarchyScope: String
  isActive: Boolean
  material: MaterialDefinitionRef
  name: String
  operationsType: WorkType
  segments: [OperationsSegmentRef]
  version: String
}

input OperationsDefinitionRef {
  billOfMaterial: BillOfMaterialRef
  description: String
  hierarchyScope: String
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  name: String
  operationsType: WorkType
  segments: [OperationsSegmentRef]
  version: String
}

"""
A request for operations to be performed is an operations schedule.
The schedule may apply to operations, maintenance, quality or inventory operations
"""
type OperationsRequest
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: SCHEDULER, key: "id")
  @join__type(graph: WMS, key: "id")
{
  actualProducedQuantity: Float @join__field(graph: WMS)
  actualStartDateTime: DateTime @join__field(graph: WMS)
  code: String! @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrders(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder] @join__field(graph: SCHEMA)
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult @join__field(graph: SCHEMA)
  operationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinition! @join__field(graph: SCHEMA)
  operationsType: WorkType! @join__field(graph: SCHEMA)
  plannedEndDateTime: DateTime @join__field(graph: SCHEMA)
  plannedStartDateTime: DateTime @join__field(graph: SCHEMA)
  priority: String @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  quantity: Float! @join__field(graph: SCHEMA)
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure! @join__field(graph: SCHEMA)
  requestState(filter: RequestStateFilter): RequestState! @join__field(graph: SCHEMA)
}

type OperationsRequestAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
  plannedEndDateTimeMax: DateTime
  plannedEndDateTimeMin: DateTime
  plannedStartDateTimeMax: DateTime
  plannedStartDateTimeMin: DateTime
  priorityMax: String
  priorityMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input OperationsRequestFilter {
  and: [OperationsRequestFilter]
  code: StringHashFilter
  has: [OperationsRequestHasFilter]
  id: [ID!]
  isActive: Boolean
  not: OperationsRequestFilter
  operationsType: WorkType_hash
  or: [OperationsRequestFilter]
  plannedEndDateTime: DateTimeFilter
  plannedStartDateTime: DateTimeFilter
}

enum OperationsRequestHasFilter {
  code
  equipment
  isActive
  jobOrders
  operationsDefinition
  operationsType
  plannedEndDateTime
  plannedStartDateTime
  priority
  properties
  quantity
  quantityUoM
  requestState
}

input OperationsRequestOrder {
  asc: OperationsRequestOrderable
  desc: OperationsRequestOrderable
  then: OperationsRequestOrder
}

enum OperationsRequestOrderable {
  code
  plannedEndDateTime
  plannedStartDateTime
  priority
  quantity
}

input OperationsRequestPatch {
  code: String
  equipment: EquipmentRef
  isActive: Boolean
  jobOrders: [JobOrderRef]
  operationsDefinition: OperationsDefinitionRef
  operationsType: WorkType
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  priority: String
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  requestState: RequestStateRef
}

input OperationsRequestRef {
  code: String
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobOrders: [JobOrderRef]
  operationsDefinition: OperationsDefinitionRef
  operationsType: WorkType
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  priority: String
  properties: [PropertyRef]
  quantity: Float
  quantityUoM: UnitOfMeasureRef
  requestState: RequestStateRef
}

type OperationsRequestStaging {
  code: String
  errList: [String]
  isValid: Boolean
  materialNo: String
  operationsDefinition: String
  plannedEndDateTime: DateTime
  plannedStartDateTime: DateTime
  quantity: Float
  quantityUoM: String
}

input OperationsRequestStagingInput {
  code: String!
  operationsDefinition: String!
  plannedEndDateTime: DateTime!
  plannedStartDateTime: DateTime!
  quantity: Float!
  quantityUoM: String
}

type OperationsSegment
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  children(filter: OperationsSegmentFilter, first: Int, offset: Int, order: OperationsSegmentOrder): [OperationsSegment] @join__field(graph: SCHEMA)
  childrenAggregate(filter: OperationsSegmentFilter): OperationsSegmentAggregateResult @join__field(graph: SCHEMA)
  costAmountDirectLabourRate: Float @join__field(graph: SCHEMA)
  costAmountFixedOverhead: Float @join__field(graph: SCHEMA)
  costAmountVariableOverhead: Float @join__field(graph: SCHEMA)
  costDriverFixedOverhead: CostDriver @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  duration: Float @join__field(graph: SCHEMA)
  durationUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
  equipmentSpecifications(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification] @join__field(graph: SCHEMA)
  equipmentSpecificationsAggregate(filter: EquipmentSpecificationFilter): EquipmentSpecificationAggregateResult @join__field(graph: SCHEMA)
  glAccountDirectLabour: String @join__field(graph: SCHEMA)
  glAccountFixedOverhead: String @join__field(graph: SCHEMA)
  glAccountVariableOverhead: String @join__field(graph: SCHEMA)
  glAccountWIP: String @join__field(graph: SCHEMA)
  glAccountWIPInvoice: String @join__field(graph: SCHEMA)
  hierarchyScope: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  inflows(filter: SegmentDependencyFilter, first: Int, offset: Int, order: SegmentDependencyOrder): [SegmentDependency] @join__field(graph: SCHEMA)
  inflowsAggregate(filter: SegmentDependencyFilter): SegmentDependencyAggregateResult @join__field(graph: SCHEMA)
  invoiceSettings(filter: SegmentInvoiceSettingFilter, first: Int, offset: Int, order: SegmentInvoiceSettingOrder): [SegmentInvoiceSetting] @join__field(graph: SCHEMA)
  invoiceSettingsAggregate(filter: SegmentInvoiceSettingFilter): SegmentInvoiceSettingAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrders(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder] @join__field(graph: SCHEMA)
  jobOrdersAggregate(filter: JobOrderFilter): JobOrderAggregateResult @join__field(graph: SCHEMA)
  materialEventRuleset(filter: MaterialEventRulesetFilter): MaterialEventRuleset @join__field(graph: SCHEMA)
  materialSpecifications(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification] @join__field(graph: SCHEMA)
  materialSpecificationsAggregate(filter: MaterialSpecificationFilter): MaterialSpecificationAggregateResult @join__field(graph: SCHEMA)
  mpmAutoIdentMatchCode(filter: PropertyFilter): Property @join__field(graph: SCHEMA)
  mpmChangeoverFamily: String @join__field(graph: SCHEMA)
  mpmEnableAutoIdent: Boolean @join__field(graph: SCHEMA)
  mpmEnableSmartChangeover: Boolean @join__field(graph: SCHEMA)
  mpmIdealChangeoverTime: Float @join__field(graph: SCHEMA)
  mpmIdealSetupTime: Float @join__field(graph: SCHEMA)
  mpmPlanRate: Float @join__field(graph: SCHEMA)
  mpmThresholdMicrostopDuration: Float @join__field(graph: SCHEMA)
  mpmThresholdRunDuration: Float @join__field(graph: SCHEMA)
  mpmThresholdRunRate: Float @join__field(graph: SCHEMA)
  mpmThresholdSlowDuration: Float @join__field(graph: SCHEMA)
  mpmThresholdSlowRate: Float @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  operationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinition @join__field(graph: SCHEMA)
  orderStartRuleset(filter: OrderStartRulesetFilter): OrderStartRuleset @join__field(graph: SCHEMA)
  outflows(filter: SegmentDependencyFilter, first: Int, offset: Int, order: SegmentDependencyOrder): [SegmentDependency] @join__field(graph: SCHEMA)
  outflowsAggregate(filter: SegmentDependencyFilter): SegmentDependencyAggregateResult @join__field(graph: SCHEMA)
  parameterSpecifications(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification] @join__field(graph: SCHEMA)
  parameterSpecificationsAggregate(filter: ParameterSpecificationFilter): ParameterSpecificationAggregateResult @join__field(graph: SCHEMA)
  parent(filter: OperationsSegmentFilter): OperationsSegment @join__field(graph: SCHEMA)
  personnelSpecifications(filter: PersonnelSpecificationFilter, first: Int, offset: Int, order: PersonnelSpecificationOrder): [PersonnelSpecification] @join__field(graph: SCHEMA)
  personnelSpecificationsAggregate(filter: PersonnelSpecificationFilter): PersonnelSpecificationAggregateResult @join__field(graph: SCHEMA)
  positionX: Int @join__field(graph: SCHEMA)
  positionY: Int @join__field(graph: SCHEMA)
  stateEventRuleset(filter: StateEventRulesetFilter): StateEventRuleset @join__field(graph: SCHEMA)
  type: SegmentType @join__field(graph: SCHEMA)
  uiComponent: String @join__field(graph: SCHEMA)
  version: String @join__field(graph: SCHEMA)
  workDefinitionType: String @join__field(graph: SCHEMA)
  workType: WorkType @join__field(graph: SCHEMA)
}

type OperationsSegmentAggregateResult {
  costAmountDirectLabourRateAvg: Float
  costAmountDirectLabourRateMax: Float
  costAmountDirectLabourRateMin: Float
  costAmountDirectLabourRateSum: Float
  costAmountFixedOverheadAvg: Float
  costAmountFixedOverheadMax: Float
  costAmountFixedOverheadMin: Float
  costAmountFixedOverheadSum: Float
  costAmountVariableOverheadAvg: Float
  costAmountVariableOverheadMax: Float
  costAmountVariableOverheadMin: Float
  costAmountVariableOverheadSum: Float
  count: Int
  descriptionMax: String
  descriptionMin: String
  durationAvg: Float
  durationMax: Float
  durationMin: Float
  durationSum: Float
  glAccountDirectLabourMax: String
  glAccountDirectLabourMin: String
  glAccountFixedOverheadMax: String
  glAccountFixedOverheadMin: String
  glAccountVariableOverheadMax: String
  glAccountVariableOverheadMin: String
  glAccountWIPInvoiceMax: String
  glAccountWIPInvoiceMin: String
  glAccountWIPMax: String
  glAccountWIPMin: String
  hierarchyScopeMax: String
  hierarchyScopeMin: String
  mpmChangeoverFamilyMax: String
  mpmChangeoverFamilyMin: String
  mpmIdealChangeoverTimeAvg: Float
  mpmIdealChangeoverTimeMax: Float
  mpmIdealChangeoverTimeMin: Float
  mpmIdealChangeoverTimeSum: Float
  mpmIdealSetupTimeAvg: Float
  mpmIdealSetupTimeMax: Float
  mpmIdealSetupTimeMin: Float
  mpmIdealSetupTimeSum: Float
  mpmPlanRateAvg: Float
  mpmPlanRateMax: Float
  mpmPlanRateMin: Float
  mpmPlanRateSum: Float
  mpmThresholdMicrostopDurationAvg: Float
  mpmThresholdMicrostopDurationMax: Float
  mpmThresholdMicrostopDurationMin: Float
  mpmThresholdMicrostopDurationSum: Float
  mpmThresholdRunDurationAvg: Float
  mpmThresholdRunDurationMax: Float
  mpmThresholdRunDurationMin: Float
  mpmThresholdRunDurationSum: Float
  mpmThresholdRunRateAvg: Float
  mpmThresholdRunRateMax: Float
  mpmThresholdRunRateMin: Float
  mpmThresholdRunRateSum: Float
  mpmThresholdSlowDurationAvg: Float
  mpmThresholdSlowDurationMax: Float
  mpmThresholdSlowDurationMin: Float
  mpmThresholdSlowDurationSum: Float
  mpmThresholdSlowRateAvg: Float
  mpmThresholdSlowRateMax: Float
  mpmThresholdSlowRateMin: Float
  mpmThresholdSlowRateSum: Float
  nameMax: String
  nameMin: String
  positionXAvg: Float
  positionXMax: Int
  positionXMin: Int
  positionXSum: Int
  positionYAvg: Float
  positionYMax: Int
  positionYMin: Int
  positionYSum: Int
  uiComponentMax: String
  uiComponentMin: String
  versionMax: String
  versionMin: String
  workDefinitionTypeMax: String
  workDefinitionTypeMin: String
}

input OperationsSegmentFilter {
  and: [OperationsSegmentFilter]
  description: StringHashFilter
  has: [OperationsSegmentHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: OperationsSegmentFilter
  or: [OperationsSegmentFilter]
  workDefinitionType: StringHashFilter
  workType: WorkType_hash
}

enum OperationsSegmentHasFilter {
  children
  costAmountDirectLabourRate
  costAmountFixedOverhead
  costAmountVariableOverhead
  costDriverFixedOverhead
  description
  duration
  durationUoM
  equipmentSpecifications
  glAccountDirectLabour
  glAccountFixedOverhead
  glAccountVariableOverhead
  glAccountWIP
  glAccountWIPInvoice
  hierarchyScope
  inflows
  invoiceSettings
  isActive
  jobOrders
  materialEventRuleset
  materialSpecifications
  mpmAutoIdentMatchCode
  mpmChangeoverFamily
  mpmEnableAutoIdent
  mpmEnableSmartChangeover
  mpmIdealChangeoverTime
  mpmIdealSetupTime
  mpmPlanRate
  mpmThresholdMicrostopDuration
  mpmThresholdRunDuration
  mpmThresholdRunRate
  mpmThresholdSlowDuration
  mpmThresholdSlowRate
  name
  operationsDefinition
  orderStartRuleset
  outflows
  parameterSpecifications
  parent
  personnelSpecifications
  positionX
  positionY
  stateEventRuleset
  type
  uiComponent
  version
  workDefinitionType
  workType
}

input OperationsSegmentOrder {
  asc: OperationsSegmentOrderable
  desc: OperationsSegmentOrderable
  then: OperationsSegmentOrder
}

enum OperationsSegmentOrderable {
  costAmountDirectLabourRate
  costAmountFixedOverhead
  costAmountVariableOverhead
  description
  duration
  glAccountDirectLabour
  glAccountFixedOverhead
  glAccountVariableOverhead
  glAccountWIP
  glAccountWIPInvoice
  hierarchyScope
  mpmChangeoverFamily
  mpmIdealChangeoverTime
  mpmIdealSetupTime
  mpmPlanRate
  mpmThresholdMicrostopDuration
  mpmThresholdRunDuration
  mpmThresholdRunRate
  mpmThresholdSlowDuration
  mpmThresholdSlowRate
  name
  positionX
  positionY
  uiComponent
  version
  workDefinitionType
}

input OperationsSegmentPatch {
  children: [OperationsSegmentRef]
  costAmountDirectLabourRate: Float
  costAmountFixedOverhead: Float
  costAmountVariableOverhead: Float
  costDriverFixedOverhead: CostDriver
  description: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  glAccountDirectLabour: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountWIP: String
  glAccountWIPInvoice: String
  hierarchyScope: String
  inflows: [SegmentDependencyRef]
  invoiceSettings: [SegmentInvoiceSettingRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  materialEventRuleset: MaterialEventRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  mpmAutoIdentMatchCode: PropertyRef
  mpmChangeoverFamily: String
  mpmEnableAutoIdent: Boolean
  mpmEnableSmartChangeover: Boolean
  mpmIdealChangeoverTime: Float
  mpmIdealSetupTime: Float
  mpmPlanRate: Float
  mpmThresholdMicrostopDuration: Float
  mpmThresholdRunDuration: Float
  mpmThresholdRunRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdSlowRate: Float
  name: String
  operationsDefinition: OperationsDefinitionRef
  orderStartRuleset: OrderStartRulesetRef
  outflows: [SegmentDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: OperationsSegmentRef
  personnelSpecifications: [PersonnelSpecificationRef]
  positionX: Int
  positionY: Int
  stateEventRuleset: StateEventRulesetRef
  type: SegmentType
  uiComponent: String
  version: String
  workDefinitionType: String
  workType: WorkType
}

input OperationsSegmentRef {
  children: [OperationsSegmentRef]
  costAmountDirectLabourRate: Float
  costAmountFixedOverhead: Float
  costAmountVariableOverhead: Float
  costDriverFixedOverhead: CostDriver
  description: String
  duration: Float
  durationUoM: UnitOfMeasureRef
  equipmentSpecifications: [EquipmentSpecificationRef]
  glAccountDirectLabour: String
  glAccountFixedOverhead: String
  glAccountVariableOverhead: String
  glAccountWIP: String
  glAccountWIPInvoice: String
  hierarchyScope: String
  id: ID
  inflows: [SegmentDependencyRef]
  invoiceSettings: [SegmentInvoiceSettingRef]
  isActive: Boolean
  jobOrders: [JobOrderRef]
  materialEventRuleset: MaterialEventRulesetRef
  materialSpecifications: [MaterialSpecificationRef]
  mpmAutoIdentMatchCode: PropertyRef
  mpmChangeoverFamily: String
  mpmEnableAutoIdent: Boolean
  mpmEnableSmartChangeover: Boolean
  mpmIdealChangeoverTime: Float
  mpmIdealSetupTime: Float
  mpmPlanRate: Float
  mpmThresholdMicrostopDuration: Float
  mpmThresholdRunDuration: Float
  mpmThresholdRunRate: Float
  mpmThresholdSlowDuration: Float
  mpmThresholdSlowRate: Float
  name: String
  operationsDefinition: OperationsDefinitionRef
  orderStartRuleset: OrderStartRulesetRef
  outflows: [SegmentDependencyRef]
  parameterSpecifications: [ParameterSpecificationRef]
  parent: OperationsSegmentRef
  personnelSpecifications: [PersonnelSpecificationRef]
  positionX: Int
  positionY: Int
  stateEventRuleset: StateEventRulesetRef
  type: SegmentType
  uiComponent: String
  version: String
  workDefinitionType: String
  workType: WorkType
}

"""An outbound Sales Order to be fulfilled"""
type Order
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  customerOrderNumber: String @join__field(graph: SCHEMA)
  customerReference: String @join__field(graph: SCHEMA)
  deliveryTerms: IncoTerms @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  invoiceFromPartner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
  invoiceToPartner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  lines(filter: OrderLineFilter, first: Int, offset: Int, order: OrderLineOrder): [OrderLine] @join__field(graph: SCHEMA)
  linesAggregate(filter: OrderLineFilter): OrderLineAggregateResult @join__field(graph: SCHEMA)
  linesWithAlternates: [OrderLine] @join__field(graph: WMS)
  materialList: [MaterialDefinition] @join__field(graph: WMS)
  notes: String @join__field(graph: SCHEMA)
  orderType: OrderType! @join__field(graph: SCHEMA)
  shipFromPartner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
  shipToPartner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
  shipments(filter: ShipmentFilter, first: Int, offset: Int, order: ShipmentOrder): [Shipment] @join__field(graph: SCHEMA)
  shipmentsAggregate(filter: ShipmentFilter): ShipmentAggregateResult @join__field(graph: SCHEMA)
  site(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  status: OrderStatus! @join__field(graph: SCHEMA)
  warehouse(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
}

type OrderAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  customerOrderNumberMax: String
  customerOrderNumberMin: String
  customerReferenceMax: String
  customerReferenceMin: String
  notesMax: String
  notesMin: String
}

input OrderFilter {
  and: [OrderFilter]
  customerOrderNumber: StringFullTextFilter_StringHashFilter
  has: [OrderHasFilter]
  id: [ID!]
  isActive: Boolean
  not: OrderFilter
  or: [OrderFilter]
  orderType: OrderType_hash
  status: OrderStatus_hash
}

enum OrderHasFilter {
  createdDateTime
  customerOrderNumber
  customerReference
  deliveryTerms
  invoiceFromPartner
  invoiceToPartner
  isActive
  lines
  notes
  orderType
  shipFromPartner
  shipToPartner
  shipments
  site
  status
  warehouse
}

type OrderLine
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  defectiveSerialNumbers: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isReturn: Boolean @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  order(filter: OrderFilter): Order @join__field(graph: SCHEMA)
  orderLineNumber: Int! @join__field(graph: SCHEMA)
  packedQty: Float @join__field(graph: WMS)
  quantity: Int! @join__field(graph: SCHEMA)
  stockOnHandQty: Float @join__field(graph: WMS)
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance @join__field(graph: SCHEMA)
}

type OrderLineAggregateResult {
  count: Int
  defectiveSerialNumbersMax: String
  defectiveSerialNumbersMin: String
  orderLineNumberAvg: Float
  orderLineNumberMax: Int
  orderLineNumberMin: Int
  orderLineNumberSum: Int
  quantityAvg: Float
  quantityMax: Int
  quantityMin: Int
  quantitySum: Int
}

input OrderLineFilter {
  and: [OrderLineFilter]
  has: [OrderLineHasFilter]
  id: [ID!]
  isActive: Boolean
  not: OrderLineFilter
  or: [OrderLineFilter]
}

enum OrderLineHasFilter {
  defectiveSerialNumbers
  isActive
  isReturn
  material
  order
  orderLineNumber
  quantity
  workflowInstance
}

input OrderLineOrder {
  asc: OrderLineOrderable
  desc: OrderLineOrderable
  then: OrderLineOrder
}

enum OrderLineOrderable {
  defectiveSerialNumbers
  orderLineNumber
  quantity
}

input OrderLinePatch {
  defectiveSerialNumbers: String
  isActive: Boolean
  isReturn: Boolean
  material: MaterialDefinitionRef
  order: OrderRef
  orderLineNumber: Int
  quantity: Int
  workflowInstance: WorkflowInstanceRef
}

input OrderLineRef {
  defectiveSerialNumbers: String
  id: ID
  isActive: Boolean
  isReturn: Boolean
  material: MaterialDefinitionRef
  order: OrderRef
  orderLineNumber: Int
  quantity: Int
  workflowInstance: WorkflowInstanceRef
}

input OrderOrder {
  asc: OrderOrderable
  desc: OrderOrderable
  then: OrderOrder
}

enum OrderOrderable {
  createdDateTime
  customerOrderNumber
  customerReference
  notes
}

input OrderPatch {
  createdDateTime: DateTime
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  isActive: Boolean
  lines: [OrderLineRef]
  notes: String
  orderType: OrderType
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  shipments: [ShipmentRef]
  site: EquipmentRef
  status: OrderStatus
  warehouse: EquipmentRef
}

input OrderRef {
  createdDateTime: DateTime
  customerOrderNumber: String
  customerReference: String
  deliveryTerms: IncoTerms
  id: ID
  invoiceFromPartner: PartnerRef
  invoiceToPartner: PartnerRef
  isActive: Boolean
  lines: [OrderLineRef]
  notes: String
  orderType: OrderType
  shipFromPartner: PartnerRef
  shipToPartner: PartnerRef
  shipments: [ShipmentRef]
  site: EquipmentRef
  status: OrderStatus
  warehouse: EquipmentRef
}

type OrderStartRuleset {
  eventDefs(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition]
  eventDefsAggregate(filter: EventDefinitionFilter): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segment(filter: OperationsSegmentFilter): OperationsSegment
}

type OrderStartRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input OrderStartRulesetFilter {
  and: [OrderStartRulesetFilter]
  has: [OrderStartRulesetHasFilter]
  id: [ID!]
  not: OrderStartRulesetFilter
  or: [OrderStartRulesetFilter]
}

enum OrderStartRulesetHasFilter {
  eventDefs
  name
  segment
}

input OrderStartRulesetOrder {
  asc: OrderStartRulesetOrderable
  desc: OrderStartRulesetOrderable
  then: OrderStartRulesetOrder
}

enum OrderStartRulesetOrderable {
  name
}

input OrderStartRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segment: OperationsSegmentRef
}

input OrderStartRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segment: OperationsSegmentRef
}

enum OrderStatus {
  COMPLETE
  CREATED
  DELIVERED
  PACKED
  RECEIVED
  SHIPPED
}

input OrderStatus_hash {
  eq: OrderStatus
  in: [OrderStatus]
}

enum OrderType {
  PURCHASE_ORDER
  REPAIR_ORDER
  REPLACE_ORDER
  RETURN_ORDER
  SALES_ORDER
}

input OrderType_hash {
  eq: OrderType
  in: [OrderType]
}

type PackedItem {
  FromPlace: PackedItemFrom
  Qty: Float
  SerialNumber: String
  material: MaterialDefinition
}

type PackedItemFrom {
  carrier: Carrier
  materialSubLot: MaterialSubLot
  storageLocation: Equipment
}

input PackedItemsFilter {
  isAccessory: Boolean
  isTerminal: Boolean
}

type ParameterSpecification
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrder(filter: JobOrderFilter): JobOrder @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition @join__field(graph: SCHEMA)
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment @join__field(graph: SCHEMA)
  property(filter: PropertyFilter): Property! @join__field(graph: SCHEMA)
  valueDefault: String @join__field(graph: SCHEMA)
  valueLowerControlLimit: Float @join__field(graph: SCHEMA)
  valueLowerSpecLimit: Float @join__field(graph: SCHEMA)
  valueSetPoint: String @join__field(graph: SCHEMA)
  valueUpperControlLimit: Float @join__field(graph: SCHEMA)
  valueUpperSpecLimit: Float @join__field(graph: SCHEMA)
}

type ParameterSpecificationAggregateResult {
  count: Int
  valueDefaultMax: String
  valueDefaultMin: String
  valueLowerControlLimitAvg: Float
  valueLowerControlLimitMax: Float
  valueLowerControlLimitMin: Float
  valueLowerControlLimitSum: Float
  valueLowerSpecLimitAvg: Float
  valueLowerSpecLimitMax: Float
  valueLowerSpecLimitMin: Float
  valueLowerSpecLimitSum: Float
  valueSetPointMax: String
  valueSetPointMin: String
  valueUpperControlLimitAvg: Float
  valueUpperControlLimitMax: Float
  valueUpperControlLimitMin: Float
  valueUpperControlLimitSum: Float
  valueUpperSpecLimitAvg: Float
  valueUpperSpecLimitMax: Float
  valueUpperSpecLimitMin: Float
  valueUpperSpecLimitSum: Float
}

input ParameterSpecificationFilter {
  and: [ParameterSpecificationFilter]
  has: [ParameterSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ParameterSpecificationFilter
  or: [ParameterSpecificationFilter]
}

enum ParameterSpecificationHasFilter {
  isActive
  jobOrder
  material
  operationsSegment
  property
  valueDefault
  valueLowerControlLimit
  valueLowerSpecLimit
  valueSetPoint
  valueUpperControlLimit
  valueUpperSpecLimit
}

input ParameterSpecificationOrder {
  asc: ParameterSpecificationOrderable
  desc: ParameterSpecificationOrderable
  then: ParameterSpecificationOrder
}

enum ParameterSpecificationOrderable {
  valueDefault
  valueLowerControlLimit
  valueLowerSpecLimit
  valueSetPoint
  valueUpperControlLimit
  valueUpperSpecLimit
}

input ParameterSpecificationPatch {
  isActive: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  operationsSegment: OperationsSegmentRef
  property: PropertyRef
  valueDefault: String
  valueLowerControlLimit: Float
  valueLowerSpecLimit: Float
  valueSetPoint: String
  valueUpperControlLimit: Float
  valueUpperSpecLimit: Float
}

input ParameterSpecificationRef {
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  material: MaterialDefinitionRef
  operationsSegment: OperationsSegmentRef
  property: PropertyRef
  valueDefault: String
  valueLowerControlLimit: Float
  valueLowerSpecLimit: Float
  valueSetPoint: String
  valueUpperControlLimit: Float
  valueUpperSpecLimit: Float
}

type Partner
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  billingAddress(filter: AddressFilter): Address @join__field(graph: SCHEMA)
  carriers(filter: CarrierFilter, first: Int, offset: Int, order: CarrierOrder): [Carrier] @join__field(graph: SCHEMA)
  carriersAggregate(filter: CarrierFilter): CarrierAggregateResult @join__field(graph: SCHEMA)
  companyCode: String! @join__field(graph: SCHEMA)
  contactEmail: String @join__field(graph: SCHEMA)
  contactName: String @join__field(graph: SCHEMA)
  contactPhone: String @join__field(graph: SCHEMA)
  fromOrders(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order] @join__field(graph: SCHEMA)
  fromOrdersAggregate(filter: OrderFilter): OrderAggregateResult @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isCustomer: Boolean @join__field(graph: SCHEMA)
  isInventoryOwner: Boolean @join__field(graph: SCHEMA)
  isMerchant: Boolean @join__field(graph: SCHEMA)
  isRepairer: Boolean @join__field(graph: SCHEMA)
  isSupplier: Boolean @join__field(graph: SCHEMA)
  isTransport: Boolean @join__field(graph: SCHEMA)
  name: String @join__field(graph: SCHEMA)
  registrationNumber: String @join__field(graph: SCHEMA)
  shippingAccounts(filter: ShippingAccountFilter, first: Int, offset: Int, order: ShippingAccountOrder): [ShippingAccount] @join__field(graph: SCHEMA)
  shippingAccountsAggregate(filter: ShippingAccountFilter): ShippingAccountAggregateResult @join__field(graph: SCHEMA)
  shippingAddress(filter: AddressFilter): Address @join__field(graph: SCHEMA)
  toOrders(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order] @join__field(graph: SCHEMA)
  toOrdersAggregate(filter: OrderFilter): OrderAggregateResult @join__field(graph: SCHEMA)
  vatNumber: String @join__field(graph: SCHEMA)
}

type PartnerAggregateResult {
  companyCodeMax: String
  companyCodeMin: String
  contactEmailMax: String
  contactEmailMin: String
  contactNameMax: String
  contactNameMin: String
  contactPhoneMax: String
  contactPhoneMin: String
  count: Int
  nameMax: String
  nameMin: String
  registrationNumberMax: String
  registrationNumberMin: String
  vatNumberMax: String
  vatNumberMin: String
}

input PartnerFilter {
  and: [PartnerFilter]
  companyCode: StringHashFilter
  has: [PartnerHasFilter]
  id: [ID!]
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: StringHashFilter
  not: PartnerFilter
  or: [PartnerFilter]
}

enum PartnerHasFilter {
  billingAddress
  carriers
  companyCode
  contactEmail
  contactName
  contactPhone
  fromOrders
  isActive
  isCustomer
  isInventoryOwner
  isMerchant
  isRepairer
  isSupplier
  isTransport
  name
  registrationNumber
  shippingAccounts
  shippingAddress
  toOrders
  vatNumber
}

input PartnerOrder {
  asc: PartnerOrderable
  desc: PartnerOrderable
  then: PartnerOrder
}

enum PartnerOrderable {
  companyCode
  contactEmail
  contactName
  contactPhone
  name
  registrationNumber
  vatNumber
}

input PartnerPatch {
  billingAddress: AddressRef
  carriers: [CarrierRef]
  companyCode: String
  contactEmail: String
  contactName: String
  contactPhone: String
  fromOrders: [OrderRef]
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: String
  registrationNumber: String
  shippingAccounts: [ShippingAccountRef]
  shippingAddress: AddressRef
  toOrders: [OrderRef]
  vatNumber: String
}

input PartnerRef {
  billingAddress: AddressRef
  carriers: [CarrierRef]
  companyCode: String
  contactEmail: String
  contactName: String
  contactPhone: String
  fromOrders: [OrderRef]
  id: ID
  isActive: Boolean
  isCustomer: Boolean
  isInventoryOwner: Boolean
  isMerchant: Boolean
  isRepairer: Boolean
  isSupplier: Boolean
  isTransport: Boolean
  name: String
  registrationNumber: String
  shippingAccounts: [ShippingAccountRef]
  shippingAddress: AddressRef
  toOrders: [OrderRef]
  vatNumber: String
}

type PayloadFieldDefinition
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  expression: String! @join__field(graph: SCHEMA)
  fieldType: PayloadFieldType @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
}

type PayloadFieldDefinitionAggregateResult {
  count: Int
  expressionMax: String
  expressionMin: String
  nameMax: String
  nameMin: String
}

input PayloadFieldDefinitionFilter {
  and: [PayloadFieldDefinitionFilter]
  has: [PayloadFieldDefinitionHasFilter]
  id: [ID!]
  isActive: Boolean
  not: PayloadFieldDefinitionFilter
  or: [PayloadFieldDefinitionFilter]
}

enum PayloadFieldDefinitionHasFilter {
  expression
  fieldType
  isActive
  name
}

input PayloadFieldDefinitionOrder {
  asc: PayloadFieldDefinitionOrderable
  desc: PayloadFieldDefinitionOrderable
  then: PayloadFieldDefinitionOrder
}

enum PayloadFieldDefinitionOrderable {
  expression
  name
}

input PayloadFieldDefinitionPatch {
  expression: String
  fieldType: PayloadFieldType
  isActive: Boolean
  name: String
}

input PayloadFieldDefinitionRef {
  expression: String
  fieldType: PayloadFieldType
  id: ID
  isActive: Boolean
  name: String
}

enum PayloadFieldType {
  Field
  Other
  Tag
}

type Person
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  memberOf(filter: PersonnelClassFilter, first: Int, offset: Int, order: PersonnelClassOrder): [PersonnelClass] @join__field(graph: SCHEMA)
  memberOfAggregate(filter: PersonnelClassFilter): PersonnelClassAggregateResult @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  personnelActual(filter: PersonnelActualFilter, first: Int, offset: Int, order: PersonnelActualOrder): [PersonnelActual] @join__field(graph: SCHEMA)
  personnelActualAggregate(filter: PersonnelActualFilter): PersonnelActualAggregateResult @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
}

type PersonAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

input PersonFilter {
  and: [PersonFilter]
  has: [PersonHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: PersonFilter
  or: [PersonFilter]
}

enum PersonHasFilter {
  description
  isActive
  memberOf
  name
  personnelActual
  properties
}

type PersonnelActual
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobResponse(filter: JobResponseFilter): JobResponse! @join__field(graph: SCHEMA)
  person(filter: PersonFilter): Person @join__field(graph: SCHEMA)
  quantity: Float @join__field(graph: SCHEMA)
  quantityUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type PersonnelActualAggregateResult {
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input PersonnelActualFilter {
  and: [PersonnelActualFilter]
  has: [PersonnelActualHasFilter]
  id: [ID!]
  isActive: Boolean
  not: PersonnelActualFilter
  or: [PersonnelActualFilter]
}

enum PersonnelActualHasFilter {
  isActive
  jobResponse
  person
  quantity
  quantityUoM
}

input PersonnelActualOrder {
  asc: PersonnelActualOrderable
  desc: PersonnelActualOrderable
  then: PersonnelActualOrder
}

enum PersonnelActualOrderable {
  quantity
}

input PersonnelActualPatch {
  isActive: Boolean
  jobResponse: JobResponseRef
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

input PersonnelActualRef {
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  person: PersonRef
  quantity: Float
  quantityUoM: UnitOfMeasureRef
}

"""
Personnel Class represents a grouping of personnel with similar characteristics
"""
type PersonnelClass
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isTestedBy(filter: TestSpecificationFilter, first: Int, offset: Int, order: TestSpecificationOrder): [TestSpecification] @join__field(graph: SCHEMA)
  isTestedByAggregate(filter: TestSpecificationFilter): TestSpecificationAggregateResult @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  persons(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person] @join__field(graph: SCHEMA)
  personsAggregate(filter: PersonFilter): PersonAggregateResult @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
}

type PersonnelClassAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

input PersonnelClassFilter {
  and: [PersonnelClassFilter]
  has: [PersonnelClassHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: PersonnelClassFilter
  or: [PersonnelClassFilter]
}

enum PersonnelClassHasFilter {
  description
  isActive
  isTestedBy
  name
  persons
  properties
}

input PersonnelClassOrder {
  asc: PersonnelClassOrderable
  desc: PersonnelClassOrderable
  then: PersonnelClassOrder
}

enum PersonnelClassOrderable {
  description
  name
}

input PersonnelClassPatch {
  description: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  name: String
  persons: [PersonRef]
  properties: [PropertyRef]
}

input PersonnelClassRef {
  description: String
  id: ID
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  name: String
  persons: [PersonRef]
  properties: [PropertyRef]
}

type PersonnelSpecification
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrder(filter: JobOrderFilter): JobOrder @join__field(graph: SCHEMA)
  operationsSegment(filter: OperationsSegmentFilter): OperationsSegment @join__field(graph: SCHEMA)
  person(filter: PersonFilter): Person @join__field(graph: SCHEMA)
  personnelClass(filter: PersonnelClassFilter): PersonnelClass @join__field(graph: SCHEMA)
  personnelUse: String @join__field(graph: SCHEMA)
  quantity: Float @join__field(graph: SCHEMA)
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type PersonnelSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  personnelUseMax: String
  personnelUseMin: String
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
}

input PersonnelSpecificationFilter {
  and: [PersonnelSpecificationFilter]
  has: [PersonnelSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: PersonnelSpecificationFilter
  or: [PersonnelSpecificationFilter]
}

enum PersonnelSpecificationHasFilter {
  description
  isActive
  jobOrder
  operationsSegment
  person
  personnelClass
  personnelUse
  quantity
  uom
}

input PersonnelSpecificationOrder {
  asc: PersonnelSpecificationOrderable
  desc: PersonnelSpecificationOrderable
  then: PersonnelSpecificationOrder
}

enum PersonnelSpecificationOrderable {
  description
  personnelUse
  quantity
}

input PersonnelSpecificationPatch {
  description: String
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

input PersonnelSpecificationRef {
  description: String
  id: ID
  isActive: Boolean
  jobOrder: JobOrderRef
  operationsSegment: OperationsSegmentRef
  person: PersonRef
  personnelClass: PersonnelClassRef
  personnelUse: String
  quantity: Float
  uom: UnitOfMeasureRef
}

input PersonOrder {
  asc: PersonOrderable
  desc: PersonOrderable
  then: PersonOrder
}

enum PersonOrderable {
  description
  name
}

input PersonPatch {
  description: String
  isActive: Boolean
  memberOf: [PersonnelClassRef]
  name: String
  personnelActual: [PersonnelActualRef]
  properties: [PropertyRef]
}

input PersonRef {
  description: String
  id: ID
  isActive: Boolean
  memberOf: [PersonnelClassRef]
  name: String
  personnelActual: [PersonnelActualRef]
  properties: [PropertyRef]
}

input PlanningSummaryFilter {
  equipmentName: String!
  materialCode: String
}

type Point {
  latitude: Float!
  longitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  latitude: Float!
  longitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  contains: ContainsFilter
  intersects: IntersectsFilter
  near: NearFilter
  within: WithinFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type Property
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  address: String @join__field(graph: SCHEMA)
  dataType: DataType @join__field(graph: SCHEMA)
  definedBy(filter: PropertyFilter): Property @join__field(graph: SCHEMA)
  description: String! @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass @join__field(graph: SCHEMA)
  eventPayloads(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition] @join__field(graph: SCHEMA)
  eventPayloadsAggregate(filter: EventDefinitionFilter): EventDefinitionAggregateResult @join__field(graph: SCHEMA)
  eventTriggers(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition] @join__field(graph: SCHEMA)
  eventTriggersAggregate(filter: EventDefinitionFilter): EventDefinitionAggregateResult @join__field(graph: SCHEMA)
  expression: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isTestedBy(filter: TestSpecificationFilter, first: Int, offset: Int, order: TestSpecificationOrder): [TestSpecification] @join__field(graph: SCHEMA)
  isTestedByAggregate(filter: TestSpecificationFilter): TestSpecificationAggregateResult @join__field(graph: SCHEMA)
  jobOrder(filter: JobOrderFilter): JobOrder @join__field(graph: SCHEMA)
  jobResponse(filter: JobResponseFilter): JobResponse @join__field(graph: SCHEMA)
  materialClass(filter: MaterialClassFilter): MaterialClass @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  operationsRequest(filter: OperationsRequestFilter): OperationsRequest @join__field(graph: SCHEMA)
  parameterSpecifications(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification] @join__field(graph: SCHEMA)
  parameterSpecificationsAggregate(filter: ParameterSpecificationFilter): ParameterSpecificationAggregateResult @join__field(graph: SCHEMA)
  propertyNameAliases(filter: PropertyNameAliasFilter, first: Int, offset: Int, order: PropertyNameAliasOrder): [PropertyNameAlias] @join__field(graph: SCHEMA)
  propertyNameAliasesAggregate(filter: PropertyNameAliasFilter): PropertyNameAliasAggregateResult @join__field(graph: SCHEMA)
  propertyOverrides(filter: EquipmentPropertyOverrideFilter, first: Int, offset: Int, order: EquipmentPropertyOverrideOrder): [EquipmentPropertyOverride] @join__field(graph: SCHEMA)
  propertyOverridesAggregate(filter: EquipmentPropertyOverrideFilter): EquipmentPropertyOverrideAggregateResult @join__field(graph: SCHEMA)
  storeHistory: Boolean @join__field(graph: SCHEMA)
  type: PropertyType @join__field(graph: SCHEMA)
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
  value: String @join__field(graph: SCHEMA)
}

type PropertyAggregateResult {
  addressMax: String
  addressMin: String
  count: Int
  descriptionMax: String
  descriptionMin: String
  expressionMax: String
  expressionMin: String
  nameMax: String
  nameMin: String
  valueMax: String
  valueMin: String
}

input PropertyFilter {
  and: [PropertyFilter]
  description: StringHashFilter
  has: [PropertyHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: PropertyFilter
  or: [PropertyFilter]
  type: PropertyType_hash
}

enum PropertyHasFilter {
  address
  dataType
  definedBy
  description
  equipment
  equipmentClass
  eventPayloads
  eventTriggers
  expression
  isActive
  isTestedBy
  jobOrder
  jobResponse
  materialClass
  name
  operationsRequest
  parameterSpecifications
  propertyNameAliases
  propertyOverrides
  storeHistory
  type
  unitOfMeasure
  value
}

input PropertyListFilter {
  id: [ID!]
}

type PropertyNameAlias {
  alias: String!
  equipment(filter: EquipmentFilter): Equipment!
  id: ID!
  property(filter: PropertyFilter): Property!
  system: String!
}

type PropertyNameAliasAggregateResult {
  aliasMax: String
  aliasMin: String
  count: Int
  systemMax: String
  systemMin: String
}

input PropertyNameAliasFilter {
  alias: StringFullTextFilter_StringHashFilter
  and: [PropertyNameAliasFilter]
  has: [PropertyNameAliasHasFilter]
  id: [ID!]
  not: PropertyNameAliasFilter
  or: [PropertyNameAliasFilter]
  system: StringFullTextFilter_StringHashFilter
}

enum PropertyNameAliasHasFilter {
  alias
  equipment
  property
  system
}

input PropertyNameAliasOrder {
  asc: PropertyNameAliasOrderable
  desc: PropertyNameAliasOrderable
  then: PropertyNameAliasOrder
}

enum PropertyNameAliasOrderable {
  alias
  system
}

input PropertyNameAliasPatch {
  alias: String
  equipment: EquipmentRef
  property: PropertyRef
  system: String
}

input PropertyNameAliasRef {
  alias: String
  equipment: EquipmentRef
  id: ID
  property: PropertyRef
  system: String
}

input PropertyOrder {
  asc: PropertyOrderable
  desc: PropertyOrderable
  then: PropertyOrder
}

enum PropertyOrderable {
  address
  description
  expression
  name
  value
}

input PropertyPatch {
  address: String
  dataType: DataType
  definedBy: PropertyRef
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  eventPayloads: [EventDefinitionRef]
  eventTriggers: [EventDefinitionRef]
  expression: String
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  jobOrder: JobOrderRef
  jobResponse: JobResponseRef
  materialClass: MaterialClassRef
  name: String
  operationsRequest: OperationsRequestRef
  parameterSpecifications: [ParameterSpecificationRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  storeHistory: Boolean
  type: PropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input PropertyRef {
  address: String
  dataType: DataType
  definedBy: PropertyRef
  description: String
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  eventPayloads: [EventDefinitionRef]
  eventTriggers: [EventDefinitionRef]
  expression: String
  id: ID
  isActive: Boolean
  isTestedBy: [TestSpecificationRef]
  jobOrder: JobOrderRef
  jobResponse: JobResponseRef
  materialClass: MaterialClassRef
  name: String
  operationsRequest: OperationsRequestRef
  parameterSpecifications: [ParameterSpecificationRef]
  propertyNameAliases: [PropertyNameAliasRef]
  propertyOverrides: [EquipmentPropertyOverrideRef]
  storeHistory: Boolean
  type: PropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

enum PropertyType {
  BOUND
  CALCULATED
  LIBRE
  REFERENCED
}

input PropertyType_hash {
  eq: PropertyType
  in: [PropertyType]
}

""" Columnar dataset for time-series property values """
type PropertyValue {
  property: Property
  timestamp: DateTime
  value: String
}

type PropertyValueAlias {
  alias: String!
  id: ID!
  property(filter: PropertyFilter): Property!
  system: String!
  value: String!
}

type PropertyValueAliasAggregateResult {
  aliasMax: String
  aliasMin: String
  count: Int
  systemMax: String
  systemMin: String
  valueMax: String
  valueMin: String
}

input PropertyValueAliasFilter {
  alias: StringFullTextFilter
  and: [PropertyValueAliasFilter]
  has: [PropertyValueAliasHasFilter]
  id: [ID!]
  not: PropertyValueAliasFilter
  or: [PropertyValueAliasFilter]
  system: StringFullTextFilter
  value: StringFullTextFilter
}

enum PropertyValueAliasHasFilter {
  alias
  property
  system
  value
}

input PropertyValueAliasOrder {
  asc: PropertyValueAliasOrderable
  desc: PropertyValueAliasOrderable
  then: PropertyValueAliasOrder
}

enum PropertyValueAliasOrderable {
  alias
  system
  value
}

input PropertyValueAliasPatch {
  alias: String
  property: PropertyRef
  system: String
  value: String
}

input PropertyValueAliasRef {
  alias: String
  id: ID
  property: PropertyRef
  system: String
  value: String
}

""" filter the properties and time range to be returned """
input PropertyValuesFilter {
  """
  returns all values between this timestamp and the timestamp specified by to.
  If not specified, defaules to -24h from the current time
  """
  from: DateTime

  """
   provide a list of property ids to return. Works as AND with propertyName filter.
  if not specified, return all properties for the equipment.
  """
  propertyId: [ID]

  """
   filter by the property name. Works as AND with propertyId filter.
  if not specified, return all properties for the equipment. 
  """
  propertyName: StringHashFilter

  """
  returns all events between this timestamp and the timestamp specified by from.
  If not specified, this value defaults to the current time
  """
  to: DateTime
}

type QuantityLog
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  comments: String @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobResponse(filter: JobResponseFilter): JobResponse! @join__field(graph: SCHEMA)
  quantity: Float! @join__field(graph: SCHEMA)
  reasonCode: String @join__field(graph: SCHEMA)
  reasonText: String @join__field(graph: SCHEMA)
  timestamp: DateTime @join__field(graph: SCHEMA)
  type: MaterialUse! @join__field(graph: SCHEMA)
}

type QuantityLogAggregateResult {
  commentsMax: String
  commentsMin: String
  count: Int
  quantityAvg: Float
  quantityMax: Float
  quantityMin: Float
  quantitySum: Float
  reasonCodeMax: String
  reasonCodeMin: String
  reasonTextMax: String
  reasonTextMin: String
  timestampMax: DateTime
  timestampMin: DateTime
}

input QuantityLogFilter {
  and: [QuantityLogFilter]
  comments: StringHashFilter
  has: [QuantityLogHasFilter]
  id: [ID!]
  isActive: Boolean
  not: QuantityLogFilter
  or: [QuantityLogFilter]
  reasonCode: StringHashFilter
  reasonText: StringHashFilter
  timestamp: DateTimeFilter
  type: MaterialUse_hash
}

enum QuantityLogHasFilter {
  comments
  equipment
  isActive
  jobResponse
  quantity
  reasonCode
  reasonText
  timestamp
  type
}

input QuantityLogOrder {
  asc: QuantityLogOrderable
  desc: QuantityLogOrderable
  then: QuantityLogOrder
}

enum QuantityLogOrderable {
  comments
  quantity
  reasonCode
  reasonText
  timestamp
}

input QuantityLogPatch {
  comments: String
  equipment: EquipmentRef
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  reasonCode: String
  reasonText: String
  timestamp: DateTime
  type: MaterialUse
}

input QuantityLogRef {
  comments: String
  equipment: EquipmentRef
  id: ID
  isActive: Boolean
  jobResponse: JobResponseRef
  quantity: Float
  reasonCode: String
  reasonText: String
  timestamp: DateTime
  type: MaterialUse
}

type QuantityLogTs {
  comment: String
  equipment: Equipment
  material: MaterialDefinition
  materialUse: MaterialUse
  plannedRunRate: Float
  quantity: Float
  reasonCode: String
  reasonText: String
  timeStamp: DateTime
}

input QuantityLogTsInput {
  comment: String
  equipment: ExtEquipmentRef!
  material: ExtMaterialDefinitionRef
  materialUse: MaterialUse!
  quantity: Float!
  reasonCode: String
  reasonText: String
  timeStamp: DateTime!
}

"""a summary of the quantity log"""
type QuantitySummary {
  """the sum of this type of quantity"""
  quantitySum: Float
  reasonCode: String
  reasonText: String

  """the type of quantity associated with the result"""
  type: String
}

"""the filter for a quantitySummary query"""
input QuantitySummaryFilter {
  """returns only the type specified by filterType"""
  filterType: String

  """
  groups the quantity logs on their reasons as well as their type if used.
  valid options are 'reasonText' and 'reasonCode'
  """
  groupBy: String

  """deprecated"""
  sortBy: String

  """limits the number of results that return"""
  topN: Int
}

type Query {
  aggregateACL(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  aggregateAccessRight(filter: AccessRightFilter): AccessRightAggregateResult @join__field(graph: SCHEMA)
  aggregateAddress(filter: AddressFilter): AddressAggregateResult @join__field(graph: SCHEMA)
  aggregateBillOfMaterial(filter: BillOfMaterialFilter): BillOfMaterialAggregateResult @join__field(graph: SCHEMA)
  aggregateBox(filter: BoxFilter): BoxAggregateResult @join__field(graph: SCHEMA)
  aggregateCarrier(filter: CarrierFilter): CarrierAggregateResult @join__field(graph: SCHEMA)
  aggregateDashboardConfig(filter: DashboardConfigFilter): DashboardConfigAggregateResult @join__field(graph: SCHEMA)
  aggregateDashboardPanelConfig(filter: DashboardPanelConfigFilter): DashboardPanelConfigAggregateResult @join__field(graph: SCHEMA)
  aggregateDashboardWidgetConfigProperty(filter: DashboardWidgetConfigPropertyFilter): DashboardWidgetConfigPropertyAggregateResult @join__field(graph: SCHEMA)
  aggregateDelivery(filter: DeliveryFilter): DeliveryAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipment(filter: EquipmentFilter): EquipmentAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipmentActual(filter: EquipmentActualFilter): EquipmentActualAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipmentClass(filter: EquipmentClassFilter): EquipmentClassAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipmentNameAlias(filter: EquipmentNameAliasFilter): EquipmentNameAliasAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipmentPropertyOverride(filter: EquipmentPropertyOverrideFilter): EquipmentPropertyOverrideAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipmentReasonOverride(filter: EquipmentReasonOverrideFilter): EquipmentReasonOverrideAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipmentRelation(filter: EquipmentRelationFilter): EquipmentRelationAggregateResult @join__field(graph: SCHEMA)
  aggregateEquipmentSpecification(filter: EquipmentSpecificationFilter): EquipmentSpecificationAggregateResult @join__field(graph: SCHEMA)
  aggregateEventDefinition(filter: EventDefinitionFilter): EventDefinitionAggregateResult @join__field(graph: SCHEMA)
  aggregateEventLog(filter: EventLogFilter): EventLogAggregateResult @join__field(graph: SCHEMA)
  aggregateForm(filter: FormFilter): FormAggregateResult @join__field(graph: SCHEMA)
  aggregateGeneralLedgerAccount(filter: GeneralLedgerAccountFilter): GeneralLedgerAccountAggregateResult @join__field(graph: SCHEMA)
  aggregateInterfaceMessageLog(filter: InterfaceMessageLogFilter): InterfaceMessageLogAggregateResult @join__field(graph: SCHEMA)
  aggregateInventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter): InventoryHandlingPolicyAggregateResult @join__field(graph: SCHEMA)
  aggregateInventoryHandlingRule(filter: InventoryHandlingRuleFilter): InventoryHandlingRuleAggregateResult @join__field(graph: SCHEMA)
  aggregateInventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter): InventoryHoldingPolicyAggregateResult @join__field(graph: SCHEMA)
  aggregateJobOrder(filter: JobOrderFilter): JobOrderAggregateResult @join__field(graph: SCHEMA)
  aggregateJobOrderDependency(filter: JobOrderDependencyFilter): JobOrderDependencyAggregateResult @join__field(graph: SCHEMA)
  aggregateJobOrderDispatchStateModel(filter: JobOrderDispatchStateModelFilter): JobOrderDispatchStateModelAggregateResult @join__field(graph: SCHEMA)
  aggregateJobOrderNote(filter: JobOrderNoteFilter): JobOrderNoteAggregateResult @join__field(graph: SCHEMA)
  aggregateJobResponse(filter: JobResponseFilter): JobResponseAggregateResult @join__field(graph: SCHEMA)
  aggregateLibreService(filter: LibreServiceFilter): LibreServiceAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialActual(filter: MaterialActualFilter): MaterialActualAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialAlternate(filter: MaterialAlternateFilter): MaterialAlternateAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialClass(filter: MaterialClassFilter): MaterialClassAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialDefinition(filter: MaterialDefinitionFilter): MaterialDefinitionAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialEventRuleset(filter: MaterialEventRulesetFilter): MaterialEventRulesetAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialLot(filter: MaterialLotFilter): MaterialLotAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialSpecification(filter: MaterialSpecificationFilter): MaterialSpecificationAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialStateModel(filter: MaterialStateModelFilter): MaterialStateModelAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialStateTransition(filter: MaterialStateTransitionFilter): MaterialStateTransitionAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialStatus(filter: MaterialStatusFilter): MaterialStatusAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialSubLot(filter: MaterialSubLotFilter): MaterialSubLotAggregateResult @join__field(graph: SCHEMA)
  aggregateMaterialUnit(filter: MaterialUnitFilter): MaterialUnitAggregateResult @join__field(graph: SCHEMA)
  aggregateMenu(filter: MenuFilter): MenuAggregateResult @join__field(graph: SCHEMA)
  aggregateOperationsDefinition(filter: OperationsDefinitionFilter): OperationsDefinitionAggregateResult @join__field(graph: SCHEMA)
  aggregateOperationsRequest(filter: OperationsRequestFilter): OperationsRequestAggregateResult @join__field(graph: SCHEMA)
  aggregateOperationsSegment(filter: OperationsSegmentFilter): OperationsSegmentAggregateResult @join__field(graph: SCHEMA)
  aggregateOrder(filter: OrderFilter): OrderAggregateResult @join__field(graph: SCHEMA)
  aggregateOrderLine(filter: OrderLineFilter): OrderLineAggregateResult @join__field(graph: SCHEMA)
  aggregateOrderStartRuleset(filter: OrderStartRulesetFilter): OrderStartRulesetAggregateResult @join__field(graph: SCHEMA)
  aggregateParameterSpecification(filter: ParameterSpecificationFilter): ParameterSpecificationAggregateResult @join__field(graph: SCHEMA)
  aggregatePartner(filter: PartnerFilter): PartnerAggregateResult @join__field(graph: SCHEMA)
  aggregatePayloadFieldDefinition(filter: PayloadFieldDefinitionFilter): PayloadFieldDefinitionAggregateResult @join__field(graph: SCHEMA)
  aggregatePerson(filter: PersonFilter): PersonAggregateResult @join__field(graph: SCHEMA)
  aggregatePersonnelActual(filter: PersonnelActualFilter): PersonnelActualAggregateResult @join__field(graph: SCHEMA)
  aggregatePersonnelClass(filter: PersonnelClassFilter): PersonnelClassAggregateResult @join__field(graph: SCHEMA)
  aggregatePersonnelSpecification(filter: PersonnelSpecificationFilter): PersonnelSpecificationAggregateResult @join__field(graph: SCHEMA)
  aggregateProperty(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  aggregatePropertyNameAlias(filter: PropertyNameAliasFilter): PropertyNameAliasAggregateResult @join__field(graph: SCHEMA)
  aggregatePropertyValueAlias(filter: PropertyValueAliasFilter): PropertyValueAliasAggregateResult @join__field(graph: SCHEMA)
  aggregateQuantityLog(filter: QuantityLogFilter): QuantityLogAggregateResult @join__field(graph: SCHEMA)
  aggregateReason(filter: ReasonFilter): ReasonAggregateResult @join__field(graph: SCHEMA)
  aggregateReasonCategory(filter: ReasonCategoryFilter): ReasonCategoryAggregateResult @join__field(graph: SCHEMA)
  aggregateRequestState(filter: RequestStateFilter): RequestStateAggregateResult @join__field(graph: SCHEMA)
  aggregateRole(filter: RoleFilter): RoleAggregateResult @join__field(graph: SCHEMA)
  aggregateSegmentDependency(filter: SegmentDependencyFilter): SegmentDependencyAggregateResult @join__field(graph: SCHEMA)
  aggregateSegmentInvoiceSetting(filter: SegmentInvoiceSettingFilter): SegmentInvoiceSettingAggregateResult @join__field(graph: SCHEMA)
  aggregateShipment(filter: ShipmentFilter): ShipmentAggregateResult @join__field(graph: SCHEMA)
  aggregateShipmentItem(filter: ShipmentItemFilter): ShipmentItemAggregateResult @join__field(graph: SCHEMA)
  aggregateShippingAccount(filter: ShippingAccountFilter): ShippingAccountAggregateResult @join__field(graph: SCHEMA)
  aggregateStateEventRuleset(filter: StateEventRulesetFilter): StateEventRulesetAggregateResult @join__field(graph: SCHEMA)
  aggregateTestResult(filter: TestResultFilter): TestResultAggregateResult @join__field(graph: SCHEMA)
  aggregateTestSpecification(filter: TestSpecificationFilter): TestSpecificationAggregateResult @join__field(graph: SCHEMA)
  aggregateTransitionEventRuleset(filter: TransitionEventRulesetFilter): TransitionEventRulesetAggregateResult @join__field(graph: SCHEMA)
  aggregateUnitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasureAggregateResult @join__field(graph: SCHEMA)
  aggregateUnitOfMeasureConversion(filter: UnitOfMeasureConversionFilter): UnitOfMeasureConversionAggregateResult @join__field(graph: SCHEMA)
  aggregateUser(filter: UserFilter): UserAggregateResult @join__field(graph: SCHEMA)
  aggregateUserRole(filter: UserRoleFilter): UserRoleAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkCalendar(filter: WorkCalendarFilter): WorkCalendarAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkCalendarDefinitionEntry(filter: WorkCalendarDefinitionEntryFilter): WorkCalendarDefinitionEntryAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkCalendarEntry(filter: WorkCalendarEntryFilter): WorkCalendarEntryAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowConnection(filter: WorkflowConnectionFilter): WorkflowConnectionAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowConnectionType(filter: WorkflowConnectionTypeFilter): WorkflowConnectionTypeAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowInstance(filter: WorkflowInstanceFilter): WorkflowInstanceAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowInstanceProperty(filter: WorkflowInstancePropertyFilter): WorkflowInstancePropertyAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowNode(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowNodeEvent(filter: WorkflowNodeEventFilter): WorkflowNodeEventAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowNodeInstance(filter: WorkflowNodeInstanceFilter): WorkflowNodeInstanceAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowNodeType(filter: WorkflowNodeTypeFilter): WorkflowNodeTypeAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowProperty(filter: WorkflowPropertyFilter): WorkflowPropertyAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowPropertyInstance(filter: WorkflowPropertyInstanceFilter): WorkflowPropertyInstanceAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowPropertyValue(filter: WorkflowPropertyValueFilter): WorkflowPropertyValueAggregateResult @join__field(graph: SCHEMA)
  aggregateWorkflowSpecification(filter: WorkflowSpecificationFilter): WorkflowSpecificationAggregateResult @join__field(graph: SCHEMA)
  getACL(id: ID!): ACL @join__field(graph: SCHEMA)
  getAccessRight(id: ID!): AccessRight @join__field(graph: SCHEMA)
  getAddress(id: ID!): Address @join__field(graph: SCHEMA)
  getAllEventsInTimeRange(filter: AllEventsInTimeRangeFilter!): [EventsByField] @join__field(graph: CORE)
  getBillOfMaterial(id: ID, name: String): BillOfMaterial @join__field(graph: SCHEMA)
  getBox(id: ID!): Box @join__field(graph: SCHEMA)
  getCarrier(code: String, id: ID): Carrier @join__field(graph: SCHEMA)
  getDashboardConfig(id: ID, name: String): DashboardConfig @join__field(graph: SCHEMA)
  getDashboardPanelConfig(id: ID!): DashboardPanelConfig @join__field(graph: SCHEMA)
  getDashboardWidgetConfigProperty(id: ID!): DashboardWidgetConfigProperty @join__field(graph: SCHEMA)
  getDelivery(id: ID!): Delivery @join__field(graph: SCHEMA)
  getDeliveryOrder(delivery: ExtDeliveryRef!, shippingAccountData: ShippingAccountData!): TransportCompanyDeliveryOrder @join__field(graph: WMS)
  getEquipment(id: ID!): Equipment @join__field(graph: SCHEMA)
  getEquipmentActual(id: ID!): EquipmentActual @join__field(graph: SCHEMA)
  getEquipmentClass(id: ID!): EquipmentClass @join__field(graph: SCHEMA)
  getEquipmentNameAlias(id: ID!): EquipmentNameAlias @join__field(graph: SCHEMA)
  getEquipmentPropertyOverride(id: ID!): EquipmentPropertyOverride @join__field(graph: SCHEMA)
  getEquipmentReasonOverride(id: ID!): EquipmentReasonOverride @join__field(graph: SCHEMA)
  getEquipmentRelation(id: ID!): EquipmentRelation @join__field(graph: SCHEMA)
  getEquipmentSpecification(id: ID!): EquipmentSpecification @join__field(graph: SCHEMA)
  getEventDefinition(id: ID!): EventDefinition @join__field(graph: SCHEMA)
  getEventLog(id: ID!): EventLog @join__field(graph: SCHEMA)
  getForm(id: ID, name: String): Form @join__field(graph: SCHEMA)
  getGeneralLedgerAccount(code: String, id: ID): GeneralLedgerAccount @join__field(graph: SCHEMA)
  getInterfaceMessageLog(id: ID!): InterfaceMessageLog @join__field(graph: SCHEMA)
  getInventoryHandlingPolicy(id: ID, name: String): InventoryHandlingPolicy @join__field(graph: SCHEMA)
  getInventoryHandlingRule(id: ID!): InventoryHandlingRule @join__field(graph: SCHEMA)
  getInventoryHoldingPolicy(id: ID!): InventoryHoldingPolicy @join__field(graph: SCHEMA)
  getInventoryTransactionsRaw(filter: InventoryTransactionsRawFilter): [InventoryTransaction] @join__field(graph: WMS)
  getJobOrder(id: ID, name: String): JobOrder @join__field(graph: SCHEMA)
  getJobOrderDependency(id: ID!): JobOrderDependency @join__field(graph: SCHEMA)
  getJobOrderNote(id: ID!): JobOrderNote @join__field(graph: SCHEMA)
  getJobResponse(id: ID!): JobResponse @join__field(graph: SCHEMA)
  getLibreService(id: ID, name: String): LibreService @join__field(graph: SCHEMA)
  getMaterialActual(id: ID!): MaterialActual @join__field(graph: SCHEMA)
  getMaterialAlternate(id: ID!): MaterialAlternate @join__field(graph: SCHEMA)
  getMaterialClass(code: String, id: ID): MaterialClass @join__field(graph: SCHEMA)
  getMaterialDefinition(code: String, id: ID): MaterialDefinition @join__field(graph: SCHEMA)
  getMaterialEventRuleset(id: ID!): MaterialEventRuleset @join__field(graph: SCHEMA)
  getMaterialLot(code: String, id: ID): MaterialLot @join__field(graph: SCHEMA)
  getMaterialSpecification(id: ID!): MaterialSpecification @join__field(graph: SCHEMA)
  getMaterialStateModel(id: ID, name: String): MaterialStateModel @join__field(graph: SCHEMA)
  getMaterialStateTransition(id: ID!): MaterialStateTransition @join__field(graph: SCHEMA)
  getMaterialStatus(code: String, id: ID): MaterialStatus @join__field(graph: SCHEMA)
  getMaterialSubLot(code: String, id: ID): MaterialSubLot @join__field(graph: SCHEMA)
  getMaterialUnit(id: ID, serialNumber: String): MaterialUnit @join__field(graph: SCHEMA)
  getMenu(id: ID!): Menu @join__field(graph: SCHEMA)
  getOperationsDefinition(id: ID, name: String): OperationsDefinition @join__field(graph: SCHEMA)
  getOperationsRequest(code: String, id: ID): OperationsRequest @join__field(graph: SCHEMA)
  getOperationsSegment(id: ID!): OperationsSegment @join__field(graph: SCHEMA)
  getOrder(id: ID!): Order @join__field(graph: SCHEMA)
  getOrderLine(id: ID!): OrderLine @join__field(graph: SCHEMA)
  getOrderStartRuleset(id: ID!): OrderStartRuleset @join__field(graph: SCHEMA)
  getPackingReturnInstructionsPDF(input: GetPackingReturnInstructionsPDFInput!): String @join__field(graph: WMS)
  getPackingSlipPDF: String @join__field(graph: WMS)
  getParameterSpecification(id: ID!): ParameterSpecification @join__field(graph: SCHEMA)
  getPartner(id: ID!): Partner @join__field(graph: SCHEMA)
  getPayloadFieldDefinition(id: ID!): PayloadFieldDefinition @join__field(graph: SCHEMA)
  getPerson(id: ID, name: String): Person @join__field(graph: SCHEMA)
  getPersonnelActual(id: ID!): PersonnelActual @join__field(graph: SCHEMA)
  getPersonnelClass(id: ID, name: String): PersonnelClass @join__field(graph: SCHEMA)
  getPersonnelSpecification(id: ID!): PersonnelSpecification @join__field(graph: SCHEMA)
  getProperty(id: ID!): Property @join__field(graph: SCHEMA)
  getPropertyNameAlias(id: ID!): PropertyNameAlias @join__field(graph: SCHEMA)
  getPropertyValueAlias(id: ID!): PropertyValueAlias @join__field(graph: SCHEMA)
  getQuantityLog(id: ID!): QuantityLog @join__field(graph: SCHEMA)
  getReason(id: ID!): Reason @join__field(graph: SCHEMA)
  getReasonCategory(code: String, id: ID): ReasonCategory @join__field(graph: SCHEMA)
  getRequestState(id: ID, name: String): RequestState @join__field(graph: SCHEMA)
  getRole(name: String!): Role @join__field(graph: SCHEMA)
  getSegmentDependency(id: ID!): SegmentDependency @join__field(graph: SCHEMA)
  getSegmentInvoiceSetting(id: ID!): SegmentInvoiceSetting @join__field(graph: SCHEMA)
  getShipment(id: ID!): Shipment @join__field(graph: SCHEMA)
  getShipmentItem(id: ID!): ShipmentItem @join__field(graph: SCHEMA)
  getShippingAccount(id: ID!): ShippingAccount @join__field(graph: SCHEMA)
  getStateEventRuleset(id: ID!): StateEventRuleset @join__field(graph: SCHEMA)
  getStockOnHand(filter: StockOnHandFilter): [StockOnHandOutput] @join__field(graph: WMS)
  getTestResult(id: ID!): TestResult @join__field(graph: SCHEMA)
  getTestSpecification(id: ID!): TestSpecification @join__field(graph: SCHEMA)
  getTransitionEventRuleset(id: ID!): TransitionEventRuleset @join__field(graph: SCHEMA)
  getUnitOfMeasure(code: String, id: ID): UnitOfMeasure @join__field(graph: SCHEMA)
  getUnitOfMeasureConversion(id: ID!): UnitOfMeasureConversion @join__field(graph: SCHEMA)
  getUser(id: ID, username: String): User @join__field(graph: SCHEMA)
  getUserRole(id: ID!): UserRole @join__field(graph: SCHEMA)
  getWorkCalendar(id: ID, name: String): WorkCalendar @join__field(graph: SCHEMA)
  getWorkCalendarDefinitionEntry(id: ID!): WorkCalendarDefinitionEntry @join__field(graph: SCHEMA)
  getWorkCalendarEntry(id: ID!): WorkCalendarEntry @join__field(graph: SCHEMA)
  getWorkflowConnection(id: ID!): WorkflowConnection @join__field(graph: SCHEMA)
  getWorkflowConnectionType(id: ID!): WorkflowConnectionType @join__field(graph: SCHEMA)
  getWorkflowInstance(id: ID!): WorkflowInstance @join__field(graph: SCHEMA)
  getWorkflowInstanceProperty(id: ID, key: String): WorkflowInstanceProperty @join__field(graph: SCHEMA)
  getWorkflowNode(id: ID!): WorkflowNode @join__field(graph: SCHEMA)
  getWorkflowNodeEvent(id: ID!): WorkflowNodeEvent @join__field(graph: SCHEMA)
  getWorkflowNodeInstance(id: ID!): WorkflowNodeInstance @join__field(graph: SCHEMA)
  getWorkflowNodeType(id: ID!): WorkflowNodeType @join__field(graph: SCHEMA)
  getWorkflowProperty(id: ID!): WorkflowProperty @join__field(graph: SCHEMA)
  getWorkflowPropertyInstance(id: ID!): WorkflowPropertyInstance @join__field(graph: SCHEMA)
  getWorkflowPropertyValue(id: ID!): WorkflowPropertyValue @join__field(graph: SCHEMA)
  getWorkflowSpecification(id: ID!): WorkflowSpecification @join__field(graph: SCHEMA)
  queryACL(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  queryAccessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight] @join__field(graph: SCHEMA)
  queryAddress(filter: AddressFilter, first: Int, offset: Int, order: AddressOrder): [Address] @join__field(graph: SCHEMA)
  queryBillOfMaterial(filter: BillOfMaterialFilter, first: Int, offset: Int, order: BillOfMaterialOrder): [BillOfMaterial] @join__field(graph: SCHEMA)
  queryBox(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box] @join__field(graph: SCHEMA)
  queryCarrier(filter: CarrierFilter, first: Int, offset: Int, order: CarrierOrder): [Carrier] @join__field(graph: SCHEMA)
  queryDashboardConfig(filter: DashboardConfigFilter, first: Int, offset: Int, order: DashboardConfigOrder): [DashboardConfig] @join__field(graph: SCHEMA)
  queryDashboardPanelConfig(filter: DashboardPanelConfigFilter, first: Int, offset: Int, order: DashboardPanelConfigOrder): [DashboardPanelConfig] @join__field(graph: SCHEMA)
  queryDashboardWidgetConfigProperty(filter: DashboardWidgetConfigPropertyFilter, first: Int, offset: Int, order: DashboardWidgetConfigPropertyOrder): [DashboardWidgetConfigProperty] @join__field(graph: SCHEMA)
  queryDelivery(filter: DeliveryFilter, first: Int, offset: Int, order: DeliveryOrder): [Delivery] @join__field(graph: SCHEMA)
  queryEquipment(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment] @join__field(graph: SCHEMA)
  queryEquipmentActual(filter: EquipmentActualFilter, first: Int, offset: Int, order: EquipmentActualOrder): [EquipmentActual] @join__field(graph: SCHEMA)
  queryEquipmentClass(filter: EquipmentClassFilter, first: Int, offset: Int, order: EquipmentClassOrder): [EquipmentClass] @join__field(graph: SCHEMA)
  queryEquipmentNameAlias(filter: EquipmentNameAliasFilter, first: Int, offset: Int, order: EquipmentNameAliasOrder): [EquipmentNameAlias] @join__field(graph: SCHEMA)
  queryEquipmentPropertyOverride(filter: EquipmentPropertyOverrideFilter, first: Int, offset: Int, order: EquipmentPropertyOverrideOrder): [EquipmentPropertyOverride] @join__field(graph: SCHEMA)
  queryEquipmentReasonOverride(filter: EquipmentReasonOverrideFilter, first: Int, offset: Int, order: EquipmentReasonOverrideOrder): [EquipmentReasonOverride] @join__field(graph: SCHEMA)
  queryEquipmentRelation(filter: EquipmentRelationFilter, first: Int, offset: Int, order: EquipmentRelationOrder): [EquipmentRelation] @join__field(graph: SCHEMA)
  queryEquipmentSpecification(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification] @join__field(graph: SCHEMA)
  queryEventDefinition(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition] @join__field(graph: SCHEMA)
  queryEventLog(filter: EventLogFilter, first: Int, offset: Int, order: EventLogOrder): [EventLog] @join__field(graph: SCHEMA)
  queryForm(filter: FormFilter, first: Int, offset: Int, order: FormOrder): [Form] @join__field(graph: SCHEMA)
  queryGeneralLedgerAccount(filter: GeneralLedgerAccountFilter, first: Int, offset: Int, order: GeneralLedgerAccountOrder): [GeneralLedgerAccount] @join__field(graph: SCHEMA)
  queryInterfaceMessageLog(filter: InterfaceMessageLogFilter, first: Int, offset: Int, order: InterfaceMessageLogOrder): [InterfaceMessageLog] @join__field(graph: SCHEMA)
  queryInventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter, first: Int, offset: Int, order: InventoryHandlingPolicyOrder): [InventoryHandlingPolicy] @join__field(graph: SCHEMA)
  queryInventoryHandlingRule(filter: InventoryHandlingRuleFilter, first: Int, offset: Int): [InventoryHandlingRule] @join__field(graph: SCHEMA)
  queryInventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter, first: Int, offset: Int, order: InventoryHoldingPolicyOrder): [InventoryHoldingPolicy] @join__field(graph: SCHEMA)
  queryJobOrder(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder] @join__field(graph: SCHEMA)
  queryJobOrderDependency(filter: JobOrderDependencyFilter, first: Int, offset: Int, order: JobOrderDependencyOrder): [JobOrderDependency] @join__field(graph: SCHEMA)
  queryJobOrderDispatchStateModel(filter: JobOrderDispatchStateModelFilter, first: Int, offset: Int): [JobOrderDispatchStateModel] @join__field(graph: SCHEMA)
  queryJobOrderNote(filter: JobOrderNoteFilter, first: Int, offset: Int, order: JobOrderNoteOrder): [JobOrderNote] @join__field(graph: SCHEMA)
  queryJobResponse(filter: JobResponseFilter, first: Int, offset: Int, order: JobResponseOrder): [JobResponse] @join__field(graph: SCHEMA)
  queryLibreService(filter: LibreServiceFilter, first: Int, offset: Int, order: LibreServiceOrder): [LibreService] @join__field(graph: SCHEMA)
  queryMaterialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual] @join__field(graph: SCHEMA)
  queryMaterialAlternate(filter: MaterialAlternateFilter, first: Int, offset: Int, order: MaterialAlternateOrder): [MaterialAlternate] @join__field(graph: SCHEMA)
  queryMaterialClass(filter: MaterialClassFilter, first: Int, offset: Int, order: MaterialClassOrder): [MaterialClass] @join__field(graph: SCHEMA)
  queryMaterialDefinition(filter: MaterialDefinitionFilter, first: Int, offset: Int, order: MaterialDefinitionOrder): [MaterialDefinition] @join__field(graph: SCHEMA)
  queryMaterialEquipment(filter: MaterialEquipmentFilter): [MaterialEquipment] @join__field(graph: WMS)
  queryMaterialEventRuleset(filter: MaterialEventRulesetFilter, first: Int, offset: Int, order: MaterialEventRulesetOrder): [MaterialEventRuleset] @join__field(graph: SCHEMA)
  queryMaterialLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot] @join__field(graph: SCHEMA)
  queryMaterialSpecification(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification] @join__field(graph: SCHEMA)
  queryMaterialStateModel(filter: MaterialStateModelFilter, first: Int, offset: Int, order: MaterialStateModelOrder): [MaterialStateModel] @join__field(graph: SCHEMA)
  queryMaterialStateTransition(filter: MaterialStateTransitionFilter, first: Int, offset: Int): [MaterialStateTransition] @join__field(graph: SCHEMA)
  queryMaterialStatus(filter: MaterialStatusFilter, first: Int, offset: Int, order: MaterialStatusOrder): [MaterialStatus] @join__field(graph: SCHEMA)
  queryMaterialSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot] @join__field(graph: SCHEMA)
  queryMaterialUnit(filter: MaterialUnitFilter, first: Int, offset: Int, order: MaterialUnitOrder): [MaterialUnit] @join__field(graph: SCHEMA)
  queryMenu(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu] @join__field(graph: SCHEMA)
  queryOperationsDefinition(filter: OperationsDefinitionFilter, first: Int, offset: Int, order: OperationsDefinitionOrder): [OperationsDefinition] @join__field(graph: SCHEMA)
  queryOperationsRequest(filter: OperationsRequestFilter, first: Int, offset: Int, order: OperationsRequestOrder): [OperationsRequest] @join__field(graph: SCHEMA)
  queryOperationsSegment(filter: OperationsSegmentFilter, first: Int, offset: Int, order: OperationsSegmentOrder): [OperationsSegment] @join__field(graph: SCHEMA)
  queryOrder(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order] @join__field(graph: SCHEMA)
  queryOrderLine(filter: OrderLineFilter, first: Int, offset: Int, order: OrderLineOrder): [OrderLine] @join__field(graph: SCHEMA)
  queryOrderStartRuleset(filter: OrderStartRulesetFilter, first: Int, offset: Int, order: OrderStartRulesetOrder): [OrderStartRuleset] @join__field(graph: SCHEMA)
  queryParameterSpecification(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification] @join__field(graph: SCHEMA)
  queryPartner(filter: PartnerFilter, first: Int, offset: Int, order: PartnerOrder): [Partner] @join__field(graph: SCHEMA)
  queryPayloadFieldDefinition(filter: PayloadFieldDefinitionFilter, first: Int, offset: Int, order: PayloadFieldDefinitionOrder): [PayloadFieldDefinition] @join__field(graph: SCHEMA)
  queryPerson(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person] @join__field(graph: SCHEMA)
  queryPersonnelActual(filter: PersonnelActualFilter, first: Int, offset: Int, order: PersonnelActualOrder): [PersonnelActual] @join__field(graph: SCHEMA)
  queryPersonnelClass(filter: PersonnelClassFilter, first: Int, offset: Int, order: PersonnelClassOrder): [PersonnelClass] @join__field(graph: SCHEMA)
  queryPersonnelSpecification(filter: PersonnelSpecificationFilter, first: Int, offset: Int, order: PersonnelSpecificationOrder): [PersonnelSpecification] @join__field(graph: SCHEMA)
  queryPlanningSummaryByStateByEquipment(filter: PlanningSummaryFilter!): [[MaterialEquipmentState]] @join__field(graph: WMS)
  queryProperty(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  queryPropertyNameAlias(filter: PropertyNameAliasFilter, first: Int, offset: Int, order: PropertyNameAliasOrder): [PropertyNameAlias] @join__field(graph: SCHEMA)
  queryPropertyValueAlias(filter: PropertyValueAliasFilter, first: Int, offset: Int, order: PropertyValueAliasOrder): [PropertyValueAlias] @join__field(graph: SCHEMA)
  queryQuantityLog(filter: QuantityLogFilter, first: Int, offset: Int, order: QuantityLogOrder): [QuantityLog] @join__field(graph: SCHEMA)
  queryReason(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason] @join__field(graph: SCHEMA)
  queryReasonCategory(filter: ReasonCategoryFilter, first: Int, offset: Int, order: ReasonCategoryOrder): [ReasonCategory] @join__field(graph: SCHEMA)
  queryRequestState(filter: RequestStateFilter, first: Int, offset: Int, order: RequestStateOrder): [RequestState] @join__field(graph: SCHEMA)
  queryRole(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role] @join__field(graph: SCHEMA)
  querySegmentDependency(filter: SegmentDependencyFilter, first: Int, offset: Int, order: SegmentDependencyOrder): [SegmentDependency] @join__field(graph: SCHEMA)
  querySegmentInvoiceSetting(filter: SegmentInvoiceSettingFilter, first: Int, offset: Int, order: SegmentInvoiceSettingOrder): [SegmentInvoiceSetting] @join__field(graph: SCHEMA)
  queryShipment(filter: ShipmentFilter, first: Int, offset: Int, order: ShipmentOrder): [Shipment] @join__field(graph: SCHEMA)
  queryShipmentItem(filter: ShipmentItemFilter, first: Int, offset: Int, order: ShipmentItemOrder): [ShipmentItem] @join__field(graph: SCHEMA)
  queryShippingAccount(filter: ShippingAccountFilter, first: Int, offset: Int, order: ShippingAccountOrder): [ShippingAccount] @join__field(graph: SCHEMA)
  queryStateEventRuleset(filter: StateEventRulesetFilter, first: Int, offset: Int, order: StateEventRulesetOrder): [StateEventRuleset] @join__field(graph: SCHEMA)
  queryTestResult(filter: TestResultFilter, first: Int, offset: Int, order: TestResultOrder): [TestResult] @join__field(graph: SCHEMA)
  queryTestSpecification(filter: TestSpecificationFilter, first: Int, offset: Int, order: TestSpecificationOrder): [TestSpecification] @join__field(graph: SCHEMA)
  queryTransitionEventRuleset(filter: TransitionEventRulesetFilter, first: Int, offset: Int, order: TransitionEventRulesetOrder): [TransitionEventRuleset] @join__field(graph: SCHEMA)
  queryUnitOfMeasure(filter: UnitOfMeasureFilter, first: Int, offset: Int, order: UnitOfMeasureOrder): [UnitOfMeasure] @join__field(graph: SCHEMA)
  queryUnitOfMeasureConversion(filter: UnitOfMeasureConversionFilter, first: Int, offset: Int, order: UnitOfMeasureConversionOrder): [UnitOfMeasureConversion] @join__field(graph: SCHEMA)
  queryUser(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User] @join__field(graph: SCHEMA)
  queryUserRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole] @join__field(graph: SCHEMA)
  queryWorkCalendar(filter: WorkCalendarFilter, first: Int, offset: Int, order: WorkCalendarOrder): [WorkCalendar] @join__field(graph: SCHEMA)
  queryWorkCalendarDefinitionEntry(filter: WorkCalendarDefinitionEntryFilter, first: Int, offset: Int, order: WorkCalendarDefinitionEntryOrder): [WorkCalendarDefinitionEntry] @join__field(graph: SCHEMA)
  queryWorkCalendarEntry(filter: WorkCalendarEntryFilter, first: Int, offset: Int, order: WorkCalendarEntryOrder): [WorkCalendarEntry] @join__field(graph: SCHEMA)
  queryWorkflowConnection(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection] @join__field(graph: SCHEMA)
  queryWorkflowConnectionType(filter: WorkflowConnectionTypeFilter, first: Int, offset: Int, order: WorkflowConnectionTypeOrder): [WorkflowConnectionType] @join__field(graph: SCHEMA)
  queryWorkflowInstance(filter: WorkflowInstanceFilter, first: Int, offset: Int, order: WorkflowInstanceOrder): [WorkflowInstance] @join__field(graph: SCHEMA)
  queryWorkflowInstanceProperty(filter: WorkflowInstancePropertyFilter, first: Int, offset: Int, order: WorkflowInstancePropertyOrder): [WorkflowInstanceProperty] @join__field(graph: SCHEMA)
  queryWorkflowNode(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode] @join__field(graph: SCHEMA)
  queryWorkflowNodeEvent(filter: WorkflowNodeEventFilter, first: Int, offset: Int, order: WorkflowNodeEventOrder): [WorkflowNodeEvent] @join__field(graph: SCHEMA)
  queryWorkflowNodeInstance(filter: WorkflowNodeInstanceFilter, first: Int, offset: Int, order: WorkflowNodeInstanceOrder): [WorkflowNodeInstance] @join__field(graph: SCHEMA)
  queryWorkflowNodeType(filter: WorkflowNodeTypeFilter, first: Int, offset: Int, order: WorkflowNodeTypeOrder): [WorkflowNodeType] @join__field(graph: SCHEMA)
  queryWorkflowProperty(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty] @join__field(graph: SCHEMA)
  queryWorkflowPropertyInstance(filter: WorkflowPropertyInstanceFilter, first: Int, offset: Int, order: WorkflowPropertyInstanceOrder): [WorkflowPropertyInstance] @join__field(graph: SCHEMA)
  queryWorkflowPropertyValue(filter: WorkflowPropertyValueFilter, first: Int, offset: Int, order: WorkflowPropertyValueOrder): [WorkflowPropertyValue] @join__field(graph: SCHEMA)
  queryWorkflowSpecification(filter: WorkflowSpecificationFilter, first: Int, offset: Int, order: WorkflowSpecificationOrder): [WorkflowSpecification] @join__field(graph: SCHEMA)
  validateASN(input: ValidateASNInput!): [ASNStaging] @join__field(graph: WMS)
}

type RawKpi {
  actualProductionTimeSeconds: Int
  quantities: [QuantityLogTs]
}

type Reason
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  category(filter: ReasonCategoryFilter): ReasonCategory @join__field(graph: SCHEMA)
  children(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason] @join__field(graph: SCHEMA)
  childrenAggregate(filter: ReasonFilter): ReasonAggregateResult @join__field(graph: SCHEMA)
  class: ReasonClass! @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  equipmentClass(filter: EquipmentClassFilter): EquipmentClass @join__field(graph: SCHEMA)
  equipmentOverrides(filter: EquipmentReasonOverrideFilter, first: Int, offset: Int, order: EquipmentReasonOverrideOrder): [EquipmentReasonOverride] @join__field(graph: SCHEMA)
  equipmentOverridesAggregate(filter: EquipmentReasonOverrideFilter): EquipmentReasonOverrideAggregateResult @join__field(graph: SCHEMA)
  erpCode: String! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  label: String! @join__field(graph: SCHEMA)
  parent(filter: ReasonFilter): Reason @join__field(graph: SCHEMA)
  standardValue: Float @join__field(graph: SCHEMA)
  text: String! @join__field(graph: SCHEMA)
  valueUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type ReasonAggregateResult {
  count: Int
  erpCodeMax: String
  erpCodeMin: String
  labelMax: String
  labelMin: String
  standardValueAvg: Float
  standardValueMax: Float
  standardValueMin: Float
  standardValueSum: Float
  textMax: String
  textMin: String
}

type ReasonCategory
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  code: String! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  reason(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason] @join__field(graph: SCHEMA)
  reasonAggregate(filter: ReasonFilter): ReasonAggregateResult @join__field(graph: SCHEMA)
  timeCategory: TimeCategory! @join__field(graph: SCHEMA)
}

type ReasonCategoryAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
}

input ReasonCategoryFilter {
  and: [ReasonCategoryFilter]
  code: StringHashFilter
  has: [ReasonCategoryHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ReasonCategoryFilter
  or: [ReasonCategoryFilter]
}

enum ReasonCategoryHasFilter {
  code
  isActive
  reason
  timeCategory
}

input ReasonCategoryOrder {
  asc: ReasonCategoryOrderable
  desc: ReasonCategoryOrderable
  then: ReasonCategoryOrder
}

enum ReasonCategoryOrderable {
  code
}

input ReasonCategoryPatch {
  code: String
  isActive: Boolean
  reason: [ReasonRef]
  timeCategory: TimeCategory
}

input ReasonCategoryRef {
  code: String
  id: ID
  isActive: Boolean
  reason: [ReasonRef]
  timeCategory: TimeCategory
}

enum ReasonClass {
  Scrap
  Time
}

input ReasonClass_hash {
  eq: ReasonClass
  in: [ReasonClass]
}

input ReasonFilter {
  and: [ReasonFilter]
  class: ReasonClass_hash
  erpCode: StringHashFilter
  has: [ReasonHasFilter]
  id: [ID!]
  isActive: Boolean
  label: StringHashFilter
  not: ReasonFilter
  or: [ReasonFilter]
  text: StringHashFilter
}

enum ReasonHasFilter {
  category
  children
  class
  equipment
  equipmentClass
  equipmentOverrides
  erpCode
  isActive
  label
  parent
  standardValue
  text
  valueUoM
}

input ReasonOrder {
  asc: ReasonOrderable
  desc: ReasonOrderable
  then: ReasonOrder
}

enum ReasonOrderable {
  erpCode
  label
  standardValue
  text
}

input ReasonPatch {
  category: ReasonCategoryRef
  children: [ReasonRef]
  class: ReasonClass
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
  erpCode: String
  isActive: Boolean
  label: String
  parent: ReasonRef
  standardValue: Float
  text: String
  valueUoM: UnitOfMeasureRef
}

input ReasonRef {
  category: ReasonCategoryRef
  children: [ReasonRef]
  class: ReasonClass
  equipment: EquipmentRef
  equipmentClass: EquipmentClassRef
  equipmentOverrides: [EquipmentReasonOverrideRef]
  erpCode: String
  id: ID
  isActive: Boolean
  label: String
  parent: ReasonRef
  standardValue: Float
  text: String
  valueUoM: UnitOfMeasureRef
}

input ReceiveInboundShipmentInput {
  inboundQuantity: Int
  materialCode: String
  max: Int
  min: Int
  orderNumber: String
  plannedQuantity: Int!
  sohQty: Int
  status: String
  warehouse: String
}

input ReplayRawDataInput {
  equipment: [String!]!
  fromDateTIme: String!
}

type RequestState
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
}

type RequestStateAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

input RequestStateFilter {
  and: [RequestStateFilter]
  has: [RequestStateHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: RequestStateFilter
  or: [RequestStateFilter]
}

enum RequestStateHasFilter {
  description
  isActive
  name
}

input RequestStateOrder {
  asc: RequestStateOrderable
  desc: RequestStateOrderable
  then: RequestStateOrder
}

enum RequestStateOrderable {
  description
  name
}

input RequestStatePatch {
  description: String
  isActive: Boolean
  name: String
}

input RequestStateRef {
  description: String
  id: ID
  isActive: Boolean
  name: String
}

type Role {
  hasGrantedRights(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  hasGrantedRightsAggregate(filter: AccessRightFilter): AccessRightAggregateResult
  hasMembers(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
  hasMembersAggregate(filter: UserRoleFilter): UserRoleAggregateResult
  isActive: Boolean
  name: String!
  workflowNodes(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode]
  workflowNodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult
}

type RoleAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input RoleFilter {
  and: [RoleFilter]
  has: [RoleHasFilter]
  name: StringHashFilter
  not: RoleFilter
  or: [RoleFilter]
}

enum RoleHasFilter {
  hasGrantedRights
  hasMembers
  isActive
  name
  workflowNodes
}

input RoleOrder {
  asc: RoleOrderable
  desc: RoleOrderable
  then: RoleOrder
}

enum RoleOrderable {
  name
}

input RolePatch {
  hasGrantedRights: [AccessRightRef]
  hasMembers: [UserRoleRef]
  isActive: Boolean
  name: String
  workflowNodes: [WorkflowNodeRef]
}

input RoleRef {
  hasGrantedRights: [AccessRightRef]
  hasMembers: [UserRoleRef]
  isActive: Boolean
  name: String
  workflowNodes: [WorkflowNodeRef]
}

enum RulesetTriggerOption {
  ORDER_END
  ORDER_START
}

"""represents a rate at a timestamp"""
type RunRate {
  rate: Float
  time: DateTime
}

"""the filter required to return the requiredRunRate type"""
input RunRateFilter {
  """the scheduled finish of the job response"""
  ScheduledFinish: DateTime

  """
  the run rate required over the total course of the job response to meet the quantity target
  """
  TargetRunRate: Float
}

"""a summary of the run rate log"""
type RunRateSummary {
  """the average run rate over the course of the job response queried from"""
  avgRunRate: Float

  """the run rate at the time of query"""
  currentRunRate: Float

  """
  the raw run rate log over the course of the job response interpolated to every minute
  """
  interpolatedRunRate: [RunRate]

  """
  the run rate required to reach the job orders target before the scheduled end time.
  requires both targetRunRate and scheduledFinish to be passed through the filter
  """
  requiredRunRate: Float
}

type SegmentDependency
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  condition: String @join__field(graph: SCHEMA)
  dependencyFactor: Float @join__field(graph: SCHEMA)
  dependencyType: DependencyType @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  factorUoM(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
  from(filter: OperationsSegmentFilter): OperationsSegment! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  jobOrderDependencies(filter: JobOrderDependencyFilter, first: Int, offset: Int, order: JobOrderDependencyOrder): [JobOrderDependency] @join__field(graph: SCHEMA)
  jobOrderDependenciesAggregate(filter: JobOrderDependencyFilter): JobOrderDependencyAggregateResult @join__field(graph: SCHEMA)
  to(filter: OperationsSegmentFilter): OperationsSegment! @join__field(graph: SCHEMA)
  transitionEventRuleset(filter: TransitionEventRulesetFilter): TransitionEventRuleset @join__field(graph: SCHEMA)
}

type SegmentDependencyAggregateResult {
  conditionMax: String
  conditionMin: String
  count: Int
  dependencyFactorAvg: Float
  dependencyFactorMax: Float
  dependencyFactorMin: Float
  dependencyFactorSum: Float
  descriptionMax: String
  descriptionMin: String
}

input SegmentDependencyFilter {
  and: [SegmentDependencyFilter]
  has: [SegmentDependencyHasFilter]
  id: [ID!]
  isActive: Boolean
  not: SegmentDependencyFilter
  or: [SegmentDependencyFilter]
}

enum SegmentDependencyHasFilter {
  condition
  dependencyFactor
  dependencyType
  description
  factorUoM
  from
  isActive
  jobOrderDependencies
  to
  transitionEventRuleset
}

input SegmentDependencyOrder {
  asc: SegmentDependencyOrderable
  desc: SegmentDependencyOrderable
  then: SegmentDependencyOrder
}

enum SegmentDependencyOrderable {
  condition
  dependencyFactor
  description
}

input SegmentDependencyPatch {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: OperationsSegmentRef
  isActive: Boolean
  jobOrderDependencies: [JobOrderDependencyRef]
  to: OperationsSegmentRef
  transitionEventRuleset: TransitionEventRulesetRef
}

input SegmentDependencyRef {
  condition: String
  dependencyFactor: Float
  dependencyType: DependencyType
  description: String
  factorUoM: UnitOfMeasureRef
  from: OperationsSegmentRef
  id: ID
  isActive: Boolean
  jobOrderDependencies: [JobOrderDependencyRef]
  to: OperationsSegmentRef
  transitionEventRuleset: TransitionEventRulesetRef
}

type SegmentInvoiceSetting
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  costPerHour: Float @join__field(graph: SCHEMA)
  costPerUnit: Float @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  partner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
}

type SegmentInvoiceSettingAggregateResult {
  costPerHourAvg: Float
  costPerHourMax: Float
  costPerHourMin: Float
  costPerHourSum: Float
  costPerUnitAvg: Float
  costPerUnitMax: Float
  costPerUnitMin: Float
  costPerUnitSum: Float
  count: Int
}

input SegmentInvoiceSettingFilter {
  and: [SegmentInvoiceSettingFilter]
  has: [SegmentInvoiceSettingHasFilter]
  id: [ID!]
  not: SegmentInvoiceSettingFilter
  or: [SegmentInvoiceSettingFilter]
}

enum SegmentInvoiceSettingHasFilter {
  costPerHour
  costPerUnit
  partner
}

input SegmentInvoiceSettingOrder {
  asc: SegmentInvoiceSettingOrderable
  desc: SegmentInvoiceSettingOrderable
  then: SegmentInvoiceSettingOrder
}

enum SegmentInvoiceSettingOrderable {
  costPerHour
  costPerUnit
}

input SegmentInvoiceSettingPatch {
  costPerHour: Float
  costPerUnit: Float
  partner: PartnerRef
}

input SegmentInvoiceSettingRef {
  costPerHour: Float
  costPerUnit: Float
  id: ID
  partner: PartnerRef
}

enum SegmentType {
  EMBED_SUBPROCESS
  SYSTEM_TASK
  USER_TASK
}

"""
A shipment represents a consignment of goods being sent or received into a warehouse
"""
type Shipment
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  consignmentNumber: String @join__field(graph: SCHEMA)
  customerReference: String @join__field(graph: SCHEMA)
  dateTimeCreatedUTC: DateTime @join__field(graph: SCHEMA)
  dateTimeDeliveredUTC: DateTime @join__field(graph: SCHEMA)
  dateTimePackedUTC: DateTime @join__field(graph: SCHEMA)
  dateTimeReceivedUTC: DateTime @join__field(graph: SCHEMA)
  delivered(filter: DeliveryFilter): Delivery @join__field(graph: SCHEMA)
  emailTrackingEnabled: Boolean @join__field(graph: SCHEMA)
  from(filter: AddressFilter): Address @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  items(filter: ShipmentItemFilter, first: Int, offset: Int, order: ShipmentItemOrder): [ShipmentItem] @join__field(graph: SCHEMA)
  itemsAggregate(filter: ShipmentItemFilter): ShipmentItemAggregateResult @join__field(graph: SCHEMA)
  order(filter: OrderFilter): Order! @join__field(graph: SCHEMA)
  packedItems(filter: PackedItemsFilter): [PackedItem] @join__field(graph: WMS)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  reference: String @join__field(graph: SCHEMA)
  status: ShipmentStatus @join__field(graph: SCHEMA)
  to(filter: AddressFilter): Address @join__field(graph: SCHEMA)
  transportCompany: TransportCompany @join__field(graph: SCHEMA)
  transportCompanyProductCode: String @join__field(graph: SCHEMA)
  transportCompanyShipmentId: String @join__field(graph: SCHEMA)
  type: ShipmentType! @join__field(graph: SCHEMA)
  warehouse(filter: EquipmentFilter): Equipment! @join__field(graph: SCHEMA)
}

type ShipmentAggregateResult {
  consignmentNumberMax: String
  consignmentNumberMin: String
  count: Int
  customerReferenceMax: String
  customerReferenceMin: String
  dateTimeCreatedUTCMax: DateTime
  dateTimeCreatedUTCMin: DateTime
  dateTimeDeliveredUTCMax: DateTime
  dateTimeDeliveredUTCMin: DateTime
  dateTimePackedUTCMax: DateTime
  dateTimePackedUTCMin: DateTime
  dateTimeReceivedUTCMax: DateTime
  dateTimeReceivedUTCMin: DateTime
  referenceMax: String
  referenceMin: String
  transportCompanyProductCodeMax: String
  transportCompanyProductCodeMin: String
  transportCompanyShipmentIdMax: String
  transportCompanyShipmentIdMin: String
}

input ShipmentFilter {
  and: [ShipmentFilter]
  consignmentNumber: StringFullTextFilter_StringHashFilter
  dateTimeCreatedUTC: DateTimeFilter
  dateTimeDeliveredUTC: DateTimeFilter
  dateTimePackedUTC: DateTimeFilter
  dateTimeReceivedUTC: DateTimeFilter
  has: [ShipmentHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ShipmentFilter
  or: [ShipmentFilter]
  reference: StringHashFilter_StringRegExpFilter
  status: ShipmentStatus_hash
  type: ShipmentType_hash
}

enum ShipmentHasFilter {
  consignmentNumber
  customerReference
  dateTimeCreatedUTC
  dateTimeDeliveredUTC
  dateTimePackedUTC
  dateTimeReceivedUTC
  delivered
  emailTrackingEnabled
  from
  isActive
  items
  order
  properties
  reference
  status
  to
  transportCompany
  transportCompanyProductCode
  transportCompanyShipmentId
  type
  warehouse
}

"""
A shipment item represents an individual package or line item within the shipment
"""
type ShipmentItem
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  bin(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  box(filter: BoxFilter): Box @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isParcel: Boolean @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition @join__field(graph: SCHEMA)
  packedItems(filter: PackedItemsFilter): [PackedItem] @join__field(graph: WMS)
  packedQty: Int @join__field(graph: WMS)
  plannedQuantity: Int @join__field(graph: SCHEMA)
  shipment(filter: ShipmentFilter): Shipment @join__field(graph: SCHEMA)
  status: ShipmentItemStatus! @join__field(graph: SCHEMA)
  trackingDetailsArticleId: String @join__field(graph: SCHEMA)
  trackingDetailsBarcodeId: String @join__field(graph: SCHEMA)
  trackingDetailsConsignmentId: String @join__field(graph: SCHEMA)
  transportCompanyItemId: String @join__field(graph: SCHEMA)
  transportCompanyItemReference: String @join__field(graph: SCHEMA)
  weightKg: Float @join__field(graph: SCHEMA)
}

type ShipmentItemAggregateResult {
  count: Int
  plannedQuantityAvg: Float
  plannedQuantityMax: Int
  plannedQuantityMin: Int
  plannedQuantitySum: Int
  trackingDetailsArticleIdMax: String
  trackingDetailsArticleIdMin: String
  trackingDetailsBarcodeIdMax: String
  trackingDetailsBarcodeIdMin: String
  trackingDetailsConsignmentIdMax: String
  trackingDetailsConsignmentIdMin: String
  transportCompanyItemIdMax: String
  transportCompanyItemIdMin: String
  transportCompanyItemReferenceMax: String
  transportCompanyItemReferenceMin: String
  weightKgAvg: Float
  weightKgMax: Float
  weightKgMin: Float
  weightKgSum: Float
}

input ShipmentItemFilter {
  and: [ShipmentItemFilter]
  has: [ShipmentItemHasFilter]
  id: [ID!]
  isActive: Boolean
  isParcel: Boolean
  not: ShipmentItemFilter
  or: [ShipmentItemFilter]
  status: ShipmentItemStatus_hash
}

enum ShipmentItemHasFilter {
  bin
  box
  isActive
  isParcel
  material
  plannedQuantity
  shipment
  status
  trackingDetailsArticleId
  trackingDetailsBarcodeId
  trackingDetailsConsignmentId
  transportCompanyItemId
  transportCompanyItemReference
  weightKg
}

input ShipmentItemOrder {
  asc: ShipmentItemOrderable
  desc: ShipmentItemOrderable
  then: ShipmentItemOrder
}

enum ShipmentItemOrderable {
  plannedQuantity
  trackingDetailsArticleId
  trackingDetailsBarcodeId
  trackingDetailsConsignmentId
  transportCompanyItemId
  transportCompanyItemReference
  weightKg
}

input ShipmentItemPatch {
  bin: EquipmentRef
  box: BoxRef
  isActive: Boolean
  isParcel: Boolean
  material: MaterialDefinitionRef
  plannedQuantity: Int
  shipment: ShipmentRef
  status: ShipmentItemStatus
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  transportCompanyItemId: String
  transportCompanyItemReference: String
  weightKg: Float
}

input ShipmentItemRef {
  bin: EquipmentRef
  box: BoxRef
  id: ID
  isActive: Boolean
  isParcel: Boolean
  material: MaterialDefinitionRef
  plannedQuantity: Int
  shipment: ShipmentRef
  status: ShipmentItemStatus
  trackingDetailsArticleId: String
  trackingDetailsBarcodeId: String
  trackingDetailsConsignmentId: String
  transportCompanyItemId: String
  transportCompanyItemReference: String
  weightKg: Float
}

enum ShipmentItemStatus {
  CREATED
  DELETED
  DELIVERED
  PACKED
  SHIPPED
}

input ShipmentItemStatus_hash {
  eq: ShipmentItemStatus
  in: [ShipmentItemStatus]
}

input ShipmentOrder {
  asc: ShipmentOrderable
  desc: ShipmentOrderable
  then: ShipmentOrder
}

enum ShipmentOrderable {
  consignmentNumber
  customerReference
  dateTimeCreatedUTC
  dateTimeDeliveredUTC
  dateTimePackedUTC
  dateTimeReceivedUTC
  reference
  transportCompanyProductCode
  transportCompanyShipmentId
}

input ShipmentPatch {
  consignmentNumber: String
  customerReference: String
  dateTimeCreatedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeReceivedUTC: DateTime
  delivered: DeliveryRef
  emailTrackingEnabled: Boolean
  from: AddressRef
  isActive: Boolean
  items: [ShipmentItemRef]
  order: OrderRef
  properties: [PropertyRef]
  reference: String
  status: ShipmentStatus
  to: AddressRef
  transportCompany: TransportCompany
  transportCompanyProductCode: String
  transportCompanyShipmentId: String
  type: ShipmentType
  warehouse: EquipmentRef
}

input ShipmentRef {
  consignmentNumber: String
  customerReference: String
  dateTimeCreatedUTC: DateTime
  dateTimeDeliveredUTC: DateTime
  dateTimePackedUTC: DateTime
  dateTimeReceivedUTC: DateTime
  delivered: DeliveryRef
  emailTrackingEnabled: Boolean
  from: AddressRef
  id: ID
  isActive: Boolean
  items: [ShipmentItemRef]
  order: OrderRef
  properties: [PropertyRef]
  reference: String
  status: ShipmentStatus
  to: AddressRef
  transportCompany: TransportCompany
  transportCompanyProductCode: String
  transportCompanyShipmentId: String
  type: ShipmentType
  warehouse: EquipmentRef
}

enum ShipmentStatus {
  COMPLETE
  CREATED
  DELIVERED
  PACKED
  RECEIVED
  SHIPPED
  UNPACKED
}

input ShipmentStatus_hash {
  eq: ShipmentStatus
  in: [ShipmentStatus]
}

enum ShipmentType {
  INBOUND
  OUTBOUND
  RETURN
}

input ShipmentType_hash {
  eq: ShipmentType
  in: [ShipmentType]
}

type ShippingAccount
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  accountNumber: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  partner(filter: PartnerFilter): Partner @join__field(graph: SCHEMA)
  secret: String @join__field(graph: SCHEMA)
  transportCompany: TransportCompany @join__field(graph: SCHEMA)
  username: String @join__field(graph: SCHEMA)
  warehouse(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
}

type ShippingAccountAggregateResult {
  accountNumberMax: String
  accountNumberMin: String
  count: Int
  secretMax: String
  secretMin: String
  usernameMax: String
  usernameMin: String
}

input ShippingAccountData {
  Partner: ExtPartnerRef!
  TransportCompany: TransportCompany!
  Warehouse: ExtEquipmentRef!
}

input ShippingAccountFilter {
  and: [ShippingAccountFilter]
  has: [ShippingAccountHasFilter]
  id: [ID!]
  isActive: Boolean
  not: ShippingAccountFilter
  or: [ShippingAccountFilter]
  transportCompany: TransportCompany_hash
}

enum ShippingAccountHasFilter {
  accountNumber
  isActive
  partner
  secret
  transportCompany
  username
  warehouse
}

input ShippingAccountOrder {
  asc: ShippingAccountOrderable
  desc: ShippingAccountOrderable
  then: ShippingAccountOrder
}

enum ShippingAccountOrderable {
  accountNumber
  secret
  username
}

input ShippingAccountPatch {
  accountNumber: String
  isActive: Boolean
  partner: PartnerRef
  secret: String
  transportCompany: TransportCompany
  username: String
  warehouse: EquipmentRef
}

input ShippingAccountRef {
  accountNumber: String
  id: ID
  isActive: Boolean
  partner: PartnerRef
  secret: String
  transportCompany: TransportCompany
  username: String
  warehouse: EquipmentRef
}

type StateEventRuleset {
  eventDefs(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition]
  eventDefsAggregate(filter: EventDefinitionFilter): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segment(filter: OperationsSegmentFilter): OperationsSegment
  targetState: String!
  triggerWhen: [RulesetTriggerOption]
}

type StateEventRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  targetStateMax: String
  targetStateMin: String
}

input StateEventRulesetFilter {
  and: [StateEventRulesetFilter]
  has: [StateEventRulesetHasFilter]
  id: [ID!]
  not: StateEventRulesetFilter
  or: [StateEventRulesetFilter]
}

enum StateEventRulesetHasFilter {
  eventDefs
  name
  segment
  targetState
  triggerWhen
}

input StateEventRulesetOrder {
  asc: StateEventRulesetOrderable
  desc: StateEventRulesetOrderable
  then: StateEventRulesetOrder
}

enum StateEventRulesetOrderable {
  name
  targetState
}

input StateEventRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segment: OperationsSegmentRef
  targetState: String
  triggerWhen: [RulesetTriggerOption]
}

input StateEventRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segment: OperationsSegmentRef
  targetState: String
  triggerWhen: [RulesetTriggerOption]
}

input StateFilter {
  canPack: Boolean
  canReceive: Boolean
  isPlanned: Boolean
}

type StockOnHandDetail {
  name: String
  stock: [InventoryTransaction]
}

input StockOnHandFilter {
  carrier: [ExtCarrierRef]
  from: DateTime
  groupBy: StockOnHandGroupBy
  jobResponse: [ExtJobResponseRef]
  material: [ExtMaterialDefinitionRef]
  materialSubLot: [ExtMaterialSubLotRef]
  maximumStock: Int
  minimumStock: Int
  shipment: [ExtShipmentRef]
  shipmentItem: [ExtShipmentItemRef]
  status: [ExtMaterialStatusRef]
  storageLocation: [ExtEquipmentRef]
  to: DateTime
  warehouse: [ExtEquipmentRef]
}

input StockOnHandGroupBy {
  carrier: Boolean
  jobResponse: Boolean
  material: Boolean
  shipment: Boolean
  status: Boolean
  storageLocation: Boolean
  subLot: Boolean
}

type StockOnHandOutput {
  children: [StockOnHandOutput]
  detail: StockOnHandDetail
  label: String
}

enum StockType {
  NEW_STOCK
  REPAIRED
  RETURNED
}

input StockType_hash {
  eq: StockType
  in: [StockType]
}

input StringExactFilter {
  between: StringRange
  eq: String
  ge: String
  gt: String
  in: [String]
  le: String
  lt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringFullTextFilter_StringHashFilter {
  alloftext: String
  anyoftext: String
  eq: String
  in: [String]
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  in: [String]
  regexp: String
}

input StringRange {
  max: String!
  min: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type TestResult
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  result: String @join__field(graph: SCHEMA)
  testDateTime: DateTime @join__field(graph: SCHEMA)
  uom(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
}

type TestResultAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  resultMax: String
  resultMin: String
  testDateTimeMax: DateTime
  testDateTimeMin: DateTime
}

input TestResultFilter {
  and: [TestResultFilter]
  has: [TestResultHasFilter]
  id: [ID!]
  isActive: Boolean
  not: TestResultFilter
  or: [TestResultFilter]
}

enum TestResultHasFilter {
  description
  isActive
  result
  testDateTime
  uom
}

input TestResultOrder {
  asc: TestResultOrderable
  desc: TestResultOrderable
  then: TestResultOrder
}

enum TestResultOrderable {
  description
  result
  testDateTime
}

input TestResultPatch {
  description: String
  isActive: Boolean
  result: String
  testDateTime: DateTime
  uom: UnitOfMeasureRef
}

input TestResultRef {
  description: String
  id: ID
  isActive: Boolean
  result: String
  testDateTime: DateTime
  uom: UnitOfMeasureRef
}

type TestSpecification
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  description: String @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  version: String @join__field(graph: SCHEMA)
}

type TestSpecificationAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  versionMax: String
  versionMin: String
}

input TestSpecificationFilter {
  and: [TestSpecificationFilter]
  has: [TestSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  not: TestSpecificationFilter
  or: [TestSpecificationFilter]
}

enum TestSpecificationHasFilter {
  description
  isActive
  version
}

input TestSpecificationOrder {
  asc: TestSpecificationOrderable
  desc: TestSpecificationOrderable
  then: TestSpecificationOrder
}

enum TestSpecificationOrderable {
  description
  version
}

input TestSpecificationPatch {
  description: String
  isActive: Boolean
  version: String
}

input TestSpecificationRef {
  description: String
  id: ID
  isActive: Boolean
  version: String
}

"""
Time Category abbreviations are defined in ISO 22400 and are used
to calculate the ISO standard KPI
"""
enum TimeCategory {
  """
  ADET is the actual unit delay times are actual times associated with malfunction-caused interrupts, minor stoppages,
  and other unplanned time intervals that occur while tasks are being completed that lead to unwanted extension
  of the order processing time
  """
  ADET

  """
  ADOT is the actual unit down time is the time when the work unit is not running with orders, although it is available.
  """
  ADOT

  """
  APT is the actual production time is the time during a work unit is producing. It includes only the value-adding functions.
  """
  APT

  """
  AUST is the actual setup time is the time actually consumed for the preparation of an order at a work unit.
  """
  AUST

  """
  PDOT is time, included in the planned operation time, in which the work unit is planned for no operations within the operation time period
  """
  PDOT

  """
  PSDT is the time in which the work unit is planned to be out of operation
  """
  PSDT

  """
  TTR is the time interval during which an item is in a down state due to a failure (IEC 60050-191)
  """
  TTR
}

input TimeRangeFilter {
  from: DateTime
  to: DateTime
}

type TransitionEventRuleset {
  eventDefs(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition]
  eventDefsAggregate(filter: EventDefinitionFilter): EventDefinitionAggregateResult
  id: ID!
  name: String!
  segmentDependency(filter: SegmentDependencyFilter): SegmentDependency
}

type TransitionEventRulesetAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input TransitionEventRulesetFilter {
  and: [TransitionEventRulesetFilter]
  has: [TransitionEventRulesetHasFilter]
  id: [ID!]
  not: TransitionEventRulesetFilter
  or: [TransitionEventRulesetFilter]
}

enum TransitionEventRulesetHasFilter {
  eventDefs
  name
  segmentDependency
}

input TransitionEventRulesetOrder {
  asc: TransitionEventRulesetOrderable
  desc: TransitionEventRulesetOrderable
  then: TransitionEventRulesetOrder
}

enum TransitionEventRulesetOrderable {
  name
}

input TransitionEventRulesetPatch {
  eventDefs: [EventDefinitionRef]
  name: String
  segmentDependency: SegmentDependencyRef
}

input TransitionEventRulesetRef {
  eventDefs: [EventDefinitionRef]
  id: ID
  name: String
  segmentDependency: SegmentDependencyRef
}

enum TransportCompany {
  AUSPOST
  MANUAL
}

input TransportCompany_hash {
  eq: TransportCompany
  in: [TransportCompany]
}

type TransportCompanyDeliveryOrder {
  DeliveryID: String!
  NumberOfShipments: Int
  Shipments: [Shipment]
  Status: String
  TotalCost: Float
  TotalCostExGst: Float
  TotalGst: Float
  TransportCompanyDeliveryID: String!
}

type UnitOfMeasure
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  code: String! @join__field(graph: SCHEMA)
  dataType: DataType @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
}

type UnitOfMeasureAggregateResult {
  codeMax: String
  codeMin: String
  count: Int
}

type UnitOfMeasureConversion
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  denominator: Float! @join__field(graph: SCHEMA)
  fromUoM(filter: UnitOfMeasureFilter): UnitOfMeasure! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  material(filter: MaterialDefinitionFilter): MaterialDefinition! @join__field(graph: SCHEMA)
  numerator: Float! @join__field(graph: SCHEMA)
  toUoM(filter: UnitOfMeasureFilter): UnitOfMeasure! @join__field(graph: SCHEMA)
}

type UnitOfMeasureConversionAggregateResult {
  count: Int
  denominatorAvg: Float
  denominatorMax: Float
  denominatorMin: Float
  denominatorSum: Float
  numeratorAvg: Float
  numeratorMax: Float
  numeratorMin: Float
  numeratorSum: Float
}

input UnitOfMeasureConversionFilter {
  and: [UnitOfMeasureConversionFilter]
  has: [UnitOfMeasureConversionHasFilter]
  id: [ID!]
  isActive: Boolean
  not: UnitOfMeasureConversionFilter
  or: [UnitOfMeasureConversionFilter]
}

enum UnitOfMeasureConversionHasFilter {
  denominator
  fromUoM
  isActive
  material
  numerator
  toUoM
}

input UnitOfMeasureConversionOrder {
  asc: UnitOfMeasureConversionOrderable
  desc: UnitOfMeasureConversionOrderable
  then: UnitOfMeasureConversionOrder
}

enum UnitOfMeasureConversionOrderable {
  denominator
  numerator
}

input UnitOfMeasureConversionPatch {
  denominator: Float
  fromUoM: UnitOfMeasureRef
  isActive: Boolean
  material: MaterialDefinitionRef
  numerator: Float
  toUoM: UnitOfMeasureRef
}

input UnitOfMeasureConversionRef {
  denominator: Float
  fromUoM: UnitOfMeasureRef
  id: ID
  isActive: Boolean
  material: MaterialDefinitionRef
  numerator: Float
  toUoM: UnitOfMeasureRef
}

input UnitOfMeasureFilter {
  and: [UnitOfMeasureFilter]
  code: StringHashFilter
  has: [UnitOfMeasureHasFilter]
  id: [ID!]
  isActive: Boolean
  not: UnitOfMeasureFilter
  or: [UnitOfMeasureFilter]
}

enum UnitOfMeasureHasFilter {
  code
  dataType
  isActive
}

input UnitOfMeasureOrder {
  asc: UnitOfMeasureOrderable
  desc: UnitOfMeasureOrderable
  then: UnitOfMeasureOrder
}

enum UnitOfMeasureOrderable {
  code
}

input UnitOfMeasurePatch {
  code: String
  dataType: DataType
  isActive: Boolean
}

input UnitOfMeasureRef {
  code: String
  dataType: DataType
  id: ID
  isActive: Boolean
}

input UpdateAccessRightInput {
  filter: AccessRightFilter!
  remove: AccessRightPatch
  set: AccessRightPatch
}

type UpdateAccessRightPayload {
  accessRight(filter: AccessRightFilter, first: Int, offset: Int): [AccessRight]
  numUids: Int
}

input UpdateACLInput {
  filter: ACLFilter!
  remove: ACLPatch
  set: ACLPatch
}

type UpdateACLPayload {
  aCL(filter: ACLFilter, first: Int, offset: Int): [ACL]
  numUids: Int
}

input UpdateAddressInput {
  filter: AddressFilter!
  remove: AddressPatch
  set: AddressPatch
}

type UpdateAddressPayload {
  address(filter: AddressFilter, first: Int, offset: Int, order: AddressOrder): [Address]
  numUids: Int
}

input UpdateBillOfMaterialInput {
  filter: BillOfMaterialFilter!
  remove: BillOfMaterialPatch
  set: BillOfMaterialPatch
}

type UpdateBillOfMaterialPayload {
  billOfMaterial(filter: BillOfMaterialFilter, first: Int, offset: Int, order: BillOfMaterialOrder): [BillOfMaterial]
  numUids: Int
}

input UpdateBoxInput {
  filter: BoxFilter!
  remove: BoxPatch
  set: BoxPatch
}

type UpdateBoxPayload {
  box(filter: BoxFilter, first: Int, offset: Int, order: BoxOrder): [Box]
  numUids: Int
}

input UpdateCarrierInput {
  filter: CarrierFilter!
  remove: CarrierPatch
  set: CarrierPatch
}

type UpdateCarrierPayload {
  carrier(filter: CarrierFilter, first: Int, offset: Int, order: CarrierOrder): [Carrier]
  numUids: Int
}

input UpdateDashboardConfigInput {
  filter: DashboardConfigFilter!
  remove: DashboardConfigPatch
  set: DashboardConfigPatch
}

type UpdateDashboardConfigPayload {
  dashboardConfig(filter: DashboardConfigFilter, first: Int, offset: Int, order: DashboardConfigOrder): [DashboardConfig]
  numUids: Int
}

input UpdateDashboardPanelConfigInput {
  filter: DashboardPanelConfigFilter!
  remove: DashboardPanelConfigPatch
  set: DashboardPanelConfigPatch
}

type UpdateDashboardPanelConfigPayload {
  dashboardPanelConfig(filter: DashboardPanelConfigFilter, first: Int, offset: Int, order: DashboardPanelConfigOrder): [DashboardPanelConfig]
  numUids: Int
}

input UpdateDashboardWidgetConfigPropertyInput {
  filter: DashboardWidgetConfigPropertyFilter!
  remove: DashboardWidgetConfigPropertyPatch
  set: DashboardWidgetConfigPropertyPatch
}

type UpdateDashboardWidgetConfigPropertyPayload {
  dashboardWidgetConfigProperty(filter: DashboardWidgetConfigPropertyFilter, first: Int, offset: Int, order: DashboardWidgetConfigPropertyOrder): [DashboardWidgetConfigProperty]
  numUids: Int
}

input UpdateDeliveryInput {
  filter: DeliveryFilter!
  remove: DeliveryPatch
  set: DeliveryPatch
}

type UpdateDeliveryPayload {
  delivery(filter: DeliveryFilter, first: Int, offset: Int, order: DeliveryOrder): [Delivery]
  numUids: Int
}

type UpdatedOrderStatus {
  equipment: Equipment
  eventStartTime: DateTime
  updateType: String
}

input UpdateEquipmentActualInput {
  filter: EquipmentActualFilter!
  remove: EquipmentActualPatch
  set: EquipmentActualPatch
}

type UpdateEquipmentActualPayload {
  equipmentActual(filter: EquipmentActualFilter, first: Int, offset: Int, order: EquipmentActualOrder): [EquipmentActual]
  numUids: Int
}

input UpdateEquipmentClassInput {
  filter: EquipmentClassFilter!
  remove: EquipmentClassPatch
  set: EquipmentClassPatch
}

type UpdateEquipmentClassPayload {
  equipmentClass(filter: EquipmentClassFilter, first: Int, offset: Int, order: EquipmentClassOrder): [EquipmentClass]
  numUids: Int
}

input UpdateEquipmentInput {
  filter: EquipmentFilter!
  remove: EquipmentPatch
  set: EquipmentPatch
}

input UpdateEquipmentNameAliasInput {
  filter: EquipmentNameAliasFilter!
  remove: EquipmentNameAliasPatch
  set: EquipmentNameAliasPatch
}

type UpdateEquipmentNameAliasPayload {
  equipmentNameAlias(filter: EquipmentNameAliasFilter, first: Int, offset: Int, order: EquipmentNameAliasOrder): [EquipmentNameAlias]
  numUids: Int
}

type UpdateEquipmentPayload {
  equipment(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment]
  numUids: Int
}

input UpdateEquipmentPropertyOverrideInput {
  filter: EquipmentPropertyOverrideFilter!
  remove: EquipmentPropertyOverridePatch
  set: EquipmentPropertyOverridePatch
}

type UpdateEquipmentPropertyOverridePayload {
  equipmentPropertyOverride(filter: EquipmentPropertyOverrideFilter, first: Int, offset: Int, order: EquipmentPropertyOverrideOrder): [EquipmentPropertyOverride]
  numUids: Int
}

input UpdateEquipmentReasonOverrideInput {
  filter: EquipmentReasonOverrideFilter!
  remove: EquipmentReasonOverridePatch
  set: EquipmentReasonOverridePatch
}

type UpdateEquipmentReasonOverridePayload {
  equipmentReasonOverride(filter: EquipmentReasonOverrideFilter, first: Int, offset: Int, order: EquipmentReasonOverrideOrder): [EquipmentReasonOverride]
  numUids: Int
}

input UpdateEquipmentRelationInput {
  filter: EquipmentRelationFilter!
  remove: EquipmentRelationPatch
  set: EquipmentRelationPatch
}

type UpdateEquipmentRelationPayload {
  equipmentRelation(filter: EquipmentRelationFilter, first: Int, offset: Int, order: EquipmentRelationOrder): [EquipmentRelation]
  numUids: Int
}

input UpdateEquipmentSpecificationInput {
  filter: EquipmentSpecificationFilter!
  remove: EquipmentSpecificationPatch
  set: EquipmentSpecificationPatch
}

type UpdateEquipmentSpecificationPayload {
  equipmentSpecification(filter: EquipmentSpecificationFilter, first: Int, offset: Int, order: EquipmentSpecificationOrder): [EquipmentSpecification]
  numUids: Int
}

input UpdateEventDefinitionInput {
  filter: EventDefinitionFilter!
  remove: EventDefinitionPatch
  set: EventDefinitionPatch
}

type UpdateEventDefinitionPayload {
  eventDefinition(filter: EventDefinitionFilter, first: Int, offset: Int, order: EventDefinitionOrder): [EventDefinition]
  numUids: Int
}

input UpdateEventLogInput {
  filter: EventLogFilter!
  remove: EventLogPatch
  set: EventLogPatch
}

type UpdateEventLogPayload {
  eventLog(filter: EventLogFilter, first: Int, offset: Int, order: EventLogOrder): [EventLog]
  numUids: Int
}

input UpdateFormInput {
  filter: FormFilter!
  remove: FormPatch
  set: FormPatch
}

type UpdateFormPayload {
  form(filter: FormFilter, first: Int, offset: Int, order: FormOrder): [Form]
  numUids: Int
}

input UpdateGeneralLedgerAccountInput {
  filter: GeneralLedgerAccountFilter!
  remove: GeneralLedgerAccountPatch
  set: GeneralLedgerAccountPatch
}

type UpdateGeneralLedgerAccountPayload {
  generalLedgerAccount(filter: GeneralLedgerAccountFilter, first: Int, offset: Int, order: GeneralLedgerAccountOrder): [GeneralLedgerAccount]
  numUids: Int
}

input UpdateInterfaceMessageLogInput {
  filter: InterfaceMessageLogFilter!
  remove: InterfaceMessageLogPatch
  set: InterfaceMessageLogPatch
}

type UpdateInterfaceMessageLogPayload {
  interfaceMessageLog(filter: InterfaceMessageLogFilter, first: Int, offset: Int, order: InterfaceMessageLogOrder): [InterfaceMessageLog]
  numUids: Int
}

input UpdateInventoryHandlingPolicyInput {
  filter: InventoryHandlingPolicyFilter!
  remove: InventoryHandlingPolicyPatch
  set: InventoryHandlingPolicyPatch
}

type UpdateInventoryHandlingPolicyPayload {
  inventoryHandlingPolicy(filter: InventoryHandlingPolicyFilter, first: Int, offset: Int, order: InventoryHandlingPolicyOrder): [InventoryHandlingPolicy]
  numUids: Int
}

input UpdateInventoryHandlingRuleInput {
  filter: InventoryHandlingRuleFilter!
  remove: InventoryHandlingRulePatch
  set: InventoryHandlingRulePatch
}

type UpdateInventoryHandlingRulePayload {
  inventoryHandlingRule(filter: InventoryHandlingRuleFilter, first: Int, offset: Int): [InventoryHandlingRule]
  numUids: Int
}

input UpdateInventoryHoldingPolicyInput {
  filter: InventoryHoldingPolicyFilter!
  remove: InventoryHoldingPolicyPatch
  set: InventoryHoldingPolicyPatch
}

type UpdateInventoryHoldingPolicyPayload {
  inventoryHoldingPolicy(filter: InventoryHoldingPolicyFilter, first: Int, offset: Int, order: InventoryHoldingPolicyOrder): [InventoryHoldingPolicy]
  numUids: Int
}

input UpdateJobOrderDependencyInput {
  filter: JobOrderDependencyFilter!
  remove: JobOrderDependencyPatch
  set: JobOrderDependencyPatch
}

type UpdateJobOrderDependencyPayload {
  jobOrderDependency(filter: JobOrderDependencyFilter, first: Int, offset: Int, order: JobOrderDependencyOrder): [JobOrderDependency]
  numUids: Int
}

input UpdateJobOrderDispatchStateModelInput {
  filter: JobOrderDispatchStateModelFilter!
  remove: JobOrderDispatchStateModelPatch
  set: JobOrderDispatchStateModelPatch
}

type UpdateJobOrderDispatchStateModelPayload {
  jobOrderDispatchStateModel(filter: JobOrderDispatchStateModelFilter, first: Int, offset: Int): [JobOrderDispatchStateModel]
  numUids: Int
}

input UpdateJobOrderInput {
  filter: JobOrderFilter!
  remove: JobOrderPatch
  set: JobOrderPatch
}

input UpdateJobOrderNoteInput {
  filter: JobOrderNoteFilter!
  remove: JobOrderNotePatch
  set: JobOrderNotePatch
}

type UpdateJobOrderNotePayload {
  jobOrderNote(filter: JobOrderNoteFilter, first: Int, offset: Int, order: JobOrderNoteOrder): [JobOrderNote]
  numUids: Int
}

type UpdateJobOrderPayload {
  jobOrder(filter: JobOrderFilter, first: Int, offset: Int, order: JobOrderOrder): [JobOrder]
  numUids: Int
}

input UpdateJobOrderStatusInput {
  filter: JobOrderFilter!
  set: JobOrderStatusPatch
}

input UpdateJobResponseInput {
  filter: JobResponseFilter!
  remove: JobResponsePatch
  set: JobResponsePatch
}

type UpdateJobResponsePayload {
  jobResponse(filter: JobResponseFilter, first: Int, offset: Int, order: JobResponseOrder): [JobResponse]
  numUids: Int
}

input UpdateLibreServiceInput {
  filter: LibreServiceFilter!
  remove: LibreServicePatch
  set: LibreServicePatch
}

type UpdateLibreServicePayload {
  libreService(filter: LibreServiceFilter, first: Int, offset: Int, order: LibreServiceOrder): [LibreService]
  numUids: Int
}

input UpdateMaterialActualInput {
  filter: MaterialActualFilter!
  remove: MaterialActualPatch
  set: MaterialActualPatch
}

type UpdateMaterialActualPayload {
  materialActual(filter: MaterialActualFilter, first: Int, offset: Int, order: MaterialActualOrder): [MaterialActual]
  numUids: Int
}

input UpdateMaterialAlternateInput {
  filter: MaterialAlternateFilter!
  remove: MaterialAlternatePatch
  set: MaterialAlternatePatch
}

type UpdateMaterialAlternatePayload {
  materialAlternate(filter: MaterialAlternateFilter, first: Int, offset: Int, order: MaterialAlternateOrder): [MaterialAlternate]
  numUids: Int
}

input UpdateMaterialClassInput {
  filter: MaterialClassFilter!
  remove: MaterialClassPatch
  set: MaterialClassPatch
}

type UpdateMaterialClassPayload {
  materialClass(filter: MaterialClassFilter, first: Int, offset: Int, order: MaterialClassOrder): [MaterialClass]
  numUids: Int
}

input UpdateMaterialDefinitionInput {
  filter: MaterialDefinitionFilter!
  remove: MaterialDefinitionPatch
  set: MaterialDefinitionPatch
}

type UpdateMaterialDefinitionPayload {
  materialDefinition(filter: MaterialDefinitionFilter, first: Int, offset: Int, order: MaterialDefinitionOrder): [MaterialDefinition]
  numUids: Int
}

input UpdateMaterialEventRulesetInput {
  filter: MaterialEventRulesetFilter!
  remove: MaterialEventRulesetPatch
  set: MaterialEventRulesetPatch
}

type UpdateMaterialEventRulesetPayload {
  materialEventRuleset(filter: MaterialEventRulesetFilter, first: Int, offset: Int, order: MaterialEventRulesetOrder): [MaterialEventRuleset]
  numUids: Int
}

input UpdateMaterialLotInput {
  filter: MaterialLotFilter!
  remove: MaterialLotPatch
  set: MaterialLotPatch
}

type UpdateMaterialLotPayload {
  materialLot(filter: MaterialLotFilter, first: Int, offset: Int, order: MaterialLotOrder): [MaterialLot]
  numUids: Int
}

input UpdateMaterialSpecificationInput {
  filter: MaterialSpecificationFilter!
  remove: MaterialSpecificationPatch
  set: MaterialSpecificationPatch
}

type UpdateMaterialSpecificationPayload {
  materialSpecification(filter: MaterialSpecificationFilter, first: Int, offset: Int, order: MaterialSpecificationOrder): [MaterialSpecification]
  numUids: Int
}

input UpdateMaterialStateModelInput {
  filter: MaterialStateModelFilter!
  remove: MaterialStateModelPatch
  set: MaterialStateModelPatch
}

type UpdateMaterialStateModelPayload {
  materialStateModel(filter: MaterialStateModelFilter, first: Int, offset: Int, order: MaterialStateModelOrder): [MaterialStateModel]
  numUids: Int
}

input UpdateMaterialStateTransitionInput {
  filter: MaterialStateTransitionFilter!
  remove: MaterialStateTransitionPatch
  set: MaterialStateTransitionPatch
}

type UpdateMaterialStateTransitionPayload {
  materialStateTransition(filter: MaterialStateTransitionFilter, first: Int, offset: Int): [MaterialStateTransition]
  numUids: Int
}

input UpdateMaterialStatusInput {
  filter: MaterialStatusFilter!
  remove: MaterialStatusPatch
  set: MaterialStatusPatch
}

type UpdateMaterialStatusPayload {
  materialStatus(filter: MaterialStatusFilter, first: Int, offset: Int, order: MaterialStatusOrder): [MaterialStatus]
  numUids: Int
}

input UpdateMaterialSubLotInput {
  filter: MaterialSubLotFilter!
  remove: MaterialSubLotPatch
  set: MaterialSubLotPatch
}

type UpdateMaterialSubLotPayload {
  materialSubLot(filter: MaterialSubLotFilter, first: Int, offset: Int, order: MaterialSubLotOrder): [MaterialSubLot]
  numUids: Int
}

input UpdateMaterialUnitInput {
  filter: MaterialUnitFilter!
  remove: MaterialUnitPatch
  set: MaterialUnitPatch
}

type UpdateMaterialUnitPayload {
  materialUnit(filter: MaterialUnitFilter, first: Int, offset: Int, order: MaterialUnitOrder): [MaterialUnit]
  numUids: Int
}

input UpdateMenuInput {
  filter: MenuFilter!
  remove: MenuPatch
  set: MenuPatch
}

type UpdateMenuPayload {
  menu(filter: MenuFilter, first: Int, offset: Int, order: MenuOrder): [Menu]
  numUids: Int
}

input UpdateOperationsDefinitionInput {
  filter: OperationsDefinitionFilter!
  remove: OperationsDefinitionPatch
  set: OperationsDefinitionPatch
}

type UpdateOperationsDefinitionPayload {
  numUids: Int
  operationsDefinition(filter: OperationsDefinitionFilter, first: Int, offset: Int, order: OperationsDefinitionOrder): [OperationsDefinition]
}

input UpdateOperationsRequestInput {
  filter: OperationsRequestFilter!
  remove: OperationsRequestPatch
  set: OperationsRequestPatch
}

type UpdateOperationsRequestPayload {
  numUids: Int
  operationsRequest(filter: OperationsRequestFilter, first: Int, offset: Int, order: OperationsRequestOrder): [OperationsRequest]
}

input UpdateOperationsSegmentInput {
  filter: OperationsSegmentFilter!
  remove: OperationsSegmentPatch
  set: OperationsSegmentPatch
}

type UpdateOperationsSegmentPayload {
  numUids: Int
  operationsSegment(filter: OperationsSegmentFilter, first: Int, offset: Int, order: OperationsSegmentOrder): [OperationsSegment]
}

input UpdateOrderInput {
  filter: OrderFilter!
  remove: OrderPatch
  set: OrderPatch
}

input UpdateOrderLineInput {
  filter: OrderLineFilter!
  remove: OrderLinePatch
  set: OrderLinePatch
}

type UpdateOrderLinePayload {
  numUids: Int
  orderLine(filter: OrderLineFilter, first: Int, offset: Int, order: OrderLineOrder): [OrderLine]
}

type UpdateOrderPayload {
  numUids: Int
  order(filter: OrderFilter, first: Int, offset: Int, order: OrderOrder): [Order]
}

input UpdateOrderStartRulesetInput {
  filter: OrderStartRulesetFilter!
  remove: OrderStartRulesetPatch
  set: OrderStartRulesetPatch
}

type UpdateOrderStartRulesetPayload {
  numUids: Int
  orderStartRuleset(filter: OrderStartRulesetFilter, first: Int, offset: Int, order: OrderStartRulesetOrder): [OrderStartRuleset]
}

input UpdateOrderStatusInput {
  equipment: ExtEquipmentRef!
  eventStartTime: DateTime!
  updateType: String!
}

input UpdateParameterSpecificationInput {
  filter: ParameterSpecificationFilter!
  remove: ParameterSpecificationPatch
  set: ParameterSpecificationPatch
}

type UpdateParameterSpecificationPayload {
  numUids: Int
  parameterSpecification(filter: ParameterSpecificationFilter, first: Int, offset: Int, order: ParameterSpecificationOrder): [ParameterSpecification]
}

input UpdatePartnerInput {
  filter: PartnerFilter!
  remove: PartnerPatch
  set: PartnerPatch
}

type UpdatePartnerPayload {
  numUids: Int
  partner(filter: PartnerFilter, first: Int, offset: Int, order: PartnerOrder): [Partner]
}

input UpdatePayloadFieldDefinitionInput {
  filter: PayloadFieldDefinitionFilter!
  remove: PayloadFieldDefinitionPatch
  set: PayloadFieldDefinitionPatch
}

type UpdatePayloadFieldDefinitionPayload {
  numUids: Int
  payloadFieldDefinition(filter: PayloadFieldDefinitionFilter, first: Int, offset: Int, order: PayloadFieldDefinitionOrder): [PayloadFieldDefinition]
}

input UpdatePersonInput {
  filter: PersonFilter!
  remove: PersonPatch
  set: PersonPatch
}

input UpdatePersonnelActualInput {
  filter: PersonnelActualFilter!
  remove: PersonnelActualPatch
  set: PersonnelActualPatch
}

type UpdatePersonnelActualPayload {
  numUids: Int
  personnelActual(filter: PersonnelActualFilter, first: Int, offset: Int, order: PersonnelActualOrder): [PersonnelActual]
}

input UpdatePersonnelClassInput {
  filter: PersonnelClassFilter!
  remove: PersonnelClassPatch
  set: PersonnelClassPatch
}

type UpdatePersonnelClassPayload {
  numUids: Int
  personnelClass(filter: PersonnelClassFilter, first: Int, offset: Int, order: PersonnelClassOrder): [PersonnelClass]
}

input UpdatePersonnelSpecificationInput {
  filter: PersonnelSpecificationFilter!
  remove: PersonnelSpecificationPatch
  set: PersonnelSpecificationPatch
}

type UpdatePersonnelSpecificationPayload {
  numUids: Int
  personnelSpecification(filter: PersonnelSpecificationFilter, first: Int, offset: Int, order: PersonnelSpecificationOrder): [PersonnelSpecification]
}

type UpdatePersonPayload {
  numUids: Int
  person(filter: PersonFilter, first: Int, offset: Int, order: PersonOrder): [Person]
}

input UpdatePropertyInput {
  filter: PropertyFilter!
  remove: PropertyPatch
  set: PropertyPatch
}

input UpdatePropertyNameAliasInput {
  filter: PropertyNameAliasFilter!
  remove: PropertyNameAliasPatch
  set: PropertyNameAliasPatch
}

type UpdatePropertyNameAliasPayload {
  numUids: Int
  propertyNameAlias(filter: PropertyNameAliasFilter, first: Int, offset: Int, order: PropertyNameAliasOrder): [PropertyNameAlias]
}

type UpdatePropertyPayload {
  numUids: Int
  property(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property]
}

input UpdatePropertyValueAliasInput {
  filter: PropertyValueAliasFilter!
  remove: PropertyValueAliasPatch
  set: PropertyValueAliasPatch
}

type UpdatePropertyValueAliasPayload {
  numUids: Int
  propertyValueAlias(filter: PropertyValueAliasFilter, first: Int, offset: Int, order: PropertyValueAliasOrder): [PropertyValueAlias]
}

input UpdateQuantityLogInput {
  filter: QuantityLogFilter!
  remove: QuantityLogPatch
  set: QuantityLogPatch
}

type UpdateQuantityLogPayload {
  numUids: Int
  quantityLog(filter: QuantityLogFilter, first: Int, offset: Int, order: QuantityLogOrder): [QuantityLog]
}

input UpdateReasonCategoryInput {
  filter: ReasonCategoryFilter!
  remove: ReasonCategoryPatch
  set: ReasonCategoryPatch
}

type UpdateReasonCategoryPayload {
  numUids: Int
  reasonCategory(filter: ReasonCategoryFilter, first: Int, offset: Int, order: ReasonCategoryOrder): [ReasonCategory]
}

input UpdateReasonInput {
  filter: ReasonFilter!
  remove: ReasonPatch
  set: ReasonPatch
}

type UpdateReasonPayload {
  numUids: Int
  reason(filter: ReasonFilter, first: Int, offset: Int, order: ReasonOrder): [Reason]
}

input UpdateRequestStateInput {
  filter: RequestStateFilter!
  remove: RequestStatePatch
  set: RequestStatePatch
}

type UpdateRequestStatePayload {
  numUids: Int
  requestState(filter: RequestStateFilter, first: Int, offset: Int, order: RequestStateOrder): [RequestState]
}

input UpdateRoleInput {
  filter: RoleFilter!
  remove: RolePatch
  set: RolePatch
}

type UpdateRolePayload {
  numUids: Int
  role(filter: RoleFilter, first: Int, offset: Int, order: RoleOrder): [Role]
}

input UpdateSegmentDependencyInput {
  filter: SegmentDependencyFilter!
  remove: SegmentDependencyPatch
  set: SegmentDependencyPatch
}

type UpdateSegmentDependencyPayload {
  numUids: Int
  segmentDependency(filter: SegmentDependencyFilter, first: Int, offset: Int, order: SegmentDependencyOrder): [SegmentDependency]
}

input UpdateSegmentInvoiceSettingInput {
  filter: SegmentInvoiceSettingFilter!
  remove: SegmentInvoiceSettingPatch
  set: SegmentInvoiceSettingPatch
}

type UpdateSegmentInvoiceSettingPayload {
  numUids: Int
  segmentInvoiceSetting(filter: SegmentInvoiceSettingFilter, first: Int, offset: Int, order: SegmentInvoiceSettingOrder): [SegmentInvoiceSetting]
}

input UpdateShipmentInput {
  filter: ShipmentFilter!
  remove: ShipmentPatch
  set: ShipmentPatch
}

input UpdateShipmentItemInput {
  filter: ShipmentItemFilter!
  remove: ShipmentItemPatch
  set: ShipmentItemPatch
}

type UpdateShipmentItemPayload {
  numUids: Int
  shipmentItem(filter: ShipmentItemFilter, first: Int, offset: Int, order: ShipmentItemOrder): [ShipmentItem]
}

type UpdateShipmentPayload {
  numUids: Int
  shipment(filter: ShipmentFilter, first: Int, offset: Int, order: ShipmentOrder): [Shipment]
}

input UpdateShippingAccountInput {
  filter: ShippingAccountFilter!
  remove: ShippingAccountPatch
  set: ShippingAccountPatch
}

type UpdateShippingAccountPayload {
  numUids: Int
  shippingAccount(filter: ShippingAccountFilter, first: Int, offset: Int, order: ShippingAccountOrder): [ShippingAccount]
}

input UpdateStateEventRulesetInput {
  filter: StateEventRulesetFilter!
  remove: StateEventRulesetPatch
  set: StateEventRulesetPatch
}

type UpdateStateEventRulesetPayload {
  numUids: Int
  stateEventRuleset(filter: StateEventRulesetFilter, first: Int, offset: Int, order: StateEventRulesetOrder): [StateEventRuleset]
}

input UpdateTestResultInput {
  filter: TestResultFilter!
  remove: TestResultPatch
  set: TestResultPatch
}

type UpdateTestResultPayload {
  numUids: Int
  testResult(filter: TestResultFilter, first: Int, offset: Int, order: TestResultOrder): [TestResult]
}

input UpdateTestSpecificationInput {
  filter: TestSpecificationFilter!
  remove: TestSpecificationPatch
  set: TestSpecificationPatch
}

type UpdateTestSpecificationPayload {
  numUids: Int
  testSpecification(filter: TestSpecificationFilter, first: Int, offset: Int, order: TestSpecificationOrder): [TestSpecification]
}

input UpdateTransitionEventRulesetInput {
  filter: TransitionEventRulesetFilter!
  remove: TransitionEventRulesetPatch
  set: TransitionEventRulesetPatch
}

type UpdateTransitionEventRulesetPayload {
  numUids: Int
  transitionEventRuleset(filter: TransitionEventRulesetFilter, first: Int, offset: Int, order: TransitionEventRulesetOrder): [TransitionEventRuleset]
}

input UpdateUnitOfMeasureConversionInput {
  filter: UnitOfMeasureConversionFilter!
  remove: UnitOfMeasureConversionPatch
  set: UnitOfMeasureConversionPatch
}

type UpdateUnitOfMeasureConversionPayload {
  numUids: Int
  unitOfMeasureConversion(filter: UnitOfMeasureConversionFilter, first: Int, offset: Int, order: UnitOfMeasureConversionOrder): [UnitOfMeasureConversion]
}

input UpdateUnitOfMeasureInput {
  filter: UnitOfMeasureFilter!
  remove: UnitOfMeasurePatch
  set: UnitOfMeasurePatch
}

type UpdateUnitOfMeasurePayload {
  numUids: Int
  unitOfMeasure(filter: UnitOfMeasureFilter, first: Int, offset: Int, order: UnitOfMeasureOrder): [UnitOfMeasure]
}

input UpdateUserInput {
  filter: UserFilter!
  remove: UserPatch
  set: UserPatch
}

type UpdateUserPayload {
  numUids: Int
  user(filter: UserFilter, first: Int, offset: Int, order: UserOrder): [User]
}

input UpdateUserRoleInput {
  filter: UserRoleFilter!
  remove: UserRolePatch
  set: UserRolePatch
}

type UpdateUserRolePayload {
  numUids: Int
  userRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole]
}

input UpdateWorkCalendarDefinitionEntryInput {
  filter: WorkCalendarDefinitionEntryFilter!
  remove: WorkCalendarDefinitionEntryPatch
  set: WorkCalendarDefinitionEntryPatch
}

type UpdateWorkCalendarDefinitionEntryPayload {
  numUids: Int
  workCalendarDefinitionEntry(filter: WorkCalendarDefinitionEntryFilter, first: Int, offset: Int, order: WorkCalendarDefinitionEntryOrder): [WorkCalendarDefinitionEntry]
}

input UpdateWorkCalendarEntryInput {
  filter: WorkCalendarEntryFilter!
  remove: WorkCalendarEntryPatch
  set: WorkCalendarEntryPatch
}

type UpdateWorkCalendarEntryPayload {
  numUids: Int
  workCalendarEntry(filter: WorkCalendarEntryFilter, first: Int, offset: Int, order: WorkCalendarEntryOrder): [WorkCalendarEntry]
}

input UpdateWorkCalendarInput {
  filter: WorkCalendarFilter!
  remove: WorkCalendarPatch
  set: WorkCalendarPatch
}

type UpdateWorkCalendarPayload {
  numUids: Int
  workCalendar(filter: WorkCalendarFilter, first: Int, offset: Int, order: WorkCalendarOrder): [WorkCalendar]
}

input UpdateWorkflowConnectionInput {
  filter: WorkflowConnectionFilter!
  remove: WorkflowConnectionPatch
  set: WorkflowConnectionPatch
}

type UpdateWorkflowConnectionPayload {
  numUids: Int
  workflowConnection(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection]
}

input UpdateWorkflowConnectionTypeInput {
  filter: WorkflowConnectionTypeFilter!
  remove: WorkflowConnectionTypePatch
  set: WorkflowConnectionTypePatch
}

type UpdateWorkflowConnectionTypePayload {
  numUids: Int
  workflowConnectionType(filter: WorkflowConnectionTypeFilter, first: Int, offset: Int, order: WorkflowConnectionTypeOrder): [WorkflowConnectionType]
}

input UpdateWorkflowInstanceInput {
  filter: WorkflowInstanceFilter!
  remove: WorkflowInstancePatch
  set: WorkflowInstancePatch
}

type UpdateWorkflowInstancePayload {
  numUids: Int
  workflowInstance(filter: WorkflowInstanceFilter, first: Int, offset: Int, order: WorkflowInstanceOrder): [WorkflowInstance]
}

input UpdateWorkflowInstancePropertyInput {
  filter: WorkflowInstancePropertyFilter!
  remove: WorkflowInstancePropertyPatch
  set: WorkflowInstancePropertyPatch
}

type UpdateWorkflowInstancePropertyPayload {
  numUids: Int
  workflowInstanceProperty(filter: WorkflowInstancePropertyFilter, first: Int, offset: Int, order: WorkflowInstancePropertyOrder): [WorkflowInstanceProperty]
}

input UpdateWorkflowNodeEventInput {
  filter: WorkflowNodeEventFilter!
  remove: WorkflowNodeEventPatch
  set: WorkflowNodeEventPatch
}

type UpdateWorkflowNodeEventPayload {
  numUids: Int
  workflowNodeEvent(filter: WorkflowNodeEventFilter, first: Int, offset: Int, order: WorkflowNodeEventOrder): [WorkflowNodeEvent]
}

input UpdateWorkflowNodeInput {
  filter: WorkflowNodeFilter!
  remove: WorkflowNodePatch
  set: WorkflowNodePatch
}

input UpdateWorkflowNodeInstanceInput {
  filter: WorkflowNodeInstanceFilter!
  remove: WorkflowNodeInstancePatch
  set: WorkflowNodeInstancePatch
}

type UpdateWorkflowNodeInstancePayload {
  numUids: Int
  workflowNodeInstance(filter: WorkflowNodeInstanceFilter, first: Int, offset: Int, order: WorkflowNodeInstanceOrder): [WorkflowNodeInstance]
}

type UpdateWorkflowNodePayload {
  numUids: Int
  workflowNode(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode]
}

input UpdateWorkflowNodeTypeInput {
  filter: WorkflowNodeTypeFilter!
  remove: WorkflowNodeTypePatch
  set: WorkflowNodeTypePatch
}

type UpdateWorkflowNodeTypePayload {
  numUids: Int
  workflowNodeType(filter: WorkflowNodeTypeFilter, first: Int, offset: Int, order: WorkflowNodeTypeOrder): [WorkflowNodeType]
}

input UpdateWorkflowPropertyInput {
  filter: WorkflowPropertyFilter!
  remove: WorkflowPropertyPatch
  set: WorkflowPropertyPatch
}

input UpdateWorkflowPropertyInstanceInput {
  filter: WorkflowPropertyInstanceFilter!
  remove: WorkflowPropertyInstancePatch
  set: WorkflowPropertyInstancePatch
}

type UpdateWorkflowPropertyInstancePayload {
  numUids: Int
  workflowPropertyInstance(filter: WorkflowPropertyInstanceFilter, first: Int, offset: Int, order: WorkflowPropertyInstanceOrder): [WorkflowPropertyInstance]
}

type UpdateWorkflowPropertyPayload {
  numUids: Int
  workflowProperty(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty]
}

input UpdateWorkflowPropertyValueInput {
  filter: WorkflowPropertyValueFilter!
  remove: WorkflowPropertyValuePatch
  set: WorkflowPropertyValuePatch
}

type UpdateWorkflowPropertyValuePayload {
  numUids: Int
  workflowPropertyValue(filter: WorkflowPropertyValueFilter, first: Int, offset: Int, order: WorkflowPropertyValueOrder): [WorkflowPropertyValue]
}

input UpdateWorkflowSpecificationInput {
  filter: WorkflowSpecificationFilter!
  remove: WorkflowSpecificationPatch
  set: WorkflowSpecificationPatch
}

type UpdateWorkflowSpecificationPayload {
  numUids: Int
  workflowSpecification(filter: WorkflowSpecificationFilter, first: Int, offset: Int, order: WorkflowSpecificationOrder): [WorkflowSpecification]
}

input UpdateWorkflowTaskInput {
  properties: [ExtWorkflowPropertyRef]
  status: String!
  task: ExtWorkflowNodeInstanceRef!
  user: CoreUserRef!
}

input UploadScheduleInput {
  begin: DateTime
  end: DateTime
  matNo: String
  orderNo: String
  workCenter: String
}

type UploadScheduleRowValidation {
  begin: DateTime
  end: DateTime
  errList: [String]
  isValid: Boolean
  materialNo: String
  orderNo: String
  workCenter: String
}

type UploadScheduleStaging {
  jobOrderStagings: [JobOrderStaging]
  operationsRequestStagings: [OperationsRequestStaging]
  rowValidations: [UploadScheduleRowValidation]
}

input UploadStagedScheduleInput {
  jobOrderStagings: [JobOrderStagingInput]
  operationsRequestStagings: [OperationsRequestStagingInput]
}

type UploadStagedScheduleOutput {
  jobOrders: [JobOrder]
  operationsRequest: [OperationsRequest]
}

type User
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: WMS, key: "id")
{
  hasRole(filter: UserRoleFilter, first: Int, offset: Int): [UserRole] @join__field(graph: SCHEMA)
  hasRoleAggregate(filter: UserRoleFilter): UserRoleAggregateResult @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isType: UserType! @join__field(graph: SCHEMA)
  name: String @join__field(graph: SCHEMA)
  tasks(filter: WorkflowNodeInstanceFilter, first: Int, offset: Int, order: WorkflowNodeInstanceOrder): [WorkflowNodeInstance] @join__field(graph: SCHEMA)
  tasksAggregate(filter: WorkflowNodeInstanceFilter): WorkflowNodeInstanceAggregateResult @join__field(graph: SCHEMA)
  username: String! @join__field(graph: SCHEMA)
}

type UserAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
  usernameMax: String
  usernameMin: String
}

input UserFilter {
  and: [UserFilter]
  has: [UserHasFilter]
  id: [ID!]
  isType: UserType_hash
  not: UserFilter
  or: [UserFilter]
  username: StringHashFilter
}

enum UserHasFilter {
  hasRole
  isActive
  isType
  name
  tasks
  username
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  name
  username
}

input UserPatch {
  hasRole: [UserRoleRef]
  isActive: Boolean
  isType: UserType
  name: String
  tasks: [WorkflowNodeInstanceRef]
  username: String
}

input UserRef {
  hasRole: [UserRoleRef]
  id: ID
  isActive: Boolean
  isType: UserType
  name: String
  tasks: [WorkflowNodeInstanceRef]
  username: String
}

type UserRole {
  id: ID!
  isActive: Boolean
  responsibilities(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment]!
  responsibilitiesAggregate(filter: EquipmentFilter): EquipmentAggregateResult
  role(filter: RoleFilter): Role!
  user(filter: UserFilter): User!
}

type UserRoleAggregateResult {
  count: Int
}

input UserRoleFilter {
  and: [UserRoleFilter]
  has: [UserRoleHasFilter]
  id: [ID!]
  not: UserRoleFilter
  or: [UserRoleFilter]
}

enum UserRoleHasFilter {
  isActive
  responsibilities
  role
  user
}

input UserRolePatch {
  isActive: Boolean
  responsibilities: [EquipmentRef]
  role: RoleRef
  user: UserRef
}

input UserRoleRef {
  id: ID
  isActive: Boolean
  responsibilities: [EquipmentRef]
  role: RoleRef
  user: UserRef
}

enum UserType {
  ADMIN
  USER
}

input UserType_hash {
  eq: UserType
  in: [UserType]
}

input ValidateASNInput {
  asnStagingInput: [ASNStagingInput!]!
  site: ExtEquipmentRef!
}

enum Weekday {
  FR
  MO
  SA
  SU
  TH
  TU
  WE
}

input WithinFilter {
  polygon: PolygonRef!
}

type WorkCalendar
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  definition(filter: WorkCalendarDefinitionEntryFilter, first: Int, offset: Int, order: WorkCalendarDefinitionEntryOrder): [WorkCalendarDefinitionEntry] @join__field(graph: SCHEMA)
  definitionAggregate(filter: WorkCalendarDefinitionEntryFilter): WorkCalendarDefinitionEntryAggregateResult @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  entries(filter: WorkCalendarEntryFilter, first: Int, offset: Int, order: WorkCalendarEntryOrder): [WorkCalendarEntry] @join__field(graph: SCHEMA)
  entriesAggregate(filter: WorkCalendarEntryFilter): WorkCalendarEntryAggregateResult @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter, first: Int, offset: Int, order: EquipmentOrder): [Equipment] @join__field(graph: SCHEMA)
  equipmentAggregate(filter: EquipmentFilter): EquipmentAggregateResult @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
}

type WorkCalendarAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  nameMax: String
  nameMin: String
}

"""
Work Calendar domain describes the definition of shift patterns and non-working days
The Work Calendar Definition defines the rule used to determine work calendar entries.
It contains the recurrence time for the rule, the duration of the entry, the entry type, and properties associated with the entry.
Standard Entry Types include Working Time and Non-Working Time. The entry may include property definitions.
The definition uses the rrule.js library to generate calendar events, and the fields available match
the configuration fields required by rrule.js
"""
type WorkCalendarDefinitionEntry
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  byHour: [Int] @join__field(graph: SCHEMA)
  byMinute: [Int] @join__field(graph: SCHEMA)
  byMonth: [Int] @join__field(graph: SCHEMA)
  byMonthDay: [Int] @join__field(graph: SCHEMA)
  bySecond: [Int] @join__field(graph: SCHEMA)
  bySetPos: [Int] @join__field(graph: SCHEMA)
  byWeekDay: [Weekday] @join__field(graph: SCHEMA)
  byWeekNo: [Int] @join__field(graph: SCHEMA)
  byYearDay: [Int] @join__field(graph: SCHEMA)
  calendarEntries(filter: WorkCalendarEntryFilter, first: Int, offset: Int, order: WorkCalendarEntryOrder): [WorkCalendarEntry] @join__field(graph: SCHEMA)
  calendarEntriesAggregate(filter: WorkCalendarEntryFilter): WorkCalendarEntryAggregateResult @join__field(graph: SCHEMA)
  count: Int @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  duration: String @join__field(graph: SCHEMA)
  endDateTime: DateTime @join__field(graph: SCHEMA)
  entryType: WorkCalendarEntryType! @join__field(graph: SCHEMA)
  freq: Frequency! @join__field(graph: SCHEMA)
  hierarchyScope(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  interval: Int @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  startDateTime: DateTime! @join__field(graph: SCHEMA)
  wkst: Weekday @join__field(graph: SCHEMA)
  workCalendar(filter: WorkCalendarFilter): WorkCalendar @join__field(graph: SCHEMA)
}

type WorkCalendarDefinitionEntryAggregateResult {
  count: Int
  countAvg: Float
  countMax: Int
  countMin: Int
  countSum: Int
  descriptionMax: String
  descriptionMin: String
  durationMax: String
  durationMin: String
  endDateTimeMax: DateTime
  endDateTimeMin: DateTime
  intervalAvg: Float
  intervalMax: Int
  intervalMin: Int
  intervalSum: Int
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input WorkCalendarDefinitionEntryFilter {
  and: [WorkCalendarDefinitionEntryFilter]
  has: [WorkCalendarDefinitionEntryHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkCalendarDefinitionEntryFilter
  or: [WorkCalendarDefinitionEntryFilter]
}

enum WorkCalendarDefinitionEntryHasFilter {
  byHour
  byMinute
  byMonth
  byMonthDay
  bySecond
  bySetPos
  byWeekDay
  byWeekNo
  byYearDay
  calendarEntries
  count
  description
  duration
  endDateTime
  entryType
  freq
  hierarchyScope
  interval
  isActive
  properties
  startDateTime
  wkst
  workCalendar
}

input WorkCalendarDefinitionEntryOrder {
  asc: WorkCalendarDefinitionEntryOrderable
  desc: WorkCalendarDefinitionEntryOrderable
  then: WorkCalendarDefinitionEntryOrder
}

enum WorkCalendarDefinitionEntryOrderable {
  count
  description
  duration
  endDateTime
  interval
  startDateTime
}

input WorkCalendarDefinitionEntryPatch {
  byHour: [Int]
  byMinute: [Int]
  byMonth: [Int]
  byMonthDay: [Int]
  bySecond: [Int]
  bySetPos: [Int]
  byWeekDay: [Weekday]
  byWeekNo: [Int]
  byYearDay: [Int]
  calendarEntries: [WorkCalendarEntryRef]
  count: Int
  description: String
  duration: String
  endDateTime: DateTime
  entryType: WorkCalendarEntryType
  freq: Frequency
  hierarchyScope: EquipmentRef
  interval: Int
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  wkst: Weekday
  workCalendar: WorkCalendarRef
}

input WorkCalendarDefinitionEntryRef {
  byHour: [Int]
  byMinute: [Int]
  byMonth: [Int]
  byMonthDay: [Int]
  bySecond: [Int]
  bySetPos: [Int]
  byWeekDay: [Weekday]
  byWeekNo: [Int]
  byYearDay: [Int]
  calendarEntries: [WorkCalendarEntryRef]
  count: Int
  description: String
  duration: String
  endDateTime: DateTime
  entryType: WorkCalendarEntryType
  freq: Frequency
  hierarchyScope: EquipmentRef
  id: ID
  interval: Int
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  wkst: Weekday
  workCalendar: WorkCalendarRef
}

type WorkCalendarEntry
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  definition(filter: WorkCalendarDefinitionEntryFilter): WorkCalendarDefinitionEntry @join__field(graph: SCHEMA)
  description: String @join__field(graph: SCHEMA)
  elapsedDuration: Int @join__field(graph: CORE, requires: "startDateTime finishDateTime")
  entryType: WorkCalendarEntryType! @join__field(graph: SCHEMA)
  finishDateTime: DateTime! @join__field(graph: SCHEMA)
  hierarchyScope(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  properties(filter: PropertyFilter, first: Int, offset: Int, order: PropertyOrder): [Property] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: PropertyFilter): PropertyAggregateResult @join__field(graph: SCHEMA)
  startDateTime: DateTime! @join__field(graph: SCHEMA)
  workCalendar(filter: WorkCalendarFilter): WorkCalendar @join__field(graph: SCHEMA)
}

type WorkCalendarEntryAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
  finishDateTimeMax: DateTime
  finishDateTimeMin: DateTime
  startDateTimeMax: DateTime
  startDateTimeMin: DateTime
}

input WorkCalendarEntryFilter {
  and: [WorkCalendarEntryFilter]
  entryType: WorkCalendarEntryType_hash
  finishDateTime: DateTimeFilter
  has: [WorkCalendarEntryHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkCalendarEntryFilter
  or: [WorkCalendarEntryFilter]
  startDateTime: DateTimeFilter
}

enum WorkCalendarEntryHasFilter {
  definition
  description
  entryType
  finishDateTime
  hierarchyScope
  isActive
  properties
  startDateTime
  workCalendar
}

input WorkCalendarEntryOrder {
  asc: WorkCalendarEntryOrderable
  desc: WorkCalendarEntryOrderable
  then: WorkCalendarEntryOrder
}

enum WorkCalendarEntryOrderable {
  description
  finishDateTime
  startDateTime
}

input WorkCalendarEntryPatch {
  definition: WorkCalendarDefinitionEntryRef
  description: String
  entryType: WorkCalendarEntryType
  finishDateTime: DateTime
  hierarchyScope: EquipmentRef
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  workCalendar: WorkCalendarRef
}

input WorkCalendarEntryRef {
  definition: WorkCalendarDefinitionEntryRef
  description: String
  entryType: WorkCalendarEntryType
  finishDateTime: DateTime
  hierarchyScope: EquipmentRef
  id: ID
  isActive: Boolean
  properties: [PropertyRef]
  startDateTime: DateTime
  workCalendar: WorkCalendarRef
}

enum WorkCalendarEntryType {
  PlannedBusyTime
  PlannedDowntime
  PlannedShutdown
}

input WorkCalendarEntryType_hash {
  eq: WorkCalendarEntryType
  in: [WorkCalendarEntryType]
}

input WorkCalendarFilter {
  and: [WorkCalendarFilter]
  has: [WorkCalendarHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkCalendarFilter
  or: [WorkCalendarFilter]
}

enum WorkCalendarHasFilter {
  definition
  description
  entries
  equipment
  isActive
  name
}

input WorkCalendarOrder {
  asc: WorkCalendarOrderable
  desc: WorkCalendarOrderable
  then: WorkCalendarOrder
}

enum WorkCalendarOrderable {
  description
  name
}

input WorkCalendarPatch {
  definition: [WorkCalendarDefinitionEntryRef]
  description: String
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
  isActive: Boolean
  name: String
}

input WorkCalendarRef {
  definition: [WorkCalendarDefinitionEntryRef]
  description: String
  entries: [WorkCalendarEntryRef]
  equipment: [EquipmentRef]
  id: ID
  isActive: Boolean
  name: String
}

type WorkflowConnection
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  condition: String @join__field(graph: SCHEMA)
  connectionType(filter: WorkflowConnectionTypeFilter): WorkflowConnectionType! @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  from(filter: WorkflowNodeFilter): WorkflowNode! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  properties(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: WorkflowPropertyFilter): WorkflowPropertyAggregateResult @join__field(graph: SCHEMA)
  to(filter: WorkflowNodeFilter): WorkflowNode! @join__field(graph: SCHEMA)
  workflowSpecification(filter: WorkflowSpecificationFilter): WorkflowSpecification! @join__field(graph: SCHEMA)
}

type WorkflowConnectionAggregateResult {
  conditionMax: String
  conditionMin: String
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowConnectionFilter {
  and: [WorkflowConnectionFilter]
  has: [WorkflowConnectionHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowConnectionFilter
  or: [WorkflowConnectionFilter]
}

enum WorkflowConnectionHasFilter {
  access
  condition
  connectionType
  createdBy
  createdDateTime
  from
  isActive
  modifiedBy
  modifiedDateTime
  properties
  to
  workflowSpecification
}

input WorkflowConnectionOrder {
  asc: WorkflowConnectionOrderable
  desc: WorkflowConnectionOrderable
  then: WorkflowConnectionOrder
}

enum WorkflowConnectionOrderable {
  condition
  createdDateTime
  modifiedDateTime
}

input WorkflowConnectionPatch {
  access: [ACLRef]
  condition: String
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  from: WorkflowNodeRef
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  properties: [WorkflowPropertyRef]
  to: WorkflowNodeRef
  workflowSpecification: WorkflowSpecificationRef
}

input WorkflowConnectionRef {
  access: [ACLRef]
  condition: String
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  from: WorkflowNodeRef
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  properties: [WorkflowPropertyRef]
  to: WorkflowNodeRef
  workflowSpecification: WorkflowSpecificationRef
}

type WorkflowConnectionType
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  connections(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection] @join__field(graph: SCHEMA)
  connectionsAggregate(filter: WorkflowConnectionFilter): WorkflowConnectionAggregateResult @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  description: String! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  properties(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: WorkflowPropertyFilter): WorkflowPropertyAggregateResult @join__field(graph: SCHEMA)
}

type WorkflowConnectionTypeAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
}

input WorkflowConnectionTypeFilter {
  and: [WorkflowConnectionTypeFilter]
  has: [WorkflowConnectionTypeHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowConnectionTypeFilter
  or: [WorkflowConnectionTypeFilter]
}

enum WorkflowConnectionTypeHasFilter {
  access
  connections
  createdBy
  createdDateTime
  description
  isActive
  modifiedBy
  modifiedDateTime
  name
  properties
}

input WorkflowConnectionTypeOrder {
  asc: WorkflowConnectionTypeOrderable
  desc: WorkflowConnectionTypeOrderable
  then: WorkflowConnectionTypeOrder
}

enum WorkflowConnectionTypeOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
}

input WorkflowConnectionTypePatch {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  properties: [WorkflowPropertyRef]
}

input WorkflowConnectionTypeRef {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  properties: [WorkflowPropertyRef]
}

type WorkflowInstance
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  children(filter: WorkflowInstanceFilter, first: Int, offset: Int, order: WorkflowInstanceOrder): [WorkflowInstance] @join__field(graph: SCHEMA)
  childrenAggregate(filter: WorkflowInstanceFilter): WorkflowInstanceAggregateResult @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  equipment(filter: EquipmentFilter): Equipment @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  nodeInstances(filter: WorkflowNodeInstanceFilter, first: Int, offset: Int, order: WorkflowNodeInstanceOrder): [WorkflowNodeInstance] @join__field(graph: SCHEMA)
  nodeInstancesAggregate(filter: WorkflowNodeInstanceFilter): WorkflowNodeInstanceAggregateResult @join__field(graph: SCHEMA)
  orderLines(filter: OrderLineFilter, first: Int, offset: Int, order: OrderLineOrder): [OrderLine] @join__field(graph: SCHEMA)
  orderLinesAggregate(filter: OrderLineFilter): OrderLineAggregateResult @join__field(graph: SCHEMA)
  parent(filter: WorkflowInstanceFilter): WorkflowInstance @join__field(graph: SCHEMA)
  properties(filter: WorkflowInstancePropertyFilter, first: Int, offset: Int, order: WorkflowInstancePropertyOrder): [WorkflowInstanceProperty] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: WorkflowInstancePropertyFilter): WorkflowInstancePropertyAggregateResult @join__field(graph: SCHEMA)
  propertyInstances(filter: WorkflowPropertyInstanceFilter, first: Int, offset: Int, order: WorkflowPropertyInstanceOrder): [WorkflowPropertyInstance] @join__field(graph: SCHEMA)
  propertyInstancesAggregate(filter: WorkflowPropertyInstanceFilter): WorkflowPropertyInstanceAggregateResult @join__field(graph: SCHEMA)
  status: WorkflowNodeStatus @join__field(graph: SCHEMA)
  workflowSpecification(filter: WorkflowSpecificationFilter): WorkflowSpecification @join__field(graph: SCHEMA)
}

type WorkflowInstanceAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowInstanceFilter {
  and: [WorkflowInstanceFilter]
  createdDateTime: DateTimeFilter
  has: [WorkflowInstanceHasFilter]
  id: [ID!]
  not: WorkflowInstanceFilter
  or: [WorkflowInstanceFilter]
  status: WorkflowNodeStatus_hash
}

enum WorkflowInstanceHasFilter {
  children
  createdBy
  createdDateTime
  equipment
  modifiedBy
  modifiedDateTime
  nodeInstances
  orderLines
  parent
  properties
  propertyInstances
  status
  workflowSpecification
}

input WorkflowInstanceOrder {
  asc: WorkflowInstanceOrderable
  desc: WorkflowInstanceOrderable
  then: WorkflowInstanceOrder
}

enum WorkflowInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowInstancePatch {
  children: [WorkflowInstanceRef]
  createdBy: UserRef
  createdDateTime: DateTime
  equipment: EquipmentRef
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  nodeInstances: [WorkflowNodeInstanceRef]
  orderLines: [OrderLineRef]
  parent: WorkflowInstanceRef
  properties: [WorkflowInstancePropertyRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
}

type WorkflowInstanceProperty
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  id: ID! @join__field(graph: SCHEMA)
  key: String! @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  values(filter: WorkflowPropertyValueFilter, first: Int, offset: Int, order: WorkflowPropertyValueOrder): [WorkflowPropertyValue] @join__field(graph: SCHEMA)
  valuesAggregate(filter: WorkflowPropertyValueFilter): WorkflowPropertyValueAggregateResult @join__field(graph: SCHEMA)
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance @join__field(graph: SCHEMA)
}

type WorkflowInstancePropertyAggregateResult {
  count: Int
  keyMax: String
  keyMin: String
  nameMax: String
  nameMin: String
}

input WorkflowInstancePropertyFilter {
  and: [WorkflowInstancePropertyFilter]
  has: [WorkflowInstancePropertyHasFilter]
  id: [ID!]
  key: StringHashFilter
  not: WorkflowInstancePropertyFilter
  or: [WorkflowInstancePropertyFilter]
}

enum WorkflowInstancePropertyHasFilter {
  key
  name
  values
  workflowInstance
}

input WorkflowInstancePropertyOrder {
  asc: WorkflowInstancePropertyOrderable
  desc: WorkflowInstancePropertyOrderable
  then: WorkflowInstancePropertyOrder
}

enum WorkflowInstancePropertyOrderable {
  key
  name
}

input WorkflowInstancePropertyPatch {
  key: String
  name: String
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
}

input WorkflowInstancePropertyRef {
  id: ID
  key: String
  name: String
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
}

input WorkflowInstanceRef {
  children: [WorkflowInstanceRef]
  createdBy: UserRef
  createdDateTime: DateTime
  equipment: EquipmentRef
  id: ID
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  nodeInstances: [WorkflowNodeInstanceRef]
  orderLines: [OrderLineRef]
  parent: WorkflowInstanceRef
  properties: [WorkflowInstancePropertyRef]
  propertyInstances: [WorkflowPropertyInstanceRef]
  status: WorkflowNodeStatus
  workflowSpecification: WorkflowSpecificationRef
}

type WorkflowNode
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  description: String! @join__field(graph: SCHEMA)
  form(filter: FormFilter): Form @join__field(graph: SCHEMA)
  height: Int @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  inflows(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection] @join__field(graph: SCHEMA)
  inflowsAggregate(filter: WorkflowConnectionFilter): WorkflowConnectionAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  nodeInstances(filter: WorkflowNodeInstanceFilter, first: Int, offset: Int, order: WorkflowNodeInstanceOrder): [WorkflowNodeInstance] @join__field(graph: SCHEMA)
  nodeInstancesAggregate(filter: WorkflowNodeInstanceFilter): WorkflowNodeInstanceAggregateResult @join__field(graph: SCHEMA)
  nodeType(filter: WorkflowNodeTypeFilter): WorkflowNodeType! @join__field(graph: SCHEMA)
  outflows(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection] @join__field(graph: SCHEMA)
  outflowsAggregate(filter: WorkflowConnectionFilter): WorkflowConnectionAggregateResult @join__field(graph: SCHEMA)
  positionX: Int @join__field(graph: SCHEMA)
  positionY: Int @join__field(graph: SCHEMA)
  properties(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: WorkflowPropertyFilter): WorkflowPropertyAggregateResult @join__field(graph: SCHEMA)
  role(filter: RoleFilter): Role @join__field(graph: SCHEMA)
  uiComponent: String @join__field(graph: SCHEMA)
  width: Int @join__field(graph: SCHEMA)
  workflowSpecification(filter: WorkflowSpecificationFilter): WorkflowSpecification! @join__field(graph: SCHEMA)
}

type WorkflowNodeAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  heightAvg: Float
  heightMax: Int
  heightMin: Int
  heightSum: Int
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
  positionXAvg: Float
  positionXMax: Int
  positionXMin: Int
  positionXSum: Int
  positionYAvg: Float
  positionYMax: Int
  positionYMin: Int
  positionYSum: Int
  uiComponentMax: String
  uiComponentMin: String
  widthAvg: Float
  widthMax: Int
  widthMin: Int
  widthSum: Int
}

enum WorkflowNodeClass {
  EVENT_END
  EVENT_INTERMEDIATE
  EVENT_START
  GATEWAY
  SUBPROCESS
  TASK_SYSTEM
  TASK_USER
}

type WorkflowNodeEvent
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  isProcessed: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  next(filter: WorkflowNodeEventFilter): WorkflowNodeEvent @join__field(graph: SCHEMA)
  nodeInstance(filter: WorkflowNodeInstanceFilter): WorkflowNodeInstance @join__field(graph: SCHEMA)
  previous(filter: WorkflowNodeEventFilter): WorkflowNodeEvent @join__field(graph: SCHEMA)
  status: WorkflowNodeStatus @join__field(graph: SCHEMA)
  value: String @join__field(graph: SCHEMA)
}

type WorkflowNodeEventAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  valueMax: String
  valueMin: String
}

input WorkflowNodeEventFilter {
  and: [WorkflowNodeEventFilter]
  createdDateTime: DateTimeFilter
  has: [WorkflowNodeEventHasFilter]
  id: [ID!]
  isActive: Boolean
  isProcessed: Boolean
  not: WorkflowNodeEventFilter
  or: [WorkflowNodeEventFilter]
  status: WorkflowNodeStatus_hash
}

enum WorkflowNodeEventHasFilter {
  access
  createdBy
  createdDateTime
  isActive
  isProcessed
  modifiedBy
  modifiedDateTime
  next
  nodeInstance
  previous
  status
  value
}

input WorkflowNodeEventOrder {
  asc: WorkflowNodeEventOrderable
  desc: WorkflowNodeEventOrderable
  then: WorkflowNodeEventOrder
}

enum WorkflowNodeEventOrderable {
  createdDateTime
  modifiedDateTime
  value
}

input WorkflowNodeEventPatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  isProcessed: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowNodeEventRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  value: String
}

input WorkflowNodeEventRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  id: ID
  isActive: Boolean
  isProcessed: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowNodeEventRef
  nodeInstance: WorkflowNodeInstanceRef
  previous: WorkflowNodeEventRef
  status: WorkflowNodeStatus
  value: String
}

input WorkflowNodeFilter {
  and: [WorkflowNodeFilter]
  has: [WorkflowNodeHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkflowNodeFilter
  or: [WorkflowNodeFilter]
}

enum WorkflowNodeHasFilter {
  access
  createdBy
  createdDateTime
  description
  form
  height
  inflows
  isActive
  modifiedBy
  modifiedDateTime
  name
  nodeInstances
  nodeType
  outflows
  positionX
  positionY
  properties
  role
  uiComponent
  width
  workflowSpecification
}

type WorkflowNodeInstance
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  assignedUser(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  duration: Int @join__field(graph: CORE)
  events(filter: WorkflowNodeEventFilter, first: Int, offset: Int, order: WorkflowNodeEventOrder): [WorkflowNodeEvent] @join__field(graph: SCHEMA)
  eventsAggregate(filter: WorkflowNodeEventFilter): WorkflowNodeEventAggregateResult @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  node(filter: WorkflowNodeFilter): WorkflowNode! @join__field(graph: SCHEMA)
  status: WorkflowNodeStatus @join__field(graph: SCHEMA)
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance! @join__field(graph: SCHEMA)
}

type WorkflowNodeInstanceAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowNodeInstanceFilter {
  and: [WorkflowNodeInstanceFilter]
  createdDateTime: DateTimeFilter
  has: [WorkflowNodeInstanceHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowNodeInstanceFilter
  or: [WorkflowNodeInstanceFilter]
  status: WorkflowNodeStatus_hash
}

enum WorkflowNodeInstanceHasFilter {
  access
  assignedUser
  createdBy
  createdDateTime
  events
  isActive
  modifiedBy
  modifiedDateTime
  node
  status
  workflowInstance
}

input WorkflowNodeInstanceOrder {
  asc: WorkflowNodeInstanceOrderable
  desc: WorkflowNodeInstanceOrderable
  then: WorkflowNodeInstanceOrder
}

enum WorkflowNodeInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowNodeInstancePatch {
  access: [ACLRef]
  assignedUser: UserRef
  createdBy: UserRef
  createdDateTime: DateTime
  events: [WorkflowNodeEventRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  node: WorkflowNodeRef
  status: WorkflowNodeStatus
  workflowInstance: WorkflowInstanceRef
}

input WorkflowNodeInstanceRef {
  access: [ACLRef]
  assignedUser: UserRef
  createdBy: UserRef
  createdDateTime: DateTime
  events: [WorkflowNodeEventRef]
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  node: WorkflowNodeRef
  status: WorkflowNodeStatus
  workflowInstance: WorkflowInstanceRef
}

input WorkflowNodeOrder {
  asc: WorkflowNodeOrderable
  desc: WorkflowNodeOrderable
  then: WorkflowNodeOrder
}

enum WorkflowNodeOrderable {
  createdDateTime
  description
  height
  modifiedDateTime
  name
  positionX
  positionY
  uiComponent
  width
}

input WorkflowNodePatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  form: FormRef
  height: Int
  inflows: [WorkflowConnectionRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeInstances: [WorkflowNodeInstanceRef]
  nodeType: WorkflowNodeTypeRef
  outflows: [WorkflowConnectionRef]
  positionX: Int
  positionY: Int
  properties: [WorkflowPropertyRef]
  role: RoleRef
  uiComponent: String
  width: Int
  workflowSpecification: WorkflowSpecificationRef
}

input WorkflowNodeRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  form: FormRef
  height: Int
  id: ID
  inflows: [WorkflowConnectionRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeInstances: [WorkflowNodeInstanceRef]
  nodeType: WorkflowNodeTypeRef
  outflows: [WorkflowConnectionRef]
  positionX: Int
  positionY: Int
  properties: [WorkflowPropertyRef]
  role: RoleRef
  uiComponent: String
  width: Int
  workflowSpecification: WorkflowSpecificationRef
}

enum WorkflowNodeStatus {
  CLAIMED
  COMPLETED
  CREATED
  PAUSED
  STARTED
}

input WorkflowNodeStatus_hash {
  eq: WorkflowNodeStatus
  in: [WorkflowNodeStatus]
}

type WorkflowNodeType
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  description: String! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  nodeClass: WorkflowNodeClass! @join__field(graph: SCHEMA)
  nodes(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode] @join__field(graph: SCHEMA)
  nodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult @join__field(graph: SCHEMA)
  properties(filter: WorkflowPropertyFilter, first: Int, offset: Int, order: WorkflowPropertyOrder): [WorkflowProperty] @join__field(graph: SCHEMA)
  propertiesAggregate(filter: WorkflowPropertyFilter): WorkflowPropertyAggregateResult @join__field(graph: SCHEMA)
}

type WorkflowNodeTypeAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
}

input WorkflowNodeTypeFilter {
  and: [WorkflowNodeTypeFilter]
  has: [WorkflowNodeTypeHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowNodeTypeFilter
  or: [WorkflowNodeTypeFilter]
}

enum WorkflowNodeTypeHasFilter {
  access
  createdBy
  createdDateTime
  description
  isActive
  modifiedBy
  modifiedDateTime
  name
  nodeClass
  nodes
  properties
}

input WorkflowNodeTypeOrder {
  asc: WorkflowNodeTypeOrderable
  desc: WorkflowNodeTypeOrderable
  then: WorkflowNodeTypeOrder
}

enum WorkflowNodeTypeOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
}

input WorkflowNodeTypePatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeClass: WorkflowNodeClass
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

input WorkflowNodeTypeRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodeClass: WorkflowNodeClass
  nodes: [WorkflowNodeRef]
  properties: [WorkflowPropertyRef]
}

type WorkflowProperty
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
  @join__type(graph: CORE, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  connection(filter: WorkflowConnectionFilter): WorkflowConnection @join__field(graph: SCHEMA)
  connectionType(filter: WorkflowConnectionTypeFilter): WorkflowConnectionType @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  dataType: DataType @join__field(graph: SCHEMA)
  definedBy(filter: WorkflowPropertyFilter): WorkflowProperty @join__field(graph: SCHEMA)
  description: String! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  instances(filter: WorkflowPropertyInstanceFilter, first: Int, offset: Int, order: WorkflowPropertyInstanceOrder): [WorkflowPropertyInstance] @join__field(graph: SCHEMA)
  instancesAggregate(filter: WorkflowPropertyInstanceFilter): WorkflowPropertyInstanceAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  node(filter: WorkflowNodeFilter): WorkflowNode @join__field(graph: SCHEMA)
  nodeType(filter: WorkflowNodeTypeFilter): WorkflowNodeType @join__field(graph: SCHEMA)
  propertyType: WorkflowPropertyType! @join__field(graph: SCHEMA)
  unitOfMeasure(filter: UnitOfMeasureFilter): UnitOfMeasure @join__field(graph: SCHEMA)
  value: String @join__field(graph: SCHEMA)
}

type WorkflowPropertyAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
  valueMax: String
  valueMin: String
}

input WorkflowPropertyFilter {
  and: [WorkflowPropertyFilter]
  description: StringHashFilter
  has: [WorkflowPropertyHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkflowPropertyFilter
  or: [WorkflowPropertyFilter]
}

enum WorkflowPropertyHasFilter {
  access
  connection
  connectionType
  createdBy
  createdDateTime
  dataType
  definedBy
  description
  instances
  isActive
  modifiedBy
  modifiedDateTime
  name
  node
  nodeType
  propertyType
  unitOfMeasure
  value
}

type WorkflowPropertyInstance
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  values(filter: WorkflowPropertyValueFilter, first: Int, offset: Int, order: WorkflowPropertyValueOrder): [WorkflowPropertyValue] @join__field(graph: SCHEMA)
  valuesAggregate(filter: WorkflowPropertyValueFilter): WorkflowPropertyValueAggregateResult @join__field(graph: SCHEMA)
  workflowInstance(filter: WorkflowInstanceFilter): WorkflowInstance @join__field(graph: SCHEMA)
  workflowProperty(filter: WorkflowPropertyFilter): WorkflowProperty @join__field(graph: SCHEMA)
}

type WorkflowPropertyInstanceAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
}

input WorkflowPropertyInstanceFilter {
  and: [WorkflowPropertyInstanceFilter]
  has: [WorkflowPropertyInstanceHasFilter]
  id: [ID!]
  isActive: Boolean
  not: WorkflowPropertyInstanceFilter
  or: [WorkflowPropertyInstanceFilter]
}

enum WorkflowPropertyInstanceHasFilter {
  access
  createdBy
  createdDateTime
  isActive
  modifiedBy
  modifiedDateTime
  values
  workflowInstance
  workflowProperty
}

input WorkflowPropertyInstanceOrder {
  asc: WorkflowPropertyInstanceOrderable
  desc: WorkflowPropertyInstanceOrderable
  then: WorkflowPropertyInstanceOrder
}

enum WorkflowPropertyInstanceOrderable {
  createdDateTime
  modifiedDateTime
}

input WorkflowPropertyInstancePatch {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
}

input WorkflowPropertyInstanceRef {
  access: [ACLRef]
  createdBy: UserRef
  createdDateTime: DateTime
  id: ID
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  values: [WorkflowPropertyValueRef]
  workflowInstance: WorkflowInstanceRef
  workflowProperty: WorkflowPropertyRef
}

input WorkflowPropertyOrder {
  asc: WorkflowPropertyOrderable
  desc: WorkflowPropertyOrderable
  then: WorkflowPropertyOrder
}

enum WorkflowPropertyOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
  value
}

input WorkflowPropertyPatch {
  access: [ACLRef]
  connection: WorkflowConnectionRef
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  dataType: DataType
  definedBy: WorkflowPropertyRef
  description: String
  instances: [WorkflowPropertyInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  node: WorkflowNodeRef
  nodeType: WorkflowNodeTypeRef
  propertyType: WorkflowPropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

input WorkflowPropertyRef {
  access: [ACLRef]
  connection: WorkflowConnectionRef
  connectionType: WorkflowConnectionTypeRef
  createdBy: UserRef
  createdDateTime: DateTime
  dataType: DataType
  definedBy: WorkflowPropertyRef
  description: String
  id: ID
  instances: [WorkflowPropertyInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  node: WorkflowNodeRef
  nodeType: WorkflowNodeTypeRef
  propertyType: WorkflowPropertyType
  unitOfMeasure: UnitOfMeasureRef
  value: String
}

enum WorkflowPropertyType {
  CONFIG
  STATIC
  VARIABLE
}

type WorkflowPropertyValue
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  next(filter: WorkflowPropertyValueFilter): WorkflowPropertyValue @join__field(graph: SCHEMA)
  previous(filter: WorkflowPropertyValueFilter): WorkflowPropertyValue @join__field(graph: SCHEMA)
  propertyInstance(filter: WorkflowPropertyInstanceFilter): WorkflowPropertyInstance! @join__field(graph: SCHEMA)
  value: String @join__field(graph: SCHEMA)
}

type WorkflowPropertyValueAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  valueMax: String
  valueMin: String
}

input WorkflowPropertyValueFilter {
  and: [WorkflowPropertyValueFilter]
  has: [WorkflowPropertyValueHasFilter]
  id: [ID!]
  not: WorkflowPropertyValueFilter
  or: [WorkflowPropertyValueFilter]
}

enum WorkflowPropertyValueHasFilter {
  createdBy
  createdDateTime
  modifiedBy
  modifiedDateTime
  next
  previous
  propertyInstance
  value
}

input WorkflowPropertyValueOrder {
  asc: WorkflowPropertyValueOrderable
  desc: WorkflowPropertyValueOrderable
  then: WorkflowPropertyValueOrder
}

enum WorkflowPropertyValueOrderable {
  createdDateTime
  modifiedDateTime
  value
}

input WorkflowPropertyValuePatch {
  createdBy: UserRef
  createdDateTime: DateTime
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowPropertyValueRef
  previous: WorkflowPropertyValueRef
  propertyInstance: WorkflowPropertyInstanceRef
  value: String
}

input WorkflowPropertyValueRef {
  createdBy: UserRef
  createdDateTime: DateTime
  id: ID
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  next: WorkflowPropertyValueRef
  previous: WorkflowPropertyValueRef
  propertyInstance: WorkflowPropertyInstanceRef
  value: String
}

type WorkflowSpecification
  @join__owner(graph: SCHEMA)
  @join__type(graph: SCHEMA, key: "id")
{
  access(filter: ACLFilter, first: Int, offset: Int): [ACL] @join__field(graph: SCHEMA)
  accessAggregate(filter: ACLFilter): ACLAggregateResult @join__field(graph: SCHEMA)
  connections(filter: WorkflowConnectionFilter, first: Int, offset: Int, order: WorkflowConnectionOrder): [WorkflowConnection] @join__field(graph: SCHEMA)
  connectionsAggregate(filter: WorkflowConnectionFilter): WorkflowConnectionAggregateResult @join__field(graph: SCHEMA)
  createdBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  createdDateTime: DateTime @join__field(graph: SCHEMA)
  description: String! @join__field(graph: SCHEMA)
  id: ID! @join__field(graph: SCHEMA)
  instances(filter: WorkflowInstanceFilter, first: Int, offset: Int, order: WorkflowInstanceOrder): [WorkflowInstance] @join__field(graph: SCHEMA)
  instancesAggregate(filter: WorkflowInstanceFilter): WorkflowInstanceAggregateResult @join__field(graph: SCHEMA)
  isActive: Boolean @join__field(graph: SCHEMA)
  modifiedBy(filter: UserFilter): User @join__field(graph: SCHEMA)
  modifiedDateTime: DateTime @join__field(graph: SCHEMA)
  name: String! @join__field(graph: SCHEMA)
  nodes(filter: WorkflowNodeFilter, first: Int, offset: Int, order: WorkflowNodeOrder): [WorkflowNode] @join__field(graph: SCHEMA)
  nodesAggregate(filter: WorkflowNodeFilter): WorkflowNodeAggregateResult @join__field(graph: SCHEMA)
}

type WorkflowSpecificationAggregateResult {
  count: Int
  createdDateTimeMax: DateTime
  createdDateTimeMin: DateTime
  descriptionMax: String
  descriptionMin: String
  modifiedDateTimeMax: DateTime
  modifiedDateTimeMin: DateTime
  nameMax: String
  nameMin: String
}

input WorkflowSpecificationFilter {
  and: [WorkflowSpecificationFilter]
  has: [WorkflowSpecificationHasFilter]
  id: [ID!]
  isActive: Boolean
  name: StringHashFilter
  not: WorkflowSpecificationFilter
  or: [WorkflowSpecificationFilter]
}

enum WorkflowSpecificationHasFilter {
  access
  connections
  createdBy
  createdDateTime
  description
  instances
  isActive
  modifiedBy
  modifiedDateTime
  name
  nodes
}

input WorkflowSpecificationOrder {
  asc: WorkflowSpecificationOrderable
  desc: WorkflowSpecificationOrderable
  then: WorkflowSpecificationOrder
}

enum WorkflowSpecificationOrderable {
  createdDateTime
  description
  modifiedDateTime
  name
}

input WorkflowSpecificationPatch {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  instances: [WorkflowInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodes: [WorkflowNodeRef]
}

input WorkflowSpecificationRef {
  access: [ACLRef]
  connections: [WorkflowConnectionRef]
  createdBy: UserRef
  createdDateTime: DateTime
  description: String
  id: ID
  instances: [WorkflowInstanceRef]
  isActive: Boolean
  modifiedBy: UserRef
  modifiedDateTime: DateTime
  name: String
  nodes: [WorkflowNodeRef]
}

"""
An identification of the resources and workflow required to perform a specified unit of work
shall be defined as a work definition. The work definition may apply to production, maintenance, quality and inventory
activities.
"""
enum WorkType {
  Inventory
  Maintenance
  Mixed
  Production
  Quality
}

input WorkType_hash {
  eq: WorkType
  in: [WorkType]
}
